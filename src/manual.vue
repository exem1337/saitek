<template>
<div class="wrapper">
    <div class="header">
        <div class="logo">Инструментальные средства программирования на языке С++</div>
    </div>
    <div class="menu">
    	<h4 data-id="page-date" class="single">Выходные данные</h4>
        <h4 data-id="page-intro" class="single">Введение</h4>
        <h4 data-id="page1">Глава 1. Введение в С++</h4>
        <ul class="collapse listStile">
            <li>1.1 Основные понятия алгоритмизации</li>
            <li class="level-2">1.1.1 Понятие алгоритма</li>
            <li class="level-2">1.1.2 Понятие схема алгоритма</li>
            <li class="level-2">1.1.3 Разработка линейных структур алгоритмов</li>
            <li class="level-2">1.1.4 Разработка разветвляющихся структур алгоритмов</li>
            <li class="level-2">1.1.5 Разработка циклических структур алгоритмов</li>
            <li>1.2 Основы работы со средой MS Visual Studio</li>
            <li class="level-2">1.2.1 Создание консольного приложения</li>
            <li class="level-2">1.2.2 Структура программы на языке C++</li>
            <li>1.3 Основы языка С++</li>
            <li class="level-2">1.3.1 Стандартные типы данных языка C++</li>
            <li class="level-2">1.3.2 Переменные</li>
            <li class="level-2">1.3.3 Константы</li>
            <li class="level-2">1.3.4 Управляющие последовательности</li>
            <li class="level-2">1.3.5 Комментарии</li>
            <li>1.4 Стандартные операторы и функции языка С++</li>
            <li class="level-2">1.4.1 Арифметические операции в С++</li>
            <li class="level-3">1.4.1.1 Сложение в С++</li>
            <li class="level-3">1.4.1.2 Вычитание в С++</li>
            <li class="level-3">1.4.1.3 Умножение в С++</li>
            <li class="level-3">1.4.1.4 Операция деления в С++</li>
            <li class="level-3">1.4.1.5 Инкремент и декремент в С++</li>
            <li class="level-2">1.4.2 Математические операторы и функции</li>
            <li class="level-3">1.4.2.1 Математические операторы</li>
            <li class="level-3">1.4.2.2 Побитовые операторы</li>
            <li class="level-3">1.4.2.3 Операторы сравнения</li>
            <li class="level-3">1.4.2.4 Операторы присваивания</li>
            <li class="level-3">1.4.2.5 Логические операторы</li>
            <li class="level-2">1.4.3 Условные операторы if и switch языка С++</li>
            <li class="level-3">1.4.3.1 Оператор ветвления if</li>
            <li class="level-3">1.4.3.2 Оператор ветвления else</li>
            <li class="level-3">1.4.3.3 Использование логических операторов при проверке условий</li>
            <li class="level-3">1.4.3.4 Оператор switch</li>
            <li class="level-2">1.4.4 Операторы цикла</li>
            <li class="level-3">1.4.4.1 Оператор цикла for</li>
            <li class="level-3">1.4.4.2 Оператор цикла while</li>
            <li class="level-3">1.4.4.3 Оператор цикла do while</li>
            <li class="level-3">1.4.4.4 Вложенные циклы</li>
            <li class="level-3">1.4.4.5 Операторы break и continue</li>
            <li>1.5 Контрольные вопросы для закрепления изученного материала</li>
            <li class="scroll_top training-exercises" data-id="page1.6">1.6 Тренировочные упражнения</li>
            <li class="scroll_top" data-id="page1.7">1.7 Тестирование по первой главе</li>
            <li class="scroll_top" data-id="page1.8"><a href="javascript:runProgram()" target="_blank">1.8 Прогаммный компилятор</a></li>
        </ul>
        <h4 data-id="page2">Глава 2. Массивы</h4>
        <ul class="collapse">
            <li>2.1 Создание массивов</li>
            <li>2.2 Инициализация массивов</li>
            <li>2.3 Классификация массивов</li>
            <li>2.4 Одномерные массивы</li>
            <li>2.5 Двумерные массивы</li>
            <li>2.6 Обработка элементов массива</li>
            <li>2.7 Примеры работы с массивами</li>
            <li>2.8 Контрольные вопросы для закрепления изученного материала</li>
            <li class="scroll_top" data-id ="page2.9">2.9 Тренировочные упражнения<li>
            <li class="scroll_top" data-id="page2.10">2.10 Тестирование по второй главе</li>
        </ul>
        <h4 data-id="page3">Глава 3. Работа со строками в С++</h4>
        <ul class="collapse">
            <li>3.1 Инициализация строк</li>
            <li>3.2 Функции работы со строками</li>
            <li>3.3 Примеры работы со строками</li>
            <li>3.4 Контрольные вопросы для закрепления изученного материала</li>
            <li class="scroll_top training-exercises_1" data-id="page3.5">3.5 Тренировочные упражнения</li>
            <li class="scroll_top" data-id="page3.6">3.6 Тестирование по третьей главе</li>
        </ul>
        <h4 data-id="page4">Глава 4. Использование указателей в языке С++</h4>
        <ul class="collapse">
            <li>4.1 Инициализация указателей</li>
            <li>4.2 Использование указателей разных типов</li>
            <li>4.3 Указатели и структуры</li>
            <li>4.4 Выделение памяти</li>
            <li>4.5 Динамические массивы</li>
            <li>4.6 Ссылки</li>
            <li>4.7 Указатели на функции</li>
            <li>4.8 Контрольные вопросы для закрепления изученного материала</li>
            <li class="scroll_top" data-id="page4.9">4.9 Тренировочные упражнения</li>
            <li class="scroll_top" data-id="page4.10">4.10 Тестирование по четвертой главе</li>
        </ul>
        <h4 data-id="page5">Глава 5. Пользовательские функции в языке C++</h4>
        <ul class="collapse">
            <li>5.1 Объявление и определение функций</li>
            <li>5.2 Параметры функции</li>
            <li class="level-2">5.2.1 Параметры-значения</li>
            <li class="level-2">5.2.2 Параметры по умолчанию</li>
            <li class="level-2">5.2.3 Параметры-указатели</li>
            <li class="level-2">5.2.4 Параметры-ссылки</li>
            <li class="level-2">5.2.5 Передача массивов в качестве параметров</li>
            <li>5.3 Функции с переменным количеством аргументов</li>
            <li>5.4 Локальные, глобальные переменные</li>
            <li>5.5 Прототипы функций</li>
            <li>5.6 Перегрузка функций</li>
            <li>5.7 Рекурсия</li>
            <li>5.8 Практические примеры работы с функциями</li>
            <li>5.9 Контрольные вопросы для закрепления изученного материала</li>
            <li class="scroll_top" data-id="page5.10">5.10 Тренировочные упражнения</li>
            <li class="scroll_top" data-id="page5.11">5.11 Тестирование по пятой главе</li>
        </ul>
        <h4 data-id="page6">Глава 6. Работа с типами и структурами данных</h4>
        <ul class="collapse">
            <li>6.1 Структуры в языке С++</li>
            <li>6.2 Объединения, перечисления, оператор typedef</li>
            <li class="level-2">6.2.1 Объединения Union</li>
            <li class="level-2">6.2.2 Перечисляемые типы Enum</li>
            <li class="level-2">6.2.3 Типы, определяемые пользователем Typedef</li>
            <li>6.3 Контрольные вопросы для закрепления материала</li>
            <li class="scroll_top" data-id="page6.4">6.4 Тренировочные упражнения</li>
            <li class="scroll_top" data-id="page6.5">6.5 Тестирование по шестой главе</li>
        </ul>
        <h4 data-id="page7">Глава 7. Динамические структуры данных</h4>
        <ul class="collapse">
            <li>7.1 Линейные списки</li>
            <li class="level-2">7.1.1 Линейные односвязные списки</li>
            <li class="level-3">7.1.1.1 Создание линейного односвязного списка</li>
            <li class="level-3">7.1.1.2 Работа с линейными односвязными списками</li>
            <li class="level-2">7.1.2 Двухсвязные линейные списки</li>
            <li class="level-3">7.1.2.1 Создание двухсвязного линейного списка</li>
            <li class="level-3">7.1.2.2 Работа с двухсвязными линейными списками</li>
            <li class="level-2">7.1.3 Кольцевой список</li>
            <li>7.2 Использование стеков в С++</li>
            <li>7.3 Очереди</li>
            <li>7.4 Бинарные деревья</li>
            <li>7.5 Контрольные вопросы для закрепления изученного материала</li>
            <li class="scroll_top" data-id="page7.6">7.6 Тренировочные упражнения</li>
            <li class="scroll_top" data-id="page7.7">7.7 Тестирование по седьмой главе</li>
        </ul>
        <h4 data-id="page8">Глава 8. Работа с файлами в С++</h4>
        <ul class="collapse">
            <li>8.1 Функции записи и чтения из файлов</li>
            <li>8.2 Функции работы с позицией курсора</li>
            <li>8.3 Работа с бинарными файлами</li>
            <li>8.4 Удаление и переименование файлов</li>
            <li>8.5 Контрольные вопросы для закрепления изученного материала</li>
            <li class="scroll_top training-exercises_2" data-id="page8.6">8.6 Тренировочные упражнения</li>
            <li class="scroll_top" data-id="page8.7">8.7 Тестирование по восьмой главе</li>
        </ul>
        <h4 data-id="page9">Глава 9. Визуальное программирование в языке C++</h4>
        <ul class="collapse">
            <li>9.1 Технология WinAPI</li>
            <li class="level-2">9.1.1 Введение в технологию Win32 API</li>
            <li class="level-2">9.1.2 Структура оконного приложения</li>
            <li class="level-2">9.1.3 Элементы управления формами</li>
            <li class="level-3">9.1.3.1 Статический элемент</li>
            <li class="level-3">9.1.3.2 Кнопка</li>
            <li class="level-3">9.1.3.3 Поле редактирования</li>
            <li class="level-3">9.1.3.4 Окно-список</li>
            <li class="level-3">9.1.3.5 Выпадающий список</li>
            <li class="level-3">9.1.3.6 Диалоговые окна</li>
            <li class="level-2">9.1.4 Обработчик сообщений</li>
            <li class="level-2">9.1.5 Пример создания визуального приложения с помощью технологии WinAPI</li>
            <li>9.2 Microsoft Foundation Classes (MFC)</li>
            <li class="level-2">9.2.1 Основы MFC. Иерархия классов</li>
            <li class="level-2">9.2.2 Создание приложения MFC</li>
            <li class="level-3">9.2.2.1 Возможности инструментальной среды MS Visual Studio для создания оконных
                приложений
            </li>
            <li class="level-3">9.2.2.2 Этапы создания MFC приложения</li>
            <li class="level-3">9.2.2.3 Пример создания MFC приложения</li>
            <li>9.3 Контрольные вопросы для закрепления изученного материала</li>
            <li class="scroll_top" data-id="page9.4">9.4 Тренировочные упражнения</li>
            <li class="scroll_top" data-id="page9.5">9.5 Тестирование по девятой главе</li>
        </ul>
        <h4 data-id="page10">Глава 10. Введение в объектно-ориентированное программирование</h4>
        <ul class="collapse">
            <li>10.1 Основы объектно-ориентированного подхода</li>
            <li>10.2 Определение классов</li>
            <li>10.3 Методы класса</li>
            <li>10.4 Спецификаторы доступа public и private</li>
            <li>10.5 Функции доступа get и set</li>
            <li>10.6 Конструкторы</li>
            <li>10.7 Классы, содержащие другие классы</li>
            <li>10.8 Отделение интерфейса от реализации</li>
            
            <li>10.9 Инкапсуляция</li>
            <li>10.10.1 Наследование </li>
            <li>10.10.2 Базовое наследование</li>
            <li>10.10.3 Порядок построения дочерних классов</li>
            <li>10.10.4 Конструкторы и инициализация дочерних классов</li>
            <li>10.10.5 Указатели, ссылки и дочерние классы </li>
            <li>10.11 Полиморфизм</li>
            <li>10.11.1 Виртуальные функции и полиморфизм</li>
            <li>10.11.2 Использование конструктора protected</li>
            <li>10.12 Контрольные вопросы для закрепления изученного материала</li>
            <li class="scroll_top training-exercises_3" data-id="page10.3">10.13 Тренировочные упражнения</li>
            <li class="scroll_top" data-id="page10.4">10.14 Тестирование по десятой главе</li>
        </ul>
        <h4 data-id="page11">Итоговое тестирование</h4>
        <h4 data-id="page-conclusion" class="single">Заключение</h4>
        <h4 data-id="page-glossary" class="single">Глоссарий</h4>
        <h4 data-id="page-sources" class="single">Список использованных источников</h4>
        <h4 data-id ="page-program" class="single">О программе</h4>
    	<h5 data-id="page1-main" class="single"><a style='width:1000px; display:inline-block;' href="index.html" class="notpodcherk">На главную</a></h3>
        <p></p>
    </div>
    <div id="content" class="content">...</div>
</div>

<!-- PAGES -->
<!-- /page1 -->
<script id="page1" type="text/html">
    <h2 id="1">1 Введение в С++</h2>
    <h3 id="1.1">1.1 Основные понятия алгоритмизации</h3>
    <h3 id="1.1.1">1.1.1 Понятие алгоритма</h3>
    <p><a href="glossary.html#m1">Алгоритм</a> &#8211; последовательность чётко определенных действий, выполнение которых ведёт к решению задачи.
        Другими
        словами, алгоритм определяется как совокупность этапов, приводящих к достижению результата за конечное число
        шагов.
        Алгоритм, записанный на языке машины, есть программа решения задачи.</p>
    <p>Первое определение не передает полноты смысла понятия «алгоритм». Используемое слово «последовательность» сужает
        данное понятие, т. к. действия не обязательно должны следовать друг за другом &#8211; они могут повторяться или
        содержать условие <a href="source.html#metka1">[1]</a>. Алгоритмы обладают следующими свойствами:</p>
    <ol>
        <li class="with-a-bracket"><a href="glossary.html#m5">Дискретность</a> (от лат. discretus &#8211; разделенный, прерывистый) &#8211; это
            разбиение
            алгоритма на ряд
            отдельных законченных действий (шагов);
        </li>
        <li class="with-a-bracket"><a href="glossary.html#m5">Детерминированность</a> (от лат. determinate &#8211; определенность, точность) &#8211;
            любое
            действие алгоритма
            должно быть строго и недвусмысленно определено в каждом случае. Например, алгоритм проезда к другу, если к
            остановке подходят автобусы разных маршрутов, то в алгоритме должен быть указан конкретный номер маршрута 5.
            Кроме того, необходимо указать точное количество остановок, которое надо проехать, скажем, три;
        </li>
        <li class="with-a-bracket"><a href="glossary.html#m7">Конечность</a> &#8211; каждое действие в отдельности и алгоритм в целом должны иметь
            возможность завершения;
        </li>
        <li class="with-a-bracket"><a href="glossary.html#m8">Массовость</a> &#8211; один и тот же алгоритм можно использовать с разными исходными
            данными;
        </li>
        <li class="with-a-bracket"><a href="glossary.html#m10">Результативность</a> &#8211; алгоритм должен приводить к достоверному решению.</li>
    </ol>
    <p>Далее представлены примеры алгоритмов:</p>
    <ol>
        <li class="with-a-bracket">Любой прибор, купленный в магазине, снабжается инструкцией по его использованию.
            Данная
            инструкция и является
            алгоритмом для правильной эксплуатации прибора;
        </li>
        <li class="with-a-bracket">Каждый шофер должен знать правила дорожного движения. Правила дорожного движения
            однозначно регламентируют
            поведение каждого участника движения. Зная эти правила, шофер должен действовать по определенному алгоритму;
        </li>
        <li class="with-a-bracket">Массовый выпуск автомобилей стал возможен только тогда, когда был придуман порядок
            сборки
            машины на конвейере.
            Определенный порядок сборки автомобилей &#8211; это набор действий, в результате которых получается
            автомобиль.
        </li>
    </ol>
    <p>Существует несколько способов записи алгоритмов. На практике наиболее распространены следующие формы
        представления
        алгоритмов:</p>
    <ol>
        <li class="without-parentheses">словесная (запись на естественном языке);</li>
        <li class="without-parentheses">псевдокоды (полуформализованные описания алгоритмов на условном алгоритмическом
            языке, включающие в себя как
            элементы языка программирования, так и фразы естественного языка, общепринятые математические обозначения и
            др.);
        </li>
        <li class="without-parentheses">графическая (изображения из графических символов &#8211; схема алгоритма);</li>
        <li class="without-parentheses">программная (тексты на языках программирования &#8211; код программы).</li>
    </ol>
    <p>Рассмотрим подробно каждый вариант записи алгоритмов на примере следующей задачи: требуется найти частное двух
        чисел.</p>
    <p>Словесный способ записи алгоритмов представляет собой описание последовательных этапов обработки данных. Алгоритм
        задается в произвольном изложении на естественном языке. Ответ при этом получает человек, который выполняет
        команды,
        согласно словесной записи <a href="source.html#metka2">[2]</a>.</p>
    <p>Пример словесной записи:</p>
    <ol>
        <li class="with-a-bracket">задать два числа, являющиеся делимым и делителем;</li>
        <li class="with-a-bracket">проверить, равняется ли делитель нулю;</li>
        <li class="with-a-bracket">если делитель не равен нулю, то найти частное, записать его в ответ;</li>
        <li class="with-a-bracket">если делитель равен нулю, то в ответ записать «нет решения».</li>
    </ol>
    <p>Словесный способ не имеет широкого распространения, так как такие описания строго не формализуемы, страдают
        многословностью записей, допускают неоднозначность толкования отдельных предписаний <a href="source.html#metka2">[2]</a>.</p>
    <p>Псевдокод занимает промежуточное место между естественным и формальным языками. С одной стороны, он близок к
        обычному
        естественному языку, поэтому алгоритмы могут на нем записываться и читаться как обычный текст. С другой стороны,
        в
        псевдокоде используются некоторые формальные конструкции и математическая символика, что приближает запись
        алгоритма
        к общепринятой математической записи. В псевдокоде не приняты строгие синтаксические правила для записи команд,
        присущие формальным языкам, что облегчает запись алгоритма на стадии его проектирования и дает возможность
        использовать более широкий набор команд, рассчитанный на абстрактного исполнителя. Однако в псевдокоде обычно
        имеются некоторые конструкции, присущие формальным языкам, что облегчает переход от записи на псевдокоде к
        записи
        алгоритма на формальном языке. Основные управляющие структуры псевдокода приведены в таблице 1.1.</p>
    <p>Таблица 1.1 &#8211; Основные управляющие структуры псевдокода</p>
    <p class="tables"><img src="./img/1_chapter/table1.1.png" alt=""></p>
    <p>Пример псевдокода:</p>
    <pre class="cpp-code"><code class="language-cpp">алг Нахождение частного двух чисел
начало
вывод ("задайте делимое и делитель")
ввод (делимое, делитель)
если делитель ≠ 0
то частное = делимое / делитель
вывод(частное)
иначе вывод("нет решения")
кон алг Нахождение частного двух чисел</code></pre>
    <p>В данном примере используется три переменные: делимое, делитель и частное. Делимое и делитель задаются
        исполнителем
        произвольными числами. Частное считается лишь в том случае, если делитель не равен нулю.</p>
    <p>Графическая реализация алгоритма представляет собой схему алгоритма. <a href="glossary.html#m11">Схема алгоритма</a> состоит из блоков
        определенной
        формы, соединенных стрелками. Ответ при этом получает человек, который выполняет команды, согласно
        блок-схеме.</p>
    <p><a href="glossary.html#m9">Программная реализация алгоритма</a> &#8211; это компьютерная программа, написанная на каком-либо алгоритмическом
        языке
        программирования: С++, Pascal, Basic или других. Программа состоит из команд определенного языка
        программирования.
        Отметим, что одна и та же схема алгоритма может быть реализована на разных языках программирования. Ответ при
        этом
        получает ЭВМ, а не человек.
    </p>
    <h3 id="1.1.2">1.1.2 Понятие схема алгоритма</h3>
    <p>Схема алгоритма &#8211; это графическая реализация алгоритма. Схема алгоритма представляет собой удобный и
        наглядный
        способ записи алгоритма.</p>
    <p>Схема алгоритма состоит из функциональных блоков разной формы, связанных между собой стрелками. В каждом блоке
        описывается одно или несколько действий. Основные виды блоков представлены в таблице 1.2. Более подробно
        обозначения
        блоков в схеме алгоритма представлены в ГОСТ 19.701-90 «Единая система программной документации. Схемы
        алгоритмов,
        программ, данных и систем. Условные обозначения и правила выполнения» <a href="source.html#metka3">[3]</a>.</p>
    <p>Таблица 1.2 &#8211; Структуры алгоритма</p>
    <p class="tables"><img src="./img/1_chapter/table1.2.png" alt=""></p>
    <p>Любая команда алгоритма записывается в схеме алгоритма в виде графического элемента &#8211; блока &#8211; и
        дополняется
        словесным описанием. Блоки в схемах алгоритма соединяются линиями потока информации. Направление потока
        информации
        указывается стрелкой. В случае потока информации сверху вниз и слева направо стрелку ставить необязательно.
        Блоки в
        схемах алгоритма имеют только один вход и один выход (за исключением логического блока &#8211; блока с
        условием).</p>
    <p>Блок начала в схеме алгоритма имеет один выход и не имеет входов, блок конца схемы алгоритма имеет один вход и не
        имеет выходов. Блок условия &#8211; единственный блок, имеющий два выхода, т. к. соответствует разветвляющемуся
        алгоритму.
        На одном выходе указывается «да», на другом &#8211; «нет». Все остальные блоки имеют один вход и один выход.
        Блок
        выполнения действия может содержать присвоение значения переменной (например, «x = 5») или вычисление (например,
        «y
        = x - 4»).</p>
    <p>Математические выражения и логические высказывания должны быть описаны математическим языком, т. к. схема
        алгоритма
        не должна иметь привязки к какому-то определенному языку программирования. Одна и та же схема алгоритма может
        быть
        реализована в программах на разных языках программирования. К примеру, функция в схеме алгоритма будет выглядеть
        таким образом: y = x2, а не таким образом: y = x^2.</p>
    <p>На сегодняшний день все требования к оформлению блоков прописаны в ГОСТ 19.701-90 «ЕСПД. Схемы алгоритмов,
        программ,
        данных и систем. Обозначения условные и правила выполнения».</p>
    <p>Различают три основных вида алгоритмов:</p>
    <ol>
        <li class="without-parentheses">линейный алгоритм,</li>
        <li class="without-parentheses">разветвляющийся алгоритм,</li>
        <li class="without-parentheses">циклический алгоритм.</li>
    </ol>
    <p><a href="glossary.html#m7">Линейный алгоритм</a> &#8211; это алгоритм, в котором действия выполняются однократно и строго последовательно.</p>
    <p> <a href="glossary.html#m9">Разветвляющийся алгоритм</a>&#8211; это алгоритм, в котором в зависимости от условия выполняется либо одна, либо
        другая
        последовательность действий.</p>
    <p>Самый простой пример реализации разветвляющегося алгоритма: если на улице идет дождь, то необходимо взять зонт,
        иначе не брать зонт с собой.</p>
    <p><a href="glossary.html#m12">Циклический алгоритм</a> &#8211; это алгоритм, команды которого повторяются некое количество раз подряд.</p>
    <p>Самый простой пример реализации циклического алгоритма, когда при чтении книги будут повторяться одни и те же
        действия:
        прочитать страницу, перелистнуть и т. д.</p>
    <h3 id="1.1.3">1.1.3 Разработка линейных структур алгоритмов</h3>
    <p>Для описания реализации линейных структур алгоритмов опишем пример звонка по телефону между друзьями. Вася хочет
        позвонить Пете по городскому телефону. Необходимо составить схему алгоритма, описывающую порядок действий
        Васи.</p>
    <p>Решение. Чтобы позвонить по городскому телефону, нужно знать номер Пети. Значит, сначала надо найти номер
        телефона
        Пети, набрать его и поговорить с Петей. На этом цель Васи (поговорить с Петей по телефону) будет достигнута.
        Результат схемы алгоритма представлен на рисунке 1.1.</p>
    <p class="photo"><img src="./img/1_chapter/1.1.png" alt=""></p>
    <p class="signature">Рисунок 1.1 &#8211; Схема алгоритма для примера </p>
    <h3 id="1.1.4">1.1.4 Разработка разветвляющихся структур алгоритмов</h3>
    <p>В разветвляющемся алгоритме обязательным блоком является блок условия, который представлен на рисунке 1.2.</p>
    <p class="photo"><img src="./img/1_chapter/1.2.png" alt=""></p>
    <p class="signature">Рисунок 1.2 &#8211; Использование блока условия в общем виде</p>
    <p>Внутри блока условия записывается условие. Если данное условие верно, то выполняются блоки, идущие по стрелке
        «да»,
        т. е. «Набор действий 1». Если условие оказывается неверным, т. е. ложным, то выполняются блоки, идущие по
        стрелке
        «нет», а именно «Набор действий 2». Разветвление заканчивается, когда обе стрелки («да» и «нет»)
        соединяются.</p>
    <p>На рисунке 1.3 представлен еще один вариант использования блока условия. Бывают задачи, в которых, исходя из
        условия,
        необходимо либо выполнить действие, либо пропустить его. Если условие верно выполняется, то следуют блоки,
        соответствующие стрелке «да», т. е. «Набор действий 1». Если же условие оказывается ложным, то следует перейти
        по
        стрелке «нет». Т. к. стрелке «нет» не соответствует ни одного блока с действием, то ни одного действия не будет
        выполнено, т. е. пропускается и не выполняется «Набор действий 1».</p>
    <p class="photo"><img src="./img/1_chapter/1.3.png" alt=""></p>
    <p class="signature">Рисунок 1.3 &#8211; Вариант использования блока условия</p>
    <p>В разветвляющемся алгоритме возможна запись сразу нескольких условий, которые могут объединяться союзом «ИЛИ» или
        пересекаться союзом «И». Рассмотрим случай двух условий: «условие 1» и «условие 2».</p>
    <p>Если необходимо, чтобы оба условия были верными одновременно, то следует использовать логическое пересечение «И»:
        «условие 1 И условие 2».</p>
    <p>Если достаточно, чтобы только одно условие выполнялось: либо первое, либо второе, &#8211; следует использовать
        логическое
        объединение «ИЛИ» («условие 1 ИЛИ условие 2»).</p>
    <p>Далее рассмотрен еще один пример. Джон звонит Полу по городскому телефону, но трубку может взять не только Пол.
        Составить блок-схему, описывающую действия Джона в этом случае.</p>
    <p>Решение. Здесь присутствует условие &#8211; Пол ли взял трубку телефона. На данное условие можно однозначно
        ответить:
        «да»,
        Пол, или «нет», кто-то другой. Если трубку взял Пол, то Джону нужно с ним поговорить, и цель будет достигнута.
        Если
        трубку взял кто-то другой, то необходимо позвать Пола к телефону, поговорить с ним, и цель также будет
        достигнута.
        Третьего варианта, например, «не туда попали» или «его нет дома» не рассматриваем. Результат схемы алгоритма
        представлен на рисунке 1.4.</p>
    <p class="photo"><img src="./img/1_chapter/1.4.png" alt=""></p>
    <p class="signature">Рисунок 1.4 &#8211; Схема алгоритма для реализации разветвляющегося алгоритма</p>
    <h3 id="1.1.5">1.1.5 Разработка циклических структур алгоритмов</h3>
    <p>В рассмотрении циклического алгоритма выделяют несколько понятий.</p>
    <p><a href="glossary.html#m11">Тело цикла</a> &#8211; это набор инструкций, предназначенных для многократного выполнения.</p>
    <p><a href="glossary.html#m6">Итерация</a> &#8211; это единичное выполнение тела цикла.</p>
    <p><a href="glossary.html#m9">Переменная цикла</a> &#8211; это величина, изменяющаяся на каждой итерации цикла.</p>
    <p>Каждый <a href="glossary.html#m12">цикл</a> должен содержать следующие необходимые элементы:</p>
    <ol>
        <li class="with-a-bracket">первоначальное задание переменной цикла,</li>
        <li class="with-a-bracket">проверку условия,</li>
        <li class="with-a-bracket">выполнение тела цикла,</li>
        <li class="with-a-bracket">изменение переменной цикла.</li>
    </ol>
    <p>Циклы бывают двух видов: с предусловием и с постусловием. В цикле с предусловием сначала проверяется условие
        входа в цикл, а затем выполняется тело цикла, если условие верно. Цикл с предусловием представлен на рисунке
        1.5.</p>
    <p class="photo"><img src="./img/1_chapter/1.5.png" alt="page"></p>
    <p class="center" align="center">или</p>
    <p class="photo"><img src="./img/1_chapter/1.5(1).png" alt="page"></p>
    <p class="signature">Рисунок 1.5 &#8211; Циклический алгоритм с предусловием в общем виде</p>
    <p>Выход из цикла осуществляется в момент проверки условия входа в цикл, когда оно не выполняется, т. е. условие
        ложно.
        Цикл с предусловием может ни разу не выполниться, если при первой проверке условия входа в цикл оно оказывается
        ложным  <a href="source.html#metka3">[3]</a>.</p>
    <p>В цикле с постусловием сначала выполняется тело цикла, а потом проверяется условие. Циклический алгоритм с
        постусловием представлен на рисунке 1.6.</p>
    <p class="photo"><img src="./img/1_chapter/1.6.png" alt=""></p>
    <p class="signature">Рисунок 1.6 &#8211; Циклический алгоритм с постусловием в общем виде</p>
    <p>Если условие верно, то итерация повторяется, если же неверно, то осуществляется выход из цикла. В отличие от
        цикла с
        предусловием, любой цикл с постусловием всегда выполнится хоть раз.</p>
    <p>Для представленных схем алгоритма для циклов с предусловием и постусловием условие записывается внутри блока
        условия
        (формы ромба), как и в разветвляющемся алгоритме. Разница между разветвляющимся и циклическим алгоритмами при
        графической реализации состоит в том, что в циклическом алгоритме в обязательном порядке присутствует стрелка,
        идущая наверх. Именно эта стрелка обеспечивает многократный повтор тела цикла.</p>
    <p>Далее приведен пример реализации циклического алгоритма: ученику требуется купить учебник. Составить блок-схему,
        описывающую действия ученика в случае, если учебника нет в ряде магазинов.</p>
    <p>Решение примера. Действия ученика в данном примере очевидны: когда он приходит в первый и любой последующий
        магазины, то возможны два варианта: учебник имеется в наличии или учебника нет в продаже. Если учебника нет в
        продаже, то ученику следует пойти в другой книжный магазин и спросить данный учебник и т. д., пока учебник не
        будет куплен, т. к. перед учеником стоит конечная цель – купить учебник. Мы будем использовать цикл с
        предусловием, т. к. сначала требуется найти магазин, имеющий в наличии данный учебник. Цикл будет выполняться,
        пока условие «В данном магазине нет учебника» будет верным, а выход из цикла осуществится, когда условие станет
        ложным, т. е. когда ученик придет в магазин, в котором есть данный учебник. Действительно, в этом случае ученик
        купит нужный ему учебник и не будет больше искать книжные магазины. Результат схемы алгоритма представлен на
        рисунке 1.7.</p>
    <p class="photo"><img src="./img/1_chapter/1.7.png" alt=""></p>
    <p class="signature">Рисунок 1.7 &#8211; Схема алгоритма для примера</p>
    <p>Здесь тело цикла состоит из одного действия «Найти другой книжный магазин». Переменной цикла в явном виде нет, но
        можно подразумевать номер магазина, в который пришел ученик в очередной раз. Как любой другой цикл с
        предусловием,
        данный цикл может ни разу не выполниться (не иметь итераций), если в первом же магазине окажется нужный
        учебник.</p>
    <p>Если в данную задачу добавить условие выбора учебника в жесткой или мягкой обложке, то оно появится после выхода
        из
        цикла. На реализацию циклического алгоритма данное условие не повлияет.</p>
    <h3 id="1.2">1.2 Основы работы со средой MS Visual Studio</h3>
    <h3 id="1.2.1">1.2.1 Создание консольного приложения</h3>
    <p> <a href="glossary.html#m12">Microsoft Visual Studio</a>
 &#8211; это набор инструментов разработки, основанных на использовании компонентов и
        других
        технологий для создания мощных, производительных приложений.</p>
    <p>Кроме того, среда Visual Studio оптимизирована для совместного проектирования, разработки и развертывания
        корпоративных решений <a href="source.html#metka4">[4]</a>.</p>
    <p>Также Visual Studio позволяет создавать проекты, имеющие пользовательский интерфейс (GUI), работая с разными
        компонентами, такими как формы, кнопки, списки, меню и т. д.</p>
    <p>При загрузке приложения из меню «Пуск/Программы/Microsoft Visual Studio 2017» появляется главное окно c начальной
        страницей программы, которое представлено на рисунке 1.8.</p>
    <p class="photo"><img src="./img/1_chapter/1.8.png" width="96%" alt=""></p>
    <p class="signature">Рисунок 1.8 &#8211; Начальная страница Visual Studio</p>
    <p>Программы, которые работают в консоли, т. е. взаимодействие с пользователем происходит посредством черного
        экрана.</p>
    <p>Для создания программы необходимо нажать «Файл/Создать/Проект» или нажать на стартовой странице Visual Studio2017
        быструю ссылку «Создать проект», выделенную синим цветом. После выбора создания нового проекта появится другое
        диалоговое окно «Создать проект», где необходимо выбрать требуемые опции, а именно в левом столбце необходимо
        выбрать «Visual C++/Win32», справа наверху &#8211; «Консольное приложение Win32», справа внизу вписать имя
        проекта
        (например, «ConsoleApplication1»), в графе расположение выбрать вашу папку, где будут храниться все программы,
        оставить
        галочку
        «Создать каталог для решения». Диалоговое окно «Создать проект» представлено на рисунке 1.9.</p>
    <p class="photo"><img src="./img/1_chapter/1.9.png" alt=""></p>
    <p class="signature">Рисунок 1.9 &#8211; Диалоговое окно «Создать проект»</p>
    <p>После этого нужно нажать «ОК». В главном окне Visual Studio 2017 закроется начальная страница, и откроется файл
        «ConsoleApplication1.cpp» (левое верхнее поле), окно вывода ошибок и предупреждений «Вывод» (левое нижнее поле),
        «Командный обозреватель» (правое вертикальное поле). Данный вид представлен на рисунке 1.10.</p>
    <p class="photo"><img src="./img/1_chapter/1.10.png" width="96%" alt=""></p>
    <p class="signature">Рисунок 1.10 &#8211; Файл «ConsoleApplication1.cpp»</p>
    <p>Файл «ConsoleApplication1.cpp» предназначен для текста программы (или кода программы), здесь будут вписываться
        операторы, переменные и функции <a href="source.html#metka4">[4]</a>.</p>
    <p>Окно вывода пока пусто, т. к. программа еще ни разу не была запущена. После первого запуска в этом окне будет
        появляться служебная информация, какой проект запускается, что проверяется, есть ли в коде программы ошибки, и,
        если
        есть, то какие. Благодаря данному списку ошибок можно легко найти ошибку в коде программы и исправить. После
        исправления ошибок следует перезапустить программу на проверку еще раз. Когда ошибок не будет обнаружено,
        программа
        запустится на выполнение задачи и появится консоль.</p>
    <p>Вместо командного обозревателя можно включить «Обозреватель решений», в котором видно все файлы и папки,
        созданные
        для нового проекта. Для этого необходимо под «Командным обозревателем» нажать кнопку «Обозреватель решений».
        Далее в
        появившемся списке раскрыть папки «Файлы исходного кода» и «Заголовочные файлы».</p>
    <p>Когда составляется программа в Visual Studio, получается целый проект, который автоматически создается средой
        Visual
        Studio. Задача начинающего программиста состоит в том, чтобы напечатать код своей программы в файле *.cpp и
        запустить программу на выполнение.</p>
    <p>Первые две строчки начинаются двумя символами «//». Данные символы означают, что далее на этой строчке следует
        комментарий, он не воспринимается компилятором как код программы и не будет выдавать ошибку. Удалять эти две
        строчки
        не рекомендуется.</p>
    <p>Далее следует строчка #include &lstdafx.h>. Данная строка необходима для сборки нашего проекта. Файл stdafx.h
        &#8211;
        это
        один из файлов, автоматически создаваемых для нашей программы, и его можно увидеть в левом столбце «Обозревателя
        решений».
        Эту строчку также нельзя удалять (рисунок 1.11). Далее начинается функция int main(). Автоматически Visual
        Studio называет ее _tmain и вписывает аргументы int argc, _TCHAR* argv[]. В самых простых программах для
        начинающих программистов изменяется эта строчка и приводится к виду int main(), остается return 0, или void
        main(), и стирается return 0. После необходимо собрать проект, нажав в меню «Построение/Построить решение».
        Тогда в поле «Вывод» начинается проверка кода. Данный код прошел проверку успешно, и проект построился.</p>
    <p class="photo"><img src="./img/1_chapter/1.11.png" width="96%" alt=""></p>
    <p class="signature">Рисунок 1.11 &#8211; Успешное построение проекта</p>
    <p>Для того чтобы запустить пустую программу, на клавиатуре необходимо нажать Ctrl+F5. Тогда появится консоль со
        стандартной надписью после выполнения программы «Для продолжения нажмите любую клавишу…». Консоль представлена
        на
        рисунке 1.12.</p>
    <p class="photo"><img src="./img/1_chapter/1.12.png" alt=""></p>
    <p class="signature">Рисунок 1.12 &#8211; Консоль выполнения программы</p>
    <p>После просмотра консоли после нажатия на крестик программа закроется.</p>
    <p>Для того чтобы составить программу, которая напишет на экране фразу «Hello world!», в код заготовки нужно
        добавить
        несколько строк:</p>
    <pre class="cpp-code"><code class="language-cpp">#include &ltiostream> // т. к. нужно будет использовать оператор вывода на экран cout
using namespace std; // подключение пространства имен
int main() {
	cout << "Hello world!" << endl; // вывод фразу на экран и перевод курсора на новую строку,
 // чтобы стандартная фраза «Для продолжения нажмите любую клавишу…» не «налипла» на нашу фразу.
}</code></pre>
    <p class="photo"><img src="./img/1_chapter/1.13.png" alt=""></p>
    <p class="signature">Рисунок 1.13 &#8211; Файл с кодом программы</p>
    <p>После этого опять строится решение, т. к. код программы был изменен. Если построение выполнилось успешно, то
        можно
        запускать программу, нажав Ctrl+F5. Если же построение выдало ошибки, то нужно еще раз все проверить, исправить
        код,
        после этого построить проект еще раз. Консоль представлена на рисунке 1.14.</p>
    <p class="photo"><img src="./img/1_chapter/1.14.png" alt=""></p>
    <p class="signature">Рисунок 1.14 &#8211; Консоль выполнения программы</p>
    <p>В процессе работы с приложением Visual Studio может возникнуть множество вопросов. В меню программы предусмотрены
        справка и стандартные примеры, которые можно посмотреть. Чтобы включить справку, необходимо нажать
        «Справка/Просмотр
        справки» или воспользоваться горячими клавишами Ctrl+F1. Чтобы посмотреть примеры кодов, в меню нужно выбрать
        «Справка/Примеры».</p>
    <h3 id="1.2.2">1.2.2 Структура программы на языке C++</h3>
    <p>Программа на языке С++ имеет определенную структуру. Существует определенная последовательность заранее
        определенных
        строк кода, которая приведена в таблице 1.3.</p>
    <p>Таблица 1.3 &#8211; Структура программы языка С++</p>
    <p class="tables"><img src="./img/1_chapter/table1.3.png" alt=""></p>
    <p>Одна из функций должна иметь имя main. Выполнение программы начинается с первого оператора этой функции.
        Простейшее
        определение функции имеет следующий формат:</p>
    <pre class="cpp-code"><code class="language-cpp">тип_возращаемого_значения имя ([ параметры ]) {<br>операторы, составляющие тело функции }</code></pre>
    <p>Как правило, функция используется для вычисления какого-либо значения, поэтому перед именем функции указывается
        его
        тип.</p>
    <ol>
        <li class="with-a-dash">Если функция не должна возвращать значение, указывается тип void;</li>
        <li class="with-a-dash">Тело функции является блоком и заключается в фигурные скобки;</li>
        <li class="with-a-dash">Функции не могут быть вложенными;</li>
        <li class="with-a-dash">Каждый оператор заканчивается «;» (кроме составного оператора).</li>
    </ol>
    <h3 id="1.3">1.3 Основы языка С++ </h3>
    <h3 id="1.3.1">1.3.1 Стандартные типы данных языка C++</h3>
    <p>Основная цель любой программы состоит в обработке данных. Данные различного типа хранятся и обрабатываются
        по-разному. В любом алгоритмическом языке каждая <a href="glossary.html#m7">константа</a>, <a href="glossary.html#m9">переменная</a>, результат вычисления выражения или
        функции
        должны иметь определенный тип <a href="source.html#metka5">[5]</a>.</p>
    <p>Все типы языка С++ можно разделить на основные и составные. В языке С++ определено шесть основных типов данных
        для
        представления целых, вещественных, символьных и логических величин. На основе этих типов программист может
        вводить
        описание составных типов. К ним относятся массивы, перечисления, функции, структуры, ссылки, указатели,
        объединения
        и классы.</p>
    <p>Таблица 1.4 &#8211; Базовые типы языка С++</p>
    <p class="tables"><img src="./img/1_chapter/table1.4.png" alt=""></p>
    <p>Кроме перечисленных, к основным типам языка относится тип void, но множество значений этого типа пусто. Он
        используется для определения функций, которые не возвращают значения для указания пустого списка аргументов
        функции,
        как базовый тип для указателей и в операции приведения типов.</p>
    <h3 id="1.3.2">1.3.2 Переменные</h3>
    <p>Для хранения информации в языке С++ используются переменные. Переменные в самом простом случае создаются согласно
        такому синтаксису, его нужно запомнить:</p>
    <pre class="cpp-code"><code class="language-cpp">&ltтип переменной> &ltимя переменной>;</code></pre>
    <p>Переменная &#8211; это именованная область памяти, в которой хранятся данные определенного типа. У переменной
        есть
        имя и
        значение. Имя служит для обращения к области памяти, в которой хранится значение. Во время выполнения программы
        значение переменной можно изменять. Перед использованием любая переменная должна быть описана.</p>
    <p>Далее приведен пример описания целой переменной с именем a и вещественной переменной x:</p>
    <pre class="cpp-code"><code class="language-cpp">int a; float x;</code></pre>
    <p>Описание переменной может выполняться в форме объявления или определения. Объявление информирует компилятор о
        типе
        переменной и классе памяти, а определение, кроме этого, содержит указание компилятору выделить память
        согласно типу переменной. В С++ большинство объявлений являются одновременно и определениями. В приведенном выше
        примере
        только описание 3 является объявлением, но не определением.</p>
    <p>Переменная может быть объявлена многократно, но определена только в одном месте программы, поскольку объявление
        просто описывает свойства переменной, а определение связывает ее с конкретной областью памяти.</p>
    <p>Какие символы можно использовать в именах переменных? Правило очень простое:</p>
    <ul>
        <li class="without-parentheses">В качестве первого символа a-z A-Z _;</li>
        <li class="without-parentheses">Последующие символы a-z, A-Z, 0-9.</li>
    </ul>
    <p>Например, можно создавать следующие переменные: short _a;, float a1;, double a2;. По умолчанию все эти переменные
        являются знаковыми (signed), то есть позволяют хранить как отрицательные, так и положительные значения. Если бы
        создавалась переменная, которая может хранить только положительные значения, то ее нужно определить как
        unsigned:</p>
    <pre class="cpp-code"><code class="language-cpp">unsigned int b; //переменная будет хранить целые числа в диапазоне от 0 до 4 млрд примерно</code></pre>
    <p>Нельзя задавать две переменные с одинаковыми именами, например, int a; и float a;, если мы начнем компилировать
        программу, содержащую две этих переменных, то компилятор просто выдаст нам ошибку, но если в одном из случаев а
        поменять на А, то компилирование пройдет успешно.</p>
    <p>Переменные определены. Теперь в них необходимо записать и прочитать какую-либо информацию. Для этого используется
        оператор присваивания =. Например:</p>
    <pre class="cpp-code"><code class="language-cpp">short с = 6; //элементу слева, переменной с, присваивается то,
    //что стоит справа от знака присваивания, в данном случае число 6</code></pre>
    <p>Чтобы лучше понять смысл этого оператора, рассмотрим простой пример работы с переменными.</p>
    <pre class="cpp-code"><code class="language-cpp">#include &ltiostream><br>int main(){
    int i = 1; //целочисленная переменная с присвоенным значением 1
    i = i + 1; //данная строка работает таким образом: справа стоит увеличение i на единицу,
    //и она становится равная 2, эта двойка присваивается значению i, то есть по итогу i увеличивается на единицу
    std::cout << "i = " << i << std::endl; //вывод значения данной переменной на экран
    return 0;
}</code></pre>
    <p>Результат выполнения программного кода представлен на рисунке 1.15.</p>
    <p class="photo"><img src="./img/1_chapter/1.15.png" alt=""></p>
    <p class="signature">Рисунок 1.15 &#8211; Результат выполнения программы, присваивающей значение переменной</p>
    <p>Также необходимо заметить, что std &#8211; это область имен, в которой определены в частности операторы cout и
        endl,
        и
        чтобы в программе все время не писать std::, в начале следует добавить строку using namespace std; и тогда перед
        cout символ std:: можно будет убрать. Если повторно запустить программу с данными изменениями, то можно будет
        убедиться в том, что она работает корректно.</p>
    <p>Далее рассмотрены ещё два подобных примера.</p>
    <pre class="cpp-code"><code class="language-cpp">#include &ltiostream><br>using namespace std;
int main(){
    int a = 10; //задание переменных и присваивание им значений
    short b; // задание переменной
    b = a; //переменной b присваивается значение а, здесь переменные имеют разные типы,
    //но так как число 10 можно записать и в short, и в int,
    //то в момент присваивания произойдет автоматическое преобразование типов,
    //то есть значение, которое хранится в а, будет корректно записано в b
        cout << " b = " << b << endl;
    return 0;
}</code></pre>
    <p>Результат выполнения данного программного кода представлен на рисунке 1.16.</p>
    <p class="photo"><img src="./img/1_chapter/1.16.png" alt=""></p>
    <p class="signature">Рисунок 1.16 &#8211; Результат выполнения программы, присваивающей значение одной переменной
        значению другой переменной</p>
    <p>Второй пример будет выглядеть следующим образом:</p>
    <pre class="cpp-code"><code class="language-cpp">#include &ltiostream><br>using namespace std;
int main(){
    float var_f = 8.7; //задание переменной и присваивание ей значения
    int var_i; //задание переменной
    var_i = var_f; // при таком присваивании произойдет потеря данных,
    //так как целочисленная переменная не может содержать вещественные числа,
    //и в результате переменная var_i будет равна 8, а дробная часть будет отброшена (округляться она не будет!)
        cout << " var_i = " << var_i << endl;
    return 0;
}</code></pre>
    <p>Результат выполнения данного программного кода представлен на рисунке 1.17.</p>
    <p class="photo"><img src="./img/1_chapter/1.17.png" alt=""></p>
    <p class="signature">Рисунок 1.17 &#8211; Результат выполнения программы, где значению переменной одного типа
        присваивается значение переменной другого типай</p>
    <p>Если программист сознательно идет на этот шаг, то он должен сказать об этом компилятору, записав это данным
        образом:
    <pre class="cpp-code"><code class="language-cpp">var_i = (int)var_f;.</code></pre>
    <p>На видео 1 представлена лекция по переменным и оператору присванивания.</p>
    <video controls="controls" poster="./img/video.jpg" src="./video/video_1_l.mp4"></video>
    <p class="signature">Видео 1 &#8211; Переменные. Оператор присваивания</p>

    <h3 id="1.3.3">1.3.3 Константы</h3>
    <p><a href="glossary.html#m7">Константами</a> называют неизменяемые величины. Константы в С++ аналогичны константам в Си <a href="source.html#metka6">[6]</a>. Для представления
        константы в Си использовалась только директива препроцессора #define.</p>
    <p>Синтаксис:</p>
    <pre class="cpp-code"><code class="language-cpp">#define ИмяКонстанты Значение</code></pre>
    <p>Например,</p>
    <pre class="cpp-code"><code class="language-cpp">#define MAX 100</code></pre>
    <p>В С++ для представления константы также можно использовать объявление с ключевым словом const.</p>
    <p>Систаксис:</p>
    <pre class="cpp-code"><code class="language-cpp">const тип ИмяКонстанты = НачальноеЗначение</code></pre>
    <p>Например,</p>
    <pre class="cpp-code"><code class="language-cpp">const int MAX = 100</code></pre>
    <p>Разница состоит лишь в том, что при использовании define компилятор заранее определяет константу, заменяя на
        этапе
        компиляции значение MAX на 100, в то время как <a href="glossary.html#m7">константа</a> инициализируется как обычная переменная с запретом на
        изменение.</p>

 <p>На видео 2 представлена лекция по директивам препроцессора.</p>
    <video controls="controls" poster="./img/video.jpg" src="./video/video_2_l.mp4"></video>
    <p class="signature">Видео 2 &#8211; Директивы препроцессора</p>

    <h3 id="1.3.4">1.3.4 Управляющие последовательности</h3>
    <p>Управляющие символы (или как их ещё называют escape-последовательность) &#8211; символы, которые выталкиваются в
        поток
        вывода с целью форматирования вывода или печати некоторых управляющих знаков С++. Escape-последовательностями
        начинаются с обратной косой черты. Все управляющие символы при использовании обрамляются двойными кавычками.</p>
    <p>В таблице 1.5 приведены допустимые значения управляющих последовательностей.</p>
    <p>Таблица 1.5 &#8211; Управляющие последовательности в языке С++</p>
    <p class="tables"><img src="./img/1_chapter/table1.5.png" alt=""></p>
    <p>Символ обратной косой черты используется в управляющих последовательностях для представления:</p>
    <ol>
        <li class="with-a-bracket">кодов, не имеющих графического изображения (например, \a &#8211; звуковой сигнал, \n
            &#8211;
            перевод курсора в начало следующей строки);
        </li>
        <li class="with-a-bracket">символов апострофа ( ' ), обратной косой черты ( \ ), знака вопроса ( ? ) и кавычки (
            "
            );
        </li>
        <li class="with-a-bracket">любого символа с помощью его шестнадцатеричного или восьмеричного кода, например,
            \073,
            \0xF5.
        </li>
    </ol>
    <p>Числовое значение должно находиться в диапазоне от 0 до 255. </p>
    <p>Управляющие последовательности могут использоваться и в строковых <a href="glossary.html#m7">константах</a>, называемых иначе строковыми
        литералами.
        Например, если внутри строки требуется записать кавычку, ее предваряют косой чертой, по которой компилятор
        отличает
        ее от кавычки, ограничивающей строку:</p>
    <p>"Издательский дом \"Питер\"".</p>
    <h3 id="1.3.5">1.3.5 Комментарии</h3>
    <p>Комментарий либо начинается с двух символов «прямая косая черта» (//) и заканчивается символом перехода на новую
        строку, либо заключается между символами &#8211; скобками /* и */. Внутри комментария можно использовать любые
        допустимые
        на данном компьютере символы, а не только символы из алфавита языка C++, поскольку компилятор комментарии
        игнорирует.</p>
    <h3 id="1.4">1.4 Стандартные операторы и функции языка С++</h3>
    <h3 id="1.4.1">1.4.1 Арифметические операции в С++</h3>
    <p>В языке С++ определены следующие основные арифметическими операции, которые представлены в таблице 1.6.</p>
    <p>Таблица 1.6 &#8211; Основные арифметические операции языка С++</p>
    <p class="tables"><img src="./img/1_chapter/table1.6.png" alt=""></p>
    <p>Операторы +, -, * и / работают в С++ точно так же, как и в большинстве других языков. Их можно применять
        практически
        ко всем встроенным типам данных. Когда применяется знак деление "/" к целому числу или символу, остаток не
        используется, например, 10/3 равно 3.</p>
    <p>Оператор взятия по модулю % работает в С++ так же, как в некоторых других языках. Надо помнить, что оператор
        взятия
        по модулю выдает остаток от целочисленного деления. % не может использоваться с типами float и double.</p>
    <h3 id="1.4.1.1">1.4.1.1 Сложение в С++</h3>
    <p>Далее рассмотрен пример использования операции сложения значений двух переменных.</p>
    <pre class="cpp-code"><code class="language-cpp">#include &ltiostream><br>using namespace std;
int main(){
    int a, b; //задание переменной
    a = 5; //присваивание значений
    b = 7;
    int c;
    c = a + b; //переменная, которая будет хранить сумму а и b
    cout << c << endl;
    return 0;
}</code></pre>
    <p>Результат выполнения данного программного кода представлен на рисунке 1.18.</p>
    <p class="photo"><img src="./img/1_chapter/1.18.png" alt=""></p>
    <p class="signature">Рисунок 1.18 &#8211; Результат операции сложения</p>
    <p>Также данную программу можно записать короче, и тогда она будет выглядеть следующим образом:</p>
    <pre class="cpp-code"><code class="language-cpp">#include &ltiostream><br>using namespace std;
int main(){
    int a = 5, b = 7; //задание переменных и присваивание им значений
    int c = a + b;
    cout << c << endl;
    return 0;
}</code></pre>
    <h3 id="1.4.1.2">1.4.1.2 Вычитание в С++</h3>
    <p>Операция вычитания выполняется аналогично. Далее приведен пример вычитания двух переменных:</p>
    <pre class="cpp-code"><code class="language-cpp">#include &ltiostream><br>using namespace std;
int main(){
    float a = 5.8, b = 7.6; // задание переменных и присваивание им значений
    double c = a - b;
    cout << c << endl;
    return 0;
}</code></pre>
    <p>Результат выполнения данного программного кода представлен на рисунке 1.19.</p>
    <p class="photo"><img src="./img/1_chapter/1.19.png" alt=""></p>
    <p class="signature">Рисунок 1.19 &#8211; Результат операции вычитания</p>
    <p>Далее записан пример задания разности переменных другим способом и показано, чему будет равна переменная в таком
        случае. По идее она должна будет равняться -1, так как дробная часть отбрасывается.</p>
    <pre class="cpp-code"><code class="language-cpp">#include &ltiostream><br>using namespace std;
int main(){
    float a = 5.8, b = 7.6; // задание переменных и присваивание им значений
    int d = (int)(a - b);
    cout << d << endl;
    return 0;
}</code></pre>
    <p>Результат выполнения данного программного кода представлен на рисунке 1.20.</p>
    <p class="photo"><img src="./img/1_chapter/1.20.png" alt=""></p>
    <p class="signature">Рисунок 1.20 &#8211; Результат операции вычитания с приведением типов</p>
    <p>Далее представлен пример записи разности еще одним способом, в котором приводится к определенному типу только
        одна
        переменная:</p>
    <pre class="cpp-code"><code class="language-cpp">#include &ltiostream><br>using namespace std;
int main(){
    float a = 5.8, b = 7.6; // задание переменных и присваивание им значений
    int d = (int)a - b;
    cout << d << endl;
    return 0;
}</code></pre>
    <p>Результат выполнения данного программного кода представлен на рисунке 1.21.</p>
    <p class="photo"><img src="./img/1_chapter/1.21.png" alt=""></p>
    <p class="signature">Рисунок 1.21 &#8211; Результат операции вычитания с приведением к типу только одной
        переменной</p>
    <h3 id="1.4.1.3">1.4.1.3 Умножение в С++</h3>
    <p>Реализация операций умножения. При умножении всё делается аналогично. Допустим, умножим переменную а на 3.</p>
    <pre class="cpp-code"><code class="language-cpp">#include &ltiostream><br>using namespace std;
int main(){
    float a = 8.6;
    double b = 3 * a;
    cout << b << endl;
    return 0;
}</code></pre>
    <p>Результат выполнения данного программного кода представлен на рисунке 1.22.</p>
    <p class="photo"><img src="./img/1_chapter/1.22.png" alt=""></p>
    <p class="signature">Рисунок 1.22 &#8211; Результат операции умножения</p>
    <p>При работе с целочисленными значениями эту операцию можно сделать таким образом:</p>
    <pre class="cpp-code"><code class="language-cpp">#include &ltiostream><br>using namespace std;
int main(){
    float a = 8.6;
    int с = (int)(3 * a);
    cout << c << endl;
    return 0;
}</code></pre>
    <p>Результат выполнения данного программного кода представлен на рисунке 1.23.</p>
    <p class="photo"><img src="./img/1_chapter/1.23.png" alt=""></p>
    <p class="signature">Рисунок 1.23 &#8211; Результат операции умножения с приведением типов</p>
    <p>Далее представлен пример простой программы, которая будет вычислять периметр прямоугольника со сторонами a и
        b:</p>
    <pre class="cpp-code"><code class="language-cpp">#include &ltiostream><br>using namespace std;
int main(){
    double a, b;
    cin >> a >> b; //ввод переменных с клавиатуры
    double p = 2 * (a + b);
    cout << "p = " << p;
    return 0;
}</code></pre>
    <p>Результат выполнения данного программного кода представлен на рисунке 1.24.</p>
    <p class="photo"><img src="./img/1_chapter/1.24.png" alt=""></p>
    <p class="signature">Рисунок 1.24 &#8211; Результат программы, вычисляющей периметр прямоугольника</p>
    <h3 id="1.4.1.4">1.4.1.4 Операция деления в С++</h3>
    <pre class="cpp-code"><code class="language-cpp">#include &ltiostream><br>using namespace std;
int main(){
    int a = 7;
    float b = 2;
    double c = a / b;
    cout << c << endl;
    return 0;
}</code></code></pre>
    <p>Результат выполнения данного программного кода представлен на рисунке 1.25.</p>
    <p class="photo"><img src="./img/1_chapter/1.25.png" alt=""></p>
    <p class="signature">Рисунок 1.25 &#8211; Результат операции деления</p>
    <h3 id="1.4.1.5">1.4.1.5 Инкремент и декремент в С++</h3>
    <p>Далее представлена работа инкремента и декремента:</p>
    <pre class="cpp-code"><code class="language-cpp">#include &ltiostream><br>using namespace std;
int main(){
    short var = 0;
    var++;
    cout << var << endl;
    return 0;
}</code></pre>
    <p>Результат выполнения данного программного кода представлен на рисунке 1.26.</p>
    <p class="photo"><img src="./img/1_chapter/1.26.png" alt=""></p>
    <p class="signature">Рисунок 1.26 &#8211; Результат операции инкремента</p>
    <p>Следующая операция, наоборот, уменьшает значение на единицу:</p>
    <pre class="cpp-code"><code class="language-cpp">#include &ltiostream><br>using namespace std;
int main(){
    float arg = 5;
    arg--;
    cout << arg << endl;
    return 0;
}</code></pre>
    <p class="photo"><img src="./img/1_chapter/1.27.png" alt=""></p>
    <p class="signature">Рисунок 1.27 &#8211; Результат операции декремента</p>
    <p>Также допустима запись --arg. Далее представлена запись кода, в котором отобразится разница написания кода:</p>
    <pre class="cpp-code"><code class="language-cpp">#include &ltiostream><br>using namespace std;
int main(){
    int a, b, c = 10, d = 10;
    a = c++;
    b = ++d;
    cout << a << " " << b << " " << c << " " << d;
    return 0;
}</code></pre>
    <p class="photo"><img src="./img/1_chapter/1.28.png" alt=""></p>
    <p class="signature">Рисунок 1.28 &#8211; Результат работы программы</p>
    <p>Как видно на рисунке 1.28, переменная «a» равна 10, а все остальные переменные равны 11. Так получилось, потому
        что в
        первом случае значение «с» сначала присваивается переменной «a», а потом уже увеличивается на два, а во втором
        случае
        переменная «d» сначала увеличивается на один, а потом уже это значение присваивается переменной «b». Именно в
        этом и
        заключается разница записи <a href="source.html#metka1">[1]</a>.</p>
    <p>Также следует обратить внимание на приоритет операций инкремента и декремента. Они имеют более высокий приоритет
        по
        сравнению с операциями умножения и деления. Это означает, что сначала выполняются эти операции, а потом уже
        умножение и деление.</p>
    <p>Рассмотрим еще некоторые операции:</p>
    <pre class="cpp-code"><code class="language-cpp">#include &ltiostream><br>using namespace std;
int main(){
    int a = 0;
    a += 5; //увеличение переменной а на 5
    cout << a;
    return 0;
}</code></pre>
    <p>Результат выполнения данного программного кода представлен на рисунке 1.29.</p>
    <p class="photo"><img src="./img/1_chapter/1.29.png" alt=""></p>
    <p class="signature">Рисунок 1.29 &#8211; Результат операции, увеличивающей переменную на 5</p>
    <p>Другая похожая операция:</p>
    <pre class="cpp-code"><code class="language-cpp">#include &ltiostream><br>using namespace std;
int main(){
    int b = 0;
    b -= 3; //уменьшение переменной b на 5
    cout << b;
    return 0;
}</code></pre>
    <p class="photo"><img src="./img/1_chapter/1.30.png" alt=""></p>
    <p class="signature">Рисунок 1.30 &#8211; Результат операции, уменьшающей переменную на 3</p>
    <p>Операция увеличения и уменьшения переменной в какое-то количество раз:</p>
    <pre class="cpp-code"><code class="language-cpp">#include &ltiostream><br>using namespace std;
int main(){
    int c = 3, d = 8;
    c *= 3; //увеличение переменной в 3 раза
    d /= 4; // уменьшение переменной в 4 раза
    cout << c << " " << d;
    return 0;
}</code></pre>
    <p class="photo"><img src="./img/1_chapter/1.31.png" alt=""></p>
    <p class="signature">Рисунок 1.31 &#8211; Результат операции, увеличивающей или уменьшающей переменную в какое-то
        количество раз</p>
<p>На видео 3 представлена лекция по арифметическим операциям.</p>
    <video controls="controls" poster="./img/video.jpg" src="./video/video_3_l.mp4"></video>
    <p class="signature">Видео 3 &#8211; Арифметические операции</p>

    <h3 id="1.4.2">1.4.2 Математические операторы и функции</h3>
    <h3 id="1.4.2.1">1.4.2.1 Математические операторы</h3>
    <p>С++ унаследовал из языка С стандартные математические функции, описание которых находится в заголовочных файлах
        &ltmath.h> (&ltcmath>). Они позволяют получить абсолютное значение (abs, fabs), округленное число (ceil, floor),
        квадратный корень (sqrt), степень (pow), значения тригонометрических функций (sin, cos, tan, sinh, cosh, tanh,
        asin,
        acos, atan, atan2), экспоненту (exp), логарифм (log, log10), дробную и целую части числа (modf), остаток от
        деления (fmod) и другие.
    </p>
    <p>В таблице 1.7 представлены математические функции языка С++.</p>
    <p>Таблица 1.7 &#8211; Математические функции языка С++</p>
    <p class="tables"><img src="./img/1_chapter/table1.7.png" alt=""></p>
    <h3 id="1.4.2.2">1.4.2.2 Побитовые операторы</h3>
    <p>Побитовые операции выполняются над отдельными разрядами или битами чисел. Данные операции производятся только над
        целыми числами.</p>
    <p>Таблица 1.8 &#8211; Побитовые операторы</p>
    <p class="tables"><img src="./img/1_chapter/table1.8.png" alt=""></p>
    <h3 id="1.4.2.3">1.4.2.3 Операторы сравнения</h3>
    <p>Сравнивать можно операнды любого типа, но либо они должны быть оба одного и того же встроенного типа (сравнение
        на
        равенство и неравенство работает для двух величин любого типа), либо между ними должна быть определена
        соответствующая операция сравнения. Результат &#8211; логическое значение true или false <a href="source.html#metka2">[2]</a>.</p>
    <p>Таблица 1.9 &#8211; Операторы сравнения</p>
    <p class="tables"><img src="./img/1_chapter/table1.9.png" alt=""></p>
    <h3 id="1.4.2.4">1.4.2.4 Операторы присваивания</h3>
    <p>Операции присваивания позволяют присвоить некоторое значения. Эти операции выполняются над двумя операндами,
        причем
        левый операнд может представлять только модифицируемое именованное выражение, например, переменную. Базовая
        операция
        присваивания = позволяет присвоить значение правого операнда левому операнду:</p>
    <pre class="cpp-code"><code class="language-cpp">int x, y;<br>x = 2;
y = 5;</code></pre>
    <p>Таблица 1.10 &#8211; Операторы присваивания</p>
    <p class="tables"><img src="./img/1_chapter/table1.10.png" alt=""></p>
    <h3 id="1.4.2.5">1.4.2.5 Логические операторы</h3>
    <p>Логические операции образуют сложное (составное) условие из нескольких простых (два или более) условий. Эти
        операции
        упрощают структуру программного кода в несколько раз. В следующей таблице приведены все логические операции в
        языке
        программирования С++ для построения логических условий.</p>
    <p>Таблица 1.11 &#8211; Логические операторы</p>
    <p class="tables"><img src="./img/1_chapter/table1.11.png" alt=""></p>
    <h3 id="1.4.3">1.4.3 Условные операторы if и switch языка С++</h3>
    <h3 id="1.4.3.1">1.4.3.1 Оператор ветвления if</h3>
    <p>Возможность проверять условие &#8211; это, наверное, главное, что отличает компьютер от простого
        калькулятора. </p>
    <p>Условный оператор if используется для разветвления процесса вычислений на два направления. Формат оператора:</p>
    <pre class="cpp-code"><code class="language-cpp">if (выражение) оператор_1; [else оператор_2;]</code></pre>
    <p>Сначала вычисляется выражение, которое может иметь арифметический тип или тип указателя. Если оно не равно нулю
        (имеет значение true), выполняется первый оператор, иначе &#8211; второй. После этого управление передается на
        оператор,
        следующий за условным. Одна из ветвей может отсутствовать, логичнее опускать вторую ветвь вместе с ключевым
        словом
        else. Если в какой-либо ветви требуется выполнить несколько операторов, их необходимо заключить в блок, иначе
        компилятор не сможет понять, где заканчивается ветвление. Блок может содержать любые операторы, в том числе
        описания
        и другие условные операторы (но не может состоять из одних описаний). Необходимо учитывать, что переменная,
        описанная в блоке, вне блока не существует <a href="source.html#metka1">[1]</a>.</p>
    <p class="photo"><img src="./img/1_chapter/1.32.png" alt=""></p>
    <p class="signature">Рисунок 1.32 &#8211; Структурная схема условного оператора</p>
    <p>В качестве условий оператора if можно использовать следующие выражения (таблица 1.12).</p>
    <p>Таблица 1.12 &#8211; Логические операторы</p>
    <p class="tables"><img src="./img/1_chapter/table1.12.png" alt=""></p>
    <p>Следует обратить внимание, в условии (a == b) два знака «=» означают операцию сравнения переменных, если
        поставить
        один знак «=», то будет происходить операция присваивания.</p>
    <p>Далее представлены примеры условного оператора:</p>
    <pre class="cpp-code"><code class="language-cpp">1) if (a<0) b = 1; // 1<br>2) if (a&ltb && (a>d || a==0)) b++; else {b* = a; a = 0;} // 2
3) if (a&ltb) {if (a&ltc) m = a; else m = c;} else {if (b&ltc) m = b; else m = c;} //3
4) if (a++) b++; // 4
5) if (b>a) max = b; else max = a; // 5</code></pre>
    <p>В примере 1 отсутствует ветвь else. Подобная конструкция называется «пропуском оператора», поскольку присваивание
        либо
        выполняется, либо пропускается в зависимости от выполнения условия.</p>
    <p>Если требуется проверить несколько условий, их объединяют знаками логических операций. Например, выражение в
        примере
        2 будет истинно в том случае, если выполнится одновременно условие a&ltb и одно из условий в скобках. Если
        опустить
        внутренние скобки, будет выполнено сначала логическое И, а потом &#8211; ИЛИ.</p>
    <p>Оператор в примере 3 вычисляет наибольшее значение из трех переменных. Фигурные скобки в данном случае
        необязательны,
        так как компилятор относит часть else к ближайшему if <a href="source.html#metka7">[7]</a>.</p>
    <p>Пример 4 напоминает о том, что хотя в качестве выражений в операторе if чаще всего используются операции
        отношения,
        это необязательно.</p>
    <p>Конструкции, подобные оператору в примере 5, проще и нагляднее записывать в виде условной операции (в данном
        случае:
        max = (b > a) ? b : a;).</p>
    <p>Далее рассмотрена следующая математическая задача: пользователь вводит с клавиатуры целое число, а программа
        вычисляет модуль этого числа. Сначала вводится число, затем проверка, если это число меньше 0, то число
        умножается
        на (-1), если же число больше или равно 0, то происходит вывод этого числа на экран. Следует обратить внимание,
        в
        ромбе на блок-схеме происходит ветвление работы алгоритма: если да, то происходит умножение на (-1), если нет,
        то
        происходит вывод на экран. Такое ветвление и есть простейший пример проверки условия.</p>
    <p>Далее представлена реализация данного алгоритма:</p>
    <pre class="cpp-code"><code class="language-cpp">#include &ltiostream><br>using namespace std;
int main(){
    int x;
    cin >> x;// ввод целого числа с клавиатуры
    if (x < 0) //проверка условия
        x = x * (-1); //присвоение значения
    cout << x << endl; // вывод на экран
    return 0;
}</code></pre>
    <p>Условный оператор здесь представлен словом if, а его условие находится в скобках, в данном случае (x < 0). Если
        условие будет истинным, т. е. число будет меньше 0, произойдет выполнение данного оператора – x=x*(-1), если же
        условие окажется ложным, то такой оператор выполняться не будет.</p>
    <p class="photo"><img src="./img/1_chapter/1.33.png" alt=""></p>
    <p class="signature">Рисунок 1.33 &#8211; Блок-схема математической задачи</p>
    <p>Далее приведен еще один пример использования условного оператора if для проверки, является ли число
        отрицательными
        или
        неотрицательным:</p>
    <pre class="cpp-code"><code class="language-cpp">#include &ltiostream><br>using namespace std;
int main(){
    setlocale(LC_ALL, "rus");
    float x;
    cout << "Введите число : ";
    cin >> x;//ввод вещественного числа
    if (x < 0)
        cout << "Введенное число " << x << " является отрицательным.\n";
    if (x >= 0)
        cout << "Введенное число " << x << " является неотрицательным.\n";
    return 0;
}</code></pre>
    <p>Результат выполнения данного программного кода представлен на рисунке 1.34.</p>
    <p class="photo"><img src="./img/1_chapter/1.34.png" alt=""></p>
    <p class="signature">Рисунок 1.34 &#8211; Результат работы программы</p>
    <h3 id="1.4.3.2">1.4.3.2 Оператор ветвления else</h3>
    <p>Оператор else означает «иначе», т. е. он будет выполняться только в том случае, если первое условие будет ложным.
        Синтаксис данной конструкции выглядит следующим образом:</p>
    <pre class="cpp-code"><code class="language-cpp">if(&ltусловие>)
оператор1;
else
оператор2;</code></pre>
    <p>Далее приведен пример использования оператора else. Следует обратить внимание на два взаимоисключающих условия:
        если
        истинно одно из них, то обязательно будет ложно второе. Значит, вместо двух таких проверок можно использовать
        одну:</p>
    <pre class="cpp-code"><code class="language-cpp">#include &ltiostream>
using namespace std;
int main(){
    setlocale(LC_ALL, "rus");
    float x;
    cout << "Введите число : ";
    cin >> x;
    if (x < 0)
        cout << "Введенное число " << x << " является отрицательным.\n";
    else
        cout << "Введенное число " << x << " является неотрицательным.\n";
    return 0;
}</code></pre>
    <p>Далее представлен код программы, выполняющий такую же функцию, как и прошлый, с тремя условиями:</p>
    <pre class="cpp-code"><code class="language-cpp">#include &ltiostream>
using namespace std;
int main(){
    setlocale(LC_ALL, "rus");
    float x;
    cout << "Введите число : ";
    cin >> x;
    if (x < 0)// проверка на отрицательное число
        cout << "Введенное число " << x << " является отрицательным.\n";
    else if (x > 0)// проверка на положительное число
        cout << "Введенное число " << x << " является положительным.\n";
    else // иначе это 0
        cout << "Введенное число равно 0.\n";
    return 0;
}</code></pre>
    <p>Следует обратить внимание: в данной программе после каждого условия записан лишь один оператор, и это cout, но
        если
        нужно выполнить сразу несколько операторов, то они заключаются в фигурные скобки.</p>
    <pre class="cpp-code"><code class="language-cpp">if (&ltусловие > ) { список операторов; }
else { список операторов; }</code></pre>
    <p>Т. е. если выполняться будет только один оператор, то фигурные скобки ставить необязательно, но, если несколько,
        &#8211;
        обязательно <a href="source.html#metka2">[2]</a>.</p>
    <p>Далее рассмотрена следующая программа, в которой используется <a href="glossary.html#m11">условный оператор</a> if с несколькими операторами else
        для
        поиска площади треугольника и прямоугольника.</p>
    <pre class="cpp-code"><code class="language-cpp">#include &ltiostream>
using namespace std;
int main(){
    setlocale(LC_ALL, "rus");
    short item;
    cout << "1 - площадь треугольника\n 2 - площадь прямоугольни-ка\n";
    cout << endl;
    cout << "Выберите геометрическую фигуру: ";
    cin >> item;
    double h, a, S = 0;
    cout << endl;
    if (item == 1)
    {
        cout << "Введите высоту и основание треугольника: ";
        cin >> h >> a;
        S = 0.5 * h * a;
    }
    else if (item == 2)
    {
        cout << "Введите стороны прямоугольника: ";
        cin >> h >> a;
        S = h * a;
    }
    cout << endl;
    cout << "Площадь равна: " << S << endl;
    return 0;
}</code></pre>
    <p>Сначала на экран выводятся пункты меню, далее пользователь вводит с клавиатуры номер нужного ему варианта меню:
        если
        пользователь вводит «1» и в последующем вводит высоту и сторону геометрической фигуры, то вычисляется площадь
        треугольника, если «2», то вычисляется площадь прямоугольника, далее искомая площадь будет выведена на
        экран.</p>
    <p>Результат выполнения данного программного кода представлен на рисунке 1.35.</p>
    <p class="photo"><img src="./img/1_chapter/1.35.png" alt=""></p>
    <p class="signature">Рисунок 1.35 &#8211; Результат работы программы</p>
    <h3 id="1.4.3.3">1.4.3.3 Использование логических операторов при проверке условий</h3>
    <p>Следует обратить внимание, что данный код:</p>
    <pre class="cpp-code"><code class="language-cpp">if (a >= -2)
if (a <= 5)</code></pre>
    <p>можно записать следующим образом:</p>
    <pre class="cpp-code"><code class="language-cpp">if (a >= -2 && a<=5)</code></pre>
    <p>Два амперсанта в данном условии обозначают логическое И. Т. е. условие считается истинным, когда и первое, и
        второе
        условия истинны, если хотя бы одно из условий ложное, то все условие становится ложным. Так работает логическое
        И
        (&&) в условных операторах.</p>
    <p>В условии оператора if данные вертикальные линии || означают логическое ИЛИ. Т. е. если хотя бы одно из условий
        оператора if истинно, то истинно все условие.</p>
    <p>Далее рассмотрена математическая задача, в которой пользователь вводит с клавиатуры целое число, а программа
        определяет, находится ли данное число вне отрезка [-2;5].</p>
    <pre class="cpp-code"><code class="language-cpp">#include &ltiostream>
using namespace std;
int main(){
    setlocale(LC_ALL, "rus");
    double a;
    cin >> a;
    if (a < -2 || a > 5)
        cout << "a принадлежит отрезку [-2;5]" << endl;
    return 0;
}</code></pre>
    <p>Также в С++ есть операция логического НЕ, она записывается как восклицательный знак(!). Далее рассмотрена
        следующая
        программа:</p>
    <pre class="cpp-code"><code class="language-cpp">#include &ltiostream>
using namespace std;
int main(){
    setlocale(LC_ALL, "rus");
    double a;
    cin >> a;
    if (!(a < -2 || a > 5))
        cout << "a принадлежит отрезку [-2;5]" << endl;
    return 0;
}</code></pre>
    <p>Восклицательный знак внутри условия перед скобками с самим условием означает, что условие становится
        противоположным,
        и теперь проверка будет происходить на принадлежность данного числа к отрезку [-2;5].</p>
    <p>Результат выполнения данного программного кода представлен на рисунке 1.36.</p>
    <p class="photo"><img src="./img/1_chapter/1.36.png" alt=""></p>
    <p class="signature">Рисунок 1.36 &#8211; Результат работы программы</p>
    <p>На практике логическое НЕ обычно так не используется, а используется применительно к отдельным переменным.</p>
    <pre class="cpp-code"><code class="language-cpp">if(!a)</code></pre>
    <p>Такое условие будет истинно, когда а будет равно 0.</p>
    <p>Подобно операциям умножения и сложения в математике логические операции И, ИЛИ, НЕ тоже имеют приоритеты. Самый
        высокий приоритет имеет операция НЕ, затем операция И, а самый низкий приоритет имеет операция ИЛИ.</p>
    <p>Далее рассмотрена следующая программа:</p>
    <pre class="cpp-code"><code class="language-cpp">#include &ltiostream>
using namespace std;
int main(){
    setlocale(LC_ALL, "rus");
    double x, y;
    cin >> x >> y;
    if ((x < 0 || x > 2) && y >= 5 && y <= 7)
        cout << "x не принадлежит [0;2], y принадлежит [5;7]" << endl;
    return 0;
}</code></pre>
    <p>Следует обратить внимание, что условие (x < 0||x > 2) специально заключено в круглые скобки, чтобы они
        проверялись по
        ИЛИ, если убрать круглые скобки, то будет следующее условие: x<2 или x>2 && y>=5 && y<=7 , а это уже совсем
        другое
        условие. Поэтому использование круглых скобок для условия (x < 0||x > 2) обязательно.</p>
    <p>Результат выполнения данного программного кода представлен на рисунке 1.37.</p>
    <p class="photo"><img src="./img/1_chapter/1.37.png" alt=""></p>
    <p class="signature">Рисунок 1.37 &#8211; Результат работы программы</p>
<p>На видео 4 представлена лекция по битовым операциям И, ИЛИ, НЕ, XOR и сдвиговым операциям.</p>
    <video controls="controls" poster="./img/video.jpg" src="./video/video_4_l.mp4"></video>
    <p class="signature">Видео 4 &#8211; Битовым операции И, ИЛИ, НЕ, XOR и сдвиговые операции</p>

    <h3 id="1.4.3.4">1.4.3.4 Оператор switch</h3>
    <p>В языке С++ есть еще один <a href="glossary.html#m11">условный оператор</a> switch. Оператор switch (переключатель) предназначен для разветвления
        процесса вычислений на несколько направлений. Он используется, когда из множества вариантов нужно выбрать один,
        соответствующий некому значению проверяемой переменной. Очень часто данный оператор используется в выборе
        пунктов
        меню пользовательского интерфейса <a href="source.html#metka8">[8]</a>.</p>
    <p>Данный оператор имеет следующий синтаксис:</p>
    <pre class="cpp-code"><code class="language-cpp">switch (выражение){
case константное_выражение_1: [список_операторов_1] ; break;
case константное_выражение_2: [список_операторов_2] ; break;
...
case константное_выражение _n : [список_операторов _n] ; break;
[default: операторы]
}</code></pre>
    <p>Выполнение оператора начинается с вычисления выражения (оно должно быть целочисленным), а затем управление
        передается
        первому оператору из списка, помеченного константным выражением, значение которого совпало с вычисленным. После
        этого, если выход из переключателя явно не указан, последовательно выполняются все остальные ветви. Выход из
        переключателя обычно выполняется с помощью операторов break или return. Оператор break выполняет выход из самого
        внутреннего из объемлющих его операторов: switch, for, while и do. Оператор return выполняет выход из функции, в
        теле которой он записан <a href="source.html#metka1">[1]</a>.</p>
    <p>Все константные выражения должны иметь разные значения, но быть одного и того же целочисленного типа. Несколько
        меток
        могут следовать подряд. Если совпадения не произошло, выполняются операторы, расположенные после слова default
        (а
        при его отсутствии управление передается следующему за switch оператору).</p>
    <p class="photo"><img src="./img/1_chapter/1.38.png" alt=""></p>
    <p class="signature">Рисунок 1.38 &#8211; Результат операции деления</p>
    <p>Далее приведен пример программы, которая реализует простейший калькулятор на четыре действия с использованием
        оператора switch:</p>
    <pre class="cpp-code"><code class="language-cpp">#include &ltiostream>
using namespace std;
int main(){
    setlocale(LC_ALL, "rus");
    int a, b, res;
    char op;
    cout << "\n Введите 1-й операнд : "; cin >> a;
    cout << "\n Введите знак операции : "; cin >> op;
    cout << "\n Введите 2-й операнд : "; cin >> b;
    bool f = true;
    switch (op){
    case '+': res = a + b; break;
    case '-': res = a - b; break;
    case '*': res = a * b; break;
    case '/': res = a / b; break;
    default: cout << "\n Неизвестная операция"; f = false;
    }
    if (f) cout << "\n Результат : " << res;
    return 0;
}</code></pre>
    <p>Далее рассмотрен еще один пример использования условного оператора switch. Оператор switch используется для
        расчета
        площади различных фигур (треугольника, прямоугольника, круга или трапеции) в зависимости от выбора
        пользователя:</p>
    <pre class="cpp-code"><code class="language-cpp">#include &ltiostream>
using namespace std;
int main(){
    setlocale(LC_ALL, "rus");
    short item;
    cout << "0 - выход из программы \n 1 - S треугольника\n 2 - S прямоугольника\n 3 - S круга\n 4 - S трапеции\n";
    cin >> item;
    switch (item)
    {
    case 1:
        cout << "Выбрана площадь треугольника";
        break;
    case 2:
        cout << "Выбрана площадь прямоугольника ";
        break;
    case 3:
        cout << "Выбрана площадь круга";
        break;
    case 4:
        cout << "Выбрана площадь трапеции";
        break;
    default:
        cout << "не выбран ни один из пунктов\n";
    }
    return 0;
}</code></pre>
    <p>В данном примере сначала на экран выводится меню, затем пользователь вводит с клавиатуры нужный ему пункт меню,
        далее
        реализован оператор switch, который проверяет переменную item (введённую пользователем с клавиатуры) на
        равенство
        значений 1, 2, 3, 4. При вводе пользователем цифры 3 сразу происходит переход к case 3, затем выполняется
        операция,
        заложенная в case 3, и после выполнения всех операций case 3 срабатывает оператор break, который досрочно
        завершает
        работу условного оператора switch.</p>
    <p>Результат выполнения данного программного кода представлен на рисунках 1.39 &#8211; 1.42.</p>
    <p class="photo"><img src="./img/1_chapter/1.39.png" alt=""></p>
    <p class="signature">Рисунок 1.39 &#8211; Результат работы программы по поиску площади фигуры</p>
    <p class="photo"><img src="./img/1_chapter/1.40.png" alt=""></p>
    <p class="signature">Рисунок 1.40 &#8211; Результат работы программы. Шаг 1</p>
    <p class="photo"><img src="./img/1_chapter/1.41.png" alt=""></p>
    <p class="signature">Рисунок 1.41 &#8211; Результат работы программы. Шаг 2</p>
    <p class="photo"><img src="./img/1_chapter/1.42.png" alt=""></p>
    <p class="signature">Рисунок 1.42 &#8211; Результат работы программы. Шаг 3</p>
    <p>Оператор break нужен, чтобы досрочно завершить работу оператора switch. Проверка с помощью оператора switch в
        данном
        случае будет происходить намного быстрее, потому что проверкой с помощью оператора if пришлось бы проверять
        сразу 4
        условия. Оператор default нужен для тех случаев, когда не будет выбран ни один из предложенных пунктов, если его
        убрать и не выбирать ни один из предложенных пунктов, то на экран просто не выведется ничего.</p>

        <p>На видео 5 представлена лекция по условным операторам if и switch.</p>
    <video controls="controls" poster="./img/video.jpg" src="./video/video_5_l.mp4"></video>
    <p class="signature">Видео 5 &#8211; Условные операторы if и switch</p>
    <h3 id="1.4.4">1.4.4 Операторы цикла</h3>
    <p>Цикл &#8211; это многократное прохождение по одному и тому же коду программы. Циклы необходимы программисту для
        многократного выполнения одного и того же кода, пока истинно какое-то условие. Если условие всегда истинно, то
        такой
        цикл называется бесконечным, у такого цикла нет точки выхода.</p>
    <p>В языке C++ имеются следующие виды циклов:</p>
    <ol>
        <li class="with-a-dash">for;</li>
        <li class="with-a-dash">while;</li>
        <li class="with-a-dash">do...while.</li>
    </ol>
    <p>Цикл for используется, если известно точное количество действий (итераций) цикла.</p>
    <p>Когда неизвестно, сколько итераций должен произвести цикл, то используются циклы while или do...while. Цикл
        do…while
        очень похож на цикл while. Единственное их различие в том, что при выполнении цикла do…while один проход цикла
        будет
        выполнен независимо от условия.</p>
    <h3 id="1.4.4.1">1.4.4.1 Оператор цикла for</h3>
    <p>Оператор цикла for &#8211; это наиболее используемый в языке С++ оператор цикла. Он имеет следующий
        синтаксис:</p>
    <pre class="cpp-code"><code class="language-cpp">for (&ltинициализация счетчика>; &ltусловие>; &ltизменение значения счетчика>)
{
    [тело цикла]
}</code></pre>
    <p>Итерацией цикла называется один проход этого цикла.</p>
    <p><a href="glossary.html#m11">Счетчик цикла</a> &#8211; это переменная, в которой хранится количество проходов данного цикла.</p>
    <p>Описание синтаксиса:</p>
    <ol>
        <li class="without-parentheses">cначала присваивается первоначальное значение счетчику, после чего ставится
            точка с
            запятой;
        </li>
        <li class="without-parentheses">затем задается конечное значение счетчика цикла. После того как значение
            счетчика
            достигнет указанного предела, цикл завершится. Снова ставим точку с запятой;
        </li>
        <li class="without-parentheses">задается шаг цикла. <a href="glossary.html#m12">Шаг цикла</a> &#8211; это значение, на которое будет
            увеличиваться
            или уменьшаться счетчик цикла при каждом проходе.
        </li>
    </ol>
    <p>Далее приведен пример программы, которая будет считать сумму всех чисел от 1 до 1000:</p>
    <pre class="cpp-code"><code class="language-cpp">#include &ltiostream>
using namespace std;
int main(){
    int i; // счетчик цикла
    int sum = 0; // сумма чисел от 1 до 1000.
    setlocale(0, "");
    for (i = 1; i <= 1000; i++) // задаем начальное значение 1, конечное 1000 и задаем шаг цикла, равный 1
    {
        sum = sum + i;
    }
    cout << "Сумма чисел от 1 до 1000 = " << sum << endl;
    return 0;
}</code></pre>
    <p>Если мы скомпилируем этот код и запустим программу, то она покажет ответ 500500 &#8211; это и есть сумма всех
        целых
        чисел
        от 1 до 1000. Если считать это вручную, понадобится очень много времени и сил. Цикл выполнил всю рутинную
        работу.</p>
    <p>В теле цикла при каждом проходе программа увеличивает значение переменной sum на i. Еще один очень важный момент
        &#8211; в
        начале программы переменной sum было присвоено значение нуля. Если этого не сделать, то программа вылетит в
        сегфолт
        (ошибка сегментации &#8211; ошибка программного обеспечения, возникающая при попытке обращения к недоступным для
        записи
        участкам памяти либо при попытке изменить память запрещённым способом). При объявлении переменной без ее
        инициализации, что эта переменная будет хранить «мусор».</p>
    <p>Далее приведен еще один пример использования оператора цикла for. В данном случае оператор цикла используется для
        расчета математической задачи для поиска суммы дробей. Формула для расчета математической задачи представлена
        ниже:</p>
    <p class="formula"><img src="./img/1_chapter/(1.1).png" alt="">(1.1)</p>
    <p>Код, реализующий данную математическую задачу на примере цикла for, представлен ниже:</p>
    <pre class="cpp-code"><code class="language-cpp">#include &ltiostream>
using namespace std;
int main(){
	setlocale(LC_ALL, "rus");
	double S = 0;
	for (int n = 1; n <= 1000; n++)
		S += 1.0 / n;
	cout << S << endl;
	return 0;
}</code></pre>
    <p>Следует отметить, что после условия цикла for не присутствуют фигурные скобки, так как для одного оператора
        фигурные
        скобки не требуются.</p>
    <p>Цикл for можно задавать и с вещественными счетчиками. Например, если нужно вычислить значение линейной функции
        f(x)=kx+b и вывести значение на экран при данных х=0; 0,1; 0,2; ...; 1.</p>
    <p>Далее представлен код, реализующий вычисление значения линейной функции:</p>
    <pre class="cpp-code"><code class="language-cpp">#include &ltiostream>
using namespace std;
int main() {
	setlocale(LC_ALL, "rus");
	double f, k, b;
	cout << "Введите k и b: ";
	cin >> k >> b;
	for (double x = 0; x <= 1; x += 0.1)
	{
		f = k * x + b;
		cout << f << endl;
	}
	return 0;
}</code></pre>
    <p>В данном примере сначала объявляются все необходимые переменные (f, k, b), далее пользователь вводит с клавиатуры
        переменные k и b. Затем идет цикл for, в нем инициализирован счетчик х с начальным значением 0, конечным
        значением 1
        и с шагом изменения 0,1. В качестве тела цикла представлены два оператора: первый вычисляет значение функции, а
        второй &#8211; выводит это значение на экран. Результат выполнения данного программного кода представлен на
        рисунке
        1.43.</p>
    <p class="photo"><img src="./img/1_chapter/1.43.png" alt=""></p>
    <p class="signature">Рисунок 1.43 &#8211; Результат работы программы</p>
    <p>Следует отметить, что объявить счетчик оператора цикла for можно отдельно, выглядит это следующим образом:</p>
    <pre class="cpp-code"><code class="language-cpp">double x = 0;
for (; x <= 1; x += 0.1)
{
    f = k * x + b;
    cout << f << endl;
}</code></pre>
    <p>Также можно поместить в тело цикла шаг изменения счетчика:</p>
    <pre class="cpp-code"><code class="language-cpp">double x = 0;
for (; x <= 1;)
{
    f = k * x + b;
    cout << f << endl;
    x += 0.1;
}</code></pre>
    <p>Помимо этого, можно условие выполнения цикла записать в тело цикла с использованием условного оператора if:</p>
    <pre class="cpp-code"><code class="language-cpp">double x = 0;
for (;;)
{
    if (x>1) break;
    f = k * x + b;
    cout << f << endl;
    x += 0.1;
}</code></pre>
    <p>Как только х станет больше 1, произойдет выход из цикла.</p>
    <h3 id="1.4.4.2">1.4.4.2 Оператор цикла while</h3>
    <p>Цикл while выполняет некоторый код, пока его условие истинно, то есть возвращает true. Цикл while имеет следующий
        синтаксис:</p>
    <pre class="cpp-code"><code class="language-cpp">while (&ltусловие цикла > ) {
    [тело цикла]
}</code></pre>
    <p>После ключевого слова while в скобках идет условное выражение, которое возвращает true или false. Затем в
        фигурных
        скобках идет набор инструкций, которые составляют тело цикла. И пока условие возвращает true, будут выполняться
        инструкции в теле цикла <a href="source.html#metka1">[1]</a>.</p>
    <p>Далее представлен пример использования цикла while для расчета суммы всех целых чисел от 1 до 1000:</p>
    <pre class="cpp-code"><code class="language-cpp">#include &ltiostream>
using namespace std;
int main(){
    setlocale(0, "");
    int i = 0; // инициализируем счетчик цикла
    int sum = 0; // инициализируем счетчик суммы
    while (i < 1000)
    {
        i++;
        sum += i;
    }
    cout << "Сумма чисел от 1 до 1000 = " << sum << endl;
    return 0;
}</code></pre>
    <p>В данном примере было задано строгое неравенство в условии цикла и инициализирован счетчик i нулем. Так как в
        цикле
        while происходит на одну итерацию больше, потому он будет выполняться до тех пор, пока значение счетчика
        перестает
        удовлетворять условию, но данная <a href="glossary.html#m6">итерация</a> все равно выполнится. Если поставить нестрогое неравенство, то цикл бы
        закончился, когда переменная i стала бы равна 1001, и выполнилось бы на одну итерацию больше.</p>
    <p>В данном примере сначала инициализируется счетчик цикла и переменная, хранящая сумму чисел. В данном случае
        счетчику
        цикла присвоено определенное значение. Если мы не инициализируем счетчик цикла, то в него попадет «мусор» и
        компилятор в лучшем случае выдаст нам ошибку, а в худшем, если программа соберется, &#8211; сегфолт практически
        неизбежен.</p>
    <p>Затем мы описываем условие цикла: «пока переменная i меньше 1000, выполняй цикл». При каждой итерации
        цикла
        значение переменной счетчика i увеличивается на единицу внутри цикла.</p>
    <p>Когда выполнится 1000 итераций цикла, счетчик станет равным 999, и следующая итерация уже не выполнится,
        поскольку
        1000 не меньше 1000. Выражение sum += i является укороченной записью sum = sum + i. После окончания выполнения
        цикла
        выводится сообщение с ответом.</p>
    <p>Далее приведен еще один пример использования цикла while для расчета суммы чисел. Формула для расчета суммы чисел
        представлена ниже:</p>
    <p class="formula"><img src="./img/1_chapter/(1.2).png" alt="">(1.2)</p>
    <p>В данном примере сначала задается переменная S, которая будет хранить сумму, а затем счетчик n, которому сразу
        присваивается значение 1, так как он будет меняться с единицы. Далее идет условие цикла n<=1000. Если будет
        выполняться условие цикла, то будут выполняться следующие операторы вычисления суммы. Затем счетчик
        увеличивается на
        1, т. е. сначала он был 1, потом будет 2, 3, 4 и т. д.</p>
    <p>После выполнения данных операторов происходит переход на условие цикла, и, если счетчик n<=1000, данные
        операторы
        опять повторяются. Когда счетчик n станет равным 1000, снова произойдет выполнение данных операторов. Счетчик n
        станет равным 1001, и условие цикла не сработает, произойдет завершение работы цикла.</p>
    <p>Далее представлена схема алгоритма для решения данной задачи.</p>
    <p class="photo"><img src="./img/1_chapter/1.44.png" alt=""></p>
    <p class="signature">Рисунок 1.44 &#8211; Схема алгоритма поиска суммы чисел</p>
    <p>Далее представлена программная реализация описанного алгоритма поиска суммы чисел:</p>
    <pre class="cpp-code"><code class="language-cpp">#include &ltiostream>
using namespace std;
int main(){
	setlocale(LC_ALL, "rus");
	double S = 0;
	int n = 1;
	while (n <= 1000)
	{
		S += 1.0 / n;
		n++;
	}
	cout << S << endl;
	return 0;
}</code></pre>
    <p>В данной программе сначала задается вещественная переменная S, которая будет хранить сумму ряда, затем счетчик n,
        изначальное значение которого 1. Далее идет цикл while: в круглых скобках записывается его условие (в данном
        случае
        n<=1000), и, пока оно истинно, выполняются два оператора (первый подсчитывает сумму ряда, а второй увеличивает
        значение счетчика на 1). Как только цикл while завершит свою работу, на экран выведется значение суммы.
        Результат
        выполнения данного программного кода представлен на рисунке 1.45.</p>
    <p class="photo"><img src="./img/1_chapter/1.45.png" alt=""></p>
    <p class="signature">Рисунок 1.45 &#8211; Результат работы программы</p>
    <p>Рассмотрим еще один пример использования оператора цикла while. В данном случае пользователь вводит с клавиатуры
        числа. В программе подсчитывается их сумма до тех пор, пока она будет меньше 100 и пользователь не введет с
        клавиатуры 0. Далее представлен код, реализующий данную задачу:</p>
    <pre class="cpp-code"><code class="language-cpp">#include &ltiostream>
using namespace std;
int main(){
	setlocale(LC_ALL, "rus");
	double S = 0;
	int n = 1;
	while (S < 100 && n != 0)
	{
		cout << "Введите целое число: ";
		cin >> n;
		S += n;
	}
	cout << S << endl;
	return 0;
}</code></pre>
    <p>Число n пользователь вводит с клавиатуры. В условии цикла while прописаны два условия, пока истинно каждое из
        них,
        истинно и все условие, если ложно хоть одно из условий, то ложно все условие. Результат выполнения данного
        программного кода представлен на рисунках 1.46 и 1.47.</p>
    <p class="photo"><img src="./img/1_chapter/1.46.png" alt=""></p>
    <p class="signature">Рисунок 1.46 &#8211; Результат работы программы</p>
    <p class="photo"><img src="./img/1_chapter/1.47.png" alt=""></p>
    <p class="signature">Рисунок 1.47 &#8211; Результат работы программы</p>
    <h3 id="1.4.4.3">1.4.4.3 Оператор цикла do while</h3>
    <p>Цикл do...while очень похож на цикл while. Единственное их различие в том, что при выполнении цикла do...while
        один проход цикла будет выполнен независимо от условия. </p>
    <p>Цикл do...while имеет следующий синтаксис:</p>
    <pre class="cpp-code"><code class="language-cpp">do
{
   [тело цикла]
} while (&ltусловие цикла > )</code></pre>
    <p>Отличие цикла do...while от двух предыдущих в том, что сначала выполняется тело цикла, а затем проверяется
        условие
        цикла.</p>
    <p>Далее приведен пример поиска суммы чисел от 1 до 1000 с применением цикла do...while:</p>
    <pre class="cpp-code"><code class="language-cpp">#include &ltiostream>
using namespace std;
int main(){
    setlocale(0, "");
    int i = 0; // инициализируем счетчик цикла
    int sum = 0; // инициализируем счетчик суммы
    do
    {// выполняем цикл
        i++;
        sum += i;
    } while (i < 1000); // пока выполняется условие
    cout << "Сумма чисел от 1 до 1000 = " << sum << endl;
    return 0;
}</code></pre>
    <p>Реализация цикла do...while может использоваться, если пользователь вводит с клавиатуры какие-то данные и нужно
        проверить, те ли данные он ввел. Если он ввел не те данные, то программа просит его ввести их еще раз. Он будет
        вводить до тех пор, пока не введет их верно. Данная программа на языке С++ будет выглядеть следующим
        образом:</p>
    <pre class="cpp-code"><code class="language-cpp">#include &ltiostream>
using namespace std;
int main(){
	setlocale(LC_ALL, "rus");
	const int secret_code = 13;
	int code_ent;
	do {
		cout << "Введите секретный код: ";
		cin >> code_ent;
	} while (code_ent != secret_code);
	cout << "Вы ввели верный код!";
	return 0;
}</code></pre>
    <p>В данном примере сначала задается <a href="glossary.html#m7">константа</a> в виде целочисленной переменной, равной 13, данное число должен будет
        ввести пользователь. Затем выполняется тело цикла, т. е. пользователь вводит этот код. Далее идет проверка
        цикла:
        если введенный код не будет соответствовать секретному коду, то условие окажется истинным и цикл начнет работать
        заново. Если введенный код будет равен секретному коду, то произойдет выход из цикла.</p>
    <p>Результат выполнения данного программного кода представлен на рисунке 1.48.</p>
    <p class="photo"><img src="./img/1_chapter/1.48.png" alt=""></p>
    <p class="signature">Рисунок 1.48 &#8211; Результат работы программы проверки ввода секретного кода</p>
    <p>На видео 6 представлена лекция по операторам циклов while, for и do...while.</p>
    <video controls="controls" poster="./img/video.jpg" src="./video/video_6_l.mp4"></video>
    <p class="signature">Видео 6 &#8211; Операторы циклов while, for и do...while</p>
    <h3 id="1.4.4.4">1.4.4.4 Вложенные циклы</h3>
    <p>Иногда для решения своих задач программистам приходится использовать вложенные циклы. Например, для решения
        задачи
        поиска суммы произведений.</p>
    <p>Далее представлена исходная формула для решения суммы произведений чисел:</p>
    <p class="formula"><img src="./img/1_chapter/(1.3).png" alt="">(1.3)</p>
    <p>Далее представлен код, реализующий данную математическую задачу:</p>
    <pre class="cpp-code"><code class="language-cpp">#include &ltiostream>
using namespace std;
int main(){
    setlocale(LC_ALL, "rus");
    int N = 5, M = 7, S = 0;
    for (int i = 0; i < N; i++)
    for (int j = 0; j < M; j++)
        S += i * j;
    cout << S << endl;
    return 0;
}</code></pre>
    <p>В данном коде первый цикл задается от 0 до N-1, так как стоит знак меньше. Поэтому, когда i будет N-1, оно будет
        истинным, а когда N, то цикл завершит свою работу. Аналогично со вторым циклом, внутри второго цикла идет
        подсчет
        суммы. Результат выполнения данного программного кода представлен на рисунке 1.49.</p>
    <p class="photo"><img src="./img/1_chapter/1.49.png" alt=""></p>
    <p class="signature">Рисунок 1.49 &#8211; Результат работы программы</p>
    <p>Как видно на рисунке 1.49, в результате работы данного кода получилось 210. Наглядную работу двух вложенных
        циклов
        for можно представить в виде таблицы на рисунке 1.50.</p>
    <p class="photo"><img src="./img/1_chapter/1.50.png" alt=""></p>
    <p class="signature">Рисунок 1.50 &#8211; Представление работы двух вложенных циклов for </p>
    <p>По строчкам меняется значение i, а по столбцам значение j, и в каждой клетке записаны значения переменных i и j.
        В
        соответствии с формулой задачи i и j перемножаются, а затем получается нужная сумма.</p>
    <h3 id="1.4.4.5">1.4.4.5 Операторы break и continue</h3>
    <p>Об операторе break уже есть упоминание выше, когда рассматривалась работа цикла for, с помощью оператора break
        прерывалась работа цикла for, такое происходит, потому что как только данный оператор встречается в теле цикла,
        то
        цикл завершает свою работу.</p>
    <p>Также с помощью этого оператора прерывается бесконечный цикл. Когда его нужно прервать, в тело цикла добавляется
        условие, при выполнении которого сработает оператор break, а цикл завершит работу <a href="source.html#metka1">[1]</a>.</p>
    <p>В следующем примере представлена работа с оператором break. Реализована простая игра: один игрок загадывает число
        от
        1 до 7, второй должен отгадать его.</p>
    <pre class="cpp-code"><code class="language-cpp">#include &ltiostream>
using namespace std;
int main(){
	setlocale(LC_ALL, "rus");
	int digit = 0;
	int answer = 0;
	cout << "Введите число от 1 до 7, которое должен угадать ваш противник:";
	for (;;)
	{
		cin >> digit; // ввод загаданного числа
		if (digit >= 1 && digit <= 7) // проверяем число на соответствие заданному диапазону
		{
			break; // если соответствует – прервать цикл
		}
		else // иначе попросить ввести число снова
		{
			cout << "Неправильный диапазон! Введите число от 1 до 7:";
		}
	}
	system("cls"); //эта функция очистит экран, и противник не увидит, какое число было введено
	cout << "Попробуйте угадать число, которое загадал ваш оппонент!\n";
	cout << "Это целое число от 1 до 7. Введите ваш вариант ответа:";
	for (int myTry = 1;; myTry++)
		// myTry будет хранить число попыток
	{
		cin >> answer;
		if (answer < 1 || answer > 7) // если диапазон нарушен
		{
			myTry--; // уменьшаем счетчик попыток на единицу
			cout << "!!!Введите число в диапазоне от 1 до 7:";
		}
		else if (digit == answer) // если числа совпадают
		{
			cout << "Поздравляем! Вы отгадали число с " << myTry << "-й попытки!\n\n";
			break; // прервать цикл
		}
		else // иначе еще одна попытка отгадать
		{
			cout << "Вы не угадали! Попробуйте еще раз:";
		}
	}
	return 0;
}</code></pre>
    <p>Чтобы всё было честно и игрок, который загадывает, не мог ввести число из недопустимого диапазона, запускаем
        бесконечный цикл, в котором и происходят ввод и проверка числа. Если число соответствует необходимому диапазон,
        цикл
        прерывается, если же нет &#8211; на экране появляется предупреждение и предложение ввести число снова. Так будет
        происходить, пока введенное число не войдет в нужный диапазон.</p>
    <p>После ввода корректного числа вызываем специальную функцию system ("cls");, которая очистит содержимое экрана
        перед
        тем, как второй игрок приступит к отгадыванию числа (сработает только в windows) <a href="source.html#metka9">[9]</a>.</p>
    <p>Далее определяем второй бесконечный цикл, но уже со счетчиком myTry. Он будет считать количество попыток игрока
        отгадать число. Игрок вводит число, и оно сразу проверяется на соответствие диапазону.</p>
    <p>Если не соответствует, предупреждаем и отнимаем единицу от счетчика попыток myTry. Иначе если число в нужный
        диапазон вошло, то проверяем, соответствует ли оно загаданному числу: да &#8211; поздравляем и прерываем цикл,
        нет &#8211; говорим об ошибке и предлагаем ввести число снова (рисунки 1.51 &#8211; 1.52).</p>
    <p class="photo"><img src="./img/1_chapter/1.51.png" alt=""></p>
    <p class="signature">Рисунок 1.51 &#8211; Результат работы оператора break</p>
    <p class="photo"><img src="./img/1_chapter/1.52.png" alt=""></p>
    <p class="signature">Рисунок 1.52 &#8211; Результат работы оператора break. Вывод сообщений</p>
    <p>Оператор continue пропускает тело цикла, которое стоит после него. Этот оператор применяется тогда, когда
        необходимо
        прервать (пропустить) текущую итерацию цикла и приступить к следующей итерации. При его выполнении в цикле for
        происходит остановка текущей итерации, переход к изменению управляющей переменной, а затем проверка условия
        продолжения выполнения цикла.</p>
    <p>Далее приведен пример использования оператора continue для решения следующей задачи. Необходимо вывести на экран
        те
        числа, которые делятся на 7 без остатка и находятся в диапазоне от 1 до 70:</p>
    <pre class="cpp-code"><code class="language-cpp">#include &ltiostream>
using namespace std;
int main(){
	for (int i = 1; i <= 70; i++) {
		if (i % 7 != 0) // если число не делится на 7 без остатка
		{
			continue; // прервать эту итерацию цикла и выполнить i++
		}
		cout << i << endl;
	}
	return 0;
}</code></pre>
    <p>Результат выполнения данного программного кода представлен на рисунке 1.53.</p>
    <p class="photo"><img src="./img/1_chapter/1.53.png" alt=""></p>
    <p class="signature">Рисунок 1.53 &#8211; Результат работы оператора continue</p>
    <p>Если число i не делится на 7 без остатка (остаток от деления не равен 0), сработает continue. То есть строка кода
        12 уже не выполнится, и мы не увидим число i на экране. В случае, если остаток от деления i на 7 будет равен 0
        (число делится на 7 нацело), тело if выполнено не будет, и число будет показано.</p>
    <p>Далее рассмотрен еще один пример. Представлен код программы для решения следующей задачи: пользователь вводит с
        клавиатуры числа, и подсчитывается сумма 5 положительных чисел (пользователь может ввести как отрицательные, так
        и
        положительные числа).</p>
    <pre class="cpp-code"><code class="language-cpp">#include &ltiostream>
using namespace std;
int main(){
	setlocale(LC_ALL, "rus");
	float x, S = 0;
	int n = 0;
	do
	{
		cout << "Введите число: ";
		cin >> x;
		if (x < 0) continue;
		n++;
		S += x;
		cout << "Текущая сумма: " << S << endl;
	} while (n < 5);
	return 0;
}</code></pre>
    <p>В данном примере сначала задается вещественное значение х, которое будет вводиться с клавиатуры, затем задается
        переменная S, которая будет хранить сумму 5 положительных чисел, и счетчик положительных чисел n. В цикле
        do...while
        пользователь вводит число, а затем с помощью условного оператора if происходит проверка: если число
        положительное,
        то происходит переход к следующим операторам, а если число отрицательное, то вызывается оператор continue,
        который
        пропускает все следующие операторы и начинает работу цикла do...while заново.</p>
    <p>Результат выполнения данного программного кода представлен на рисунке 1.54.</p>
    <p class="photo"><img src="./img/1_chapter/1.54.png" alt=""></p>
    <p class="signature">Рисунок 1.54 &#8211; Результат работы программы</p>
    <p>Хотелось бы отметить, что операторы цикла взаимозаменяемы, но можно привести некоторые рекомендации по выбору
        наилучшего в каждом конкретном случае.</p>
    <p>Оператор do...while обычно используют, когда цикл требуется обязательно выполнить хотя бы раз (например, если в
        цикле
        производится ввод данных).</p>
    <p>Оператор for предпочтительнее в большинстве остальных случаев (однозначно для организации циклов со
        счетчиками).</p>
    <p>Оператором while удобнее пользоваться в случаях, когда число итераций заранее неизвестно, очевидных параметров
        цикла
        нет или модификацию параметров удобнее записывать не в конце тела цикла.</p>
    <h3 id="1.5">1.5 Контрольные вопросы для закрепления изученного материала </h3>
    <ol>
        <li class="with-a-bracket">Что такое алгоритм?</li>
        <li class="with-a-bracket">Какие виды алгоритма бывают?</li>
        <li class="with-a-bracket">Укажите базовые математические функции языка С++.</li>
        <li class="with-a-bracket">Перечислите операторы цикла языка С++.</li>
        <li class="with-a-bracket">В чем заключается задача оператора switch?</li>
    </ol>
</script>

<script id="page1.6" type="text/html">
    
    <TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0>
        <TR>
            <TD width="50%"><a name="3"></a>
                <HR>
                <div align=justify><h1>Тренировочные упражнения</h1></div>
  <form>
   <ol> 
    <li class="without-parentheses"> Какой результат будет выведен после выполнения данного кода программы?
     <pre class="cpp-code"><code class="language-cpp">
#include &ltiostream>
using namespace std;
int main() {
    int b = 0;
    b -= 7;
    cout << b;
    return 0;
}
</code></pre>  
              <p>Ответ: <input type="text" id="glav1_1"></p>
        <input type="button" value="Ответить" class="proverit_glav1_1"></input>
              <input type="reset" value ="Очистить"></input>
              <br><br>
                 <div id="resultat"></div>
                  </form>
              </li><br><br>
         
<li class="without-parentheses"> Соотнесите описания функций с их наименованиями</li> <br><br>

<table class="table_center table_glava1">
    <tr>
        <td>
            <ul class="static_ul static_glava1">
                <li>fabs()</li>
                <li>fmod()</li>
                <li>ceil()</li>
                <li>floor()</li>
            </ul>
        </td>
        <td>
            <ul class="droppable_ul1 droppable_ul static_glava11" id="parent1">
            </ul>
            <ul class="droppable_ul2 droppable_ul static_glava11" id="parent2">
            </ul>
            <ul class="droppable_ul3 droppable_ul static_glava11" id="parent3">
            </ul>
            <ul class="droppable_ul4 droppable_ul static_glava11" id="parent4">
            </ul>
        </td>
        <td>
            <ul class="draggable_ul draggable_glava1">
                <li class="ufo draggable_li" id="ufo1" draggable="true">Вычисление остатка от деления</li>
                <li class="ufo2 draggable_li" id="ufo2" draggable="true">Округление к меньшему</li>
                <li class="ufo3 draggable_li" id="ufo3" draggable="true">Округление до большего</li>
                <li class="ufo4 draggable_li" id="ufo4" draggable="true">Вычисление абсолютного значения</li>
            </ul>
        </td>
    </tr>
</table>
 <input type="button" value="Ответить" onclick="provet()"></input>
 <input type="button" value ="Сбросить" onclick="provet_del()"></input>

    <br></br><br>
    <div class="button" id="resultat_2" ></div>
</ol>
</script> 

<!-- <script id="page1.8" type="text/html"></script> -->

</script>

<script id="page1.7" type="text/html">
    <TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0>
        <TR>
            <TD width="50%"><a name="3"></a>
                <HR>
                <div align=justify><h1>Тестирование по первой главе</h1></div>
                <form name=test>
                    <ol>
                        <li class="without-parentheses"><h4><input type=text name=T1 style="height: 15px; width:15px;"
                                                                   value=''> Что такое алгоритм?
                        </h4>
                            <input type=radio name=Q1> совокупность чётко определенных действий, выполнение
                            которых ведёт к
                            решению задачи;<br>
                            <input type=radio name=Q1> последовательность действий, выполнение которых ведёт к
                            концу;<br>
                            <input type=radio name=Q1> набор определений и понятий, определенных в языке С++;<br>
                            <input type=radio name=Q1> повтор
                            действий, приводящих к решению задачи;<br>
                            <input type=radio name=Q1> нет верного ответа.<br>
                            <br>
                        </li>
                        <li class="without-parentheses">
                            <h4><input type=text name=T2 style="height: 15px; width:15px;" value=''> Какие существуют
                                свойства алгоритма?</h4>
                            <input type=radio name=Q2> дискретность, детерминированность, конечность,
                            массовость,
                            результативность;<br>
                            <input type=radio name=Q2> постоянство, детерминированность, конечность, массовость,
                            продолжительность;<br>
                            <input type=radio name=Q2> дискретность, детерминированность, бесконечность, группировка,
                            распределение;<br>
                            <input type=radio name=Q2> постоянство, недетерминированность, бесконечность, массовость,
                            результативность;<br>
                            <input type=radio name=Q2> нет верного ответа.<br>
                            <br>
                        </li>
                        <li>
                            <h4><input type=text name=T3 style="height: 15px; width:15px;" value=''> После компиляции
                                программы:</h4>
                            <input type=radio name=Q3> ее можно выполнять только с одним набором исходных
                            данных;<br>
                            <input type=radio name=Q3> перед каждым последующим запуском ее нужно перекомпилировать;<br>
                            <input type=radio name=Q3> ее можно выполнять многократно без перекомпиляции;<br>
                            <input type=radio name=Q3> можно запускать только .exe файл;<br>
                            <input type=radio name=Q3> нет верного ответа.<br>
                            <br>
                        </li>
                        <li>
                            <h4><input type=text name=T4 style="height: 15px; width:15px;" value=''> При выходе из
                                функции
                                main:</h4>
                            <input type=radio name=Q4> выполняется функция finish, определенная
                            программистом;<br>
                            <input type=radio name=Q4> программа заканчивается;<br>
                            <input type=radio name=Q4> программа повторяется с теми же аргументами;<br>
                            <input type=radio name=Q4> выводится сообщение об ошибке;<br>
                            <input type=radio name=Q4> нет верного ответа.<br>
                            <br>
                        </li>
                        <li>
                            <h4><input type=text name=T5 style="height: 15px; width:15px;" value=''> Исходя из данного
                                кода,
                                какое высказывание верно?</h4>
                            <pre class="cpp-code"><code class="language-cpp">int main(){
    int a, b, c, d;
    a = 1;
    b = 2;
    c = a + b + p;
    cout << p;
}</code></pre>
                            </p>
                            <input type=radio name=Q5> код неверен, потому что переменным c и d не присвоены
                            значения;<br>
                            <input type=radio name=Q5> код неверен, потому что переменная p не объявлена;<br>
                            <input type=radio name=Q5> код верен, потому что по умолчанию все переменные имеют
                            целочисленный
                            тип;<br>
                            <input type=radio name=Q5> код верен, потому что по умолчанию все переменные имеют
                            вещественный
                            тип;<br>
                            <input type=radio name=Q5> нет верного ответа.<br>
                            <br>
                        </li>
                        <li>
                            <h4><input type=text name=T6 style="height: 15px; width:15px;" value=''> Оператор вывода
                                cout
                                может печатать несколько значений или переменных в одной команде, используя следующий
                                синтаксис:</h4>
                            <input type=radio name=Q6> cout << "Привет" + name + "n";<br>
                            <input type=radio name=Q6> cout << ("Привет" &name& "n");<br>
                            <input type=radio name=Q6> cout << "Привет" << name << "n";<br>
                            <input type=radio name=Q6> cout << "Привет;name;n);<br>
                            <input type=radio name=Q6> cout << "Привет", name, "n".<br>
                            <br>
                        </li>
                        <li>
                            <h4><input type=text name=T7 style="height: 15px; width:15px;" value=''> Укажите операцию,
                                приоритет выполнения которой больше остальных:</h4>
                            <input type=radio name=Q7> +;<br>
                            <input type=radio name=Q7> /;<br>
                            <input type=radio name=Q7> *;<br>
                            <input type=radio name=Q7> ++;<br>
                            <input type=radio name=Q7> ( ).<br>
                            <br>
                        </li>
                        <li>
                            <h4><input type=text name=T8 style="height: 15px; width:15px;" value=''> Какие
                                преобразования
                                типов данных невозможны без потери данных?</h4>
                            <input type=radio name=Q8> все перечисленные преобразования невозможны;<br>
                            <input type=radio name=Q8> char to float;<br>
                            <input type=radio name=Q8> float to int;<br>
                            <input type=radio name=Q8> string toint;<br>
                            <input type=radio name=Q8> int to float.<br>
                            <br>
                        </li>
                        <li>
                            <h4><input type=text name=T9 style="height: 15px; width:15px;" value=''> Как написать
                                следующее
                                выражение на языке С++:
                                «Переменной a присвоено значение b»?</h4>
                            <input type=radio name=Q9> a==b;<br>
                            <input type=radio name=Q9> a=b;<br>
                            <input type=radio name=Q9> b=a;<br>
                            <input type=radio name=Q9> a:=b;<br>
                            <input type=radio name=Q9> нет верного ответа.<br>
                            <br>
                        </li>
                        <li>
                            <h4><input type=text name=T10 style="height: 15px; width:15px;" value=''> Логическая
                                операция с
                                большим приоритетом выполнения:</h4>
                            <input type=radio name=Q10> ||;<br>
                            <input type=radio name=Q10> !;<br>
                            <input type=radio name=Q10> &&;<br>
                            <input type=radio name=Q10> -;<br>
                            <input type=radio name=Q10> ==.<br>
                            <br>
                        </li>
                    </ol>
                    <div align="center">
                        <div>
                            <input type=button value="Показать результат" onClick="test1('MTEzMjIxNDMyMg', 10)">
                        </div>
                        <div>
                            <textarea style="margin-top:6px" rows=5 cols="100%" name=s1></textarea>
                        </div>
                        <div>
                            <input type=reset value="Очистить выбранные пункты">
                        </div>
                        <br>
                        <Div align=center>
                            <a href="#3">В начало страницы</a>
                        </div>
                        <br>
                    </div>
                </form>
            </TD>
        </TR>
    </TABLE>
</script>

<!-- /page2 -->
<script id="page2" type="text/html">
    <h2 id="2">2 Массивы</h2>
    <h3 id="2.1">2.1 Создание массивов</h3>
    <p><a href="glossary.html#m8">Массив</a> &#8211; это пронумерованный набор однотипных элементов. Для того чтобы создать массив в языке С++,
        используется
        синтаксис:</p>
    <pre class="cpp-code"><code class="language-cpp">&ltтип данных> &ltимя массива> [число элементов];</code></pre>
    <p>Сначала задается тип данных элемента массива, затем имя массива и затем в квадратных скобках указывается
        максимальное число элементов этого массива <a href="source.html#metka10">[10]</a>.</p>
    <p>Для понимания сущности массивов необходимо рассмотреть пример. Допустим, необходимо хранить в памяти компьютера
        значение линейной функции y=kx+b при значениях x = 0, 1, 2, ..., 99. Для того чтобы это сделать, понадобится 100
        переменных. Однако всё это можно сделать гораздо проще, задав массив из 100 элементов, и в каждый элемент
        массива
        записать значение функции при конкретных значениях x.</p>
    <p>Например:</p>
    <pre class="cpp-code"><code class="language-cpp">float y[100];</code></pre>
    <p>В рассмотренном примере следует выбрать вещественный тип данных, имя массива такое же, как и функции, и
        максимальное
        число его элементов равно 100. Получился массив y, состоящий из ста элементов.</p>
    <p>Для того чтобы в первый элемент массива записать первое значение функции, используется синтаксис:</p>
    <pre class="cpp-code"><code class="language-cpp">y[0] = k*0 + b; //первый элемент массива
y[1] = k*1 + b; //второй элемент массива</code></pre>
    <p>Где k и b &#8211; переменные с какими-либо значениями, а 0 соответствует первому значению х. Следует обратить
        внимание, что первый элемент массива всегда имеет <a href="glossary.html#m6">индекс</a> 0.</p>
    <p>Далее представлен код программы, которая заносит 100 значений линейной функции в массив и выводит их на
        экран:</p>
    <pre class="cpp-code"><code class="language-cpp">#include &ltiostream>
using namespace std;
int main(){
	setlocale(LC_ALL, "rus");
	float y[100], k = 0.5, b = 2; //задан массив, определены переменные
	for (int x = 0; x < 100; ++x) //цикл от 0 до 100
		y[x] = k * x + b; //таким образом заносятся все значения в массив
	for (int x = 0; x < 100; ++x) //второй цикл выводит все значения
		cout << y[x] << " "; // элементов на экран
	return 0;
}</code></pre>
    <p>Результат выполнения данного программного кода представлен на рисунке 2.1.</p>
    <p class="photo"><img src="./img/2_chapter/2.1.png" alt=""></p>
    <p class="signature">Рисунок 2.1 &#8211; Пример работы с массивами</p>
    <p>Как видно на рисунке 2.1, выведены значения линейной функции. Следует обратить внимание, что в конструкции cout
        <<
        y[x] << " "; происходит считывание текущего значения элемента и вывод его на экран. То есть, чтобы прочитать
        какое-либо значение из массива «y», используется конструкция: float a = y[5]; переменная «а» принимает значение
        шестого элемента массива «y».</p>
    <h3 id="2.2">2.2 Инициализация массивов</h3>
    <p>Особенностью инициализации массива является то, что их размер нельзя задавать через переменную, например, нельзя
        задать переменную N, равную 100. А затем определить массив через эту переменную. Так делать нельзя.</p>
    <pre class="cpp-code"><code class="language-cpp">int N = 100;
float array_f[N];  // ошибка, так делать нельзя!!!</code></pre>
    <p>Вместо этого следует поступать другим способом: необходимо задать константу (#define N 100) и далее определять
        массив
        через эту константу (float y[N], k = 0.5, b = 2;).</p>
    <pre class="cpp-code"><code class="language-cpp">#define N 100
float y[N], k = 0.5, b = 2;</code></pre>
    <p>Если размер нашего массива изменится, то для этого будет достаточно просто поменять значение константы N.</p>
    <p>В языке С++ можно сразу инициализировать массив конкретными значениями в момент его объявления вот таким
        образом:</p>
    <pre class="cpp-code"><code class="language-cpp">int powers[4] = {1, 2, 4, 6}; //задали массив размерностью в 4 элемента и сразу их задали
    //(первый элемент имеет значение 1, второй – 2 и т.д.)</code></pre>
    <p>Можно задавать элементы массива и таким образом:</p>
    <pre class="cpp-code"><code class="language-cpp">int data[] = {2, 16, 32, 64, 128, 256}; //здесь, в квадратных скобках, размер массива не указан,
    //он определяется числом инициализируемых элементов.
    //В данном случае этих элементов шесть, поэтому размер массива равен шести.</code></pre>
    <p>Причем задавать такой массив без указания его размера можно только при инициализации его конкретными
        значениями.</p>
    <pre class="cpp-code"><code
            class="language-cpp">int data[]; // так делать нельзя, т. к. не указан размер массива</code></pre>
    <p>Одной из функций для работы с массивами используется функция sizeof(). Данная функция определяет число элементов
        в массиве, возвращает число байт, которое занимает та или иная переменная.</p>
    <p>Далее представлен пример вычисления с помощью данной функции размер массива data:</p>
    <pre class="cpp-code"><code class="language-cpp">int data[] = {2, 16, 32, 64, 128, 256};
int N = sizeof(data)/sizeof(int);</code></pre>
    <p>В данном случае переменная N будет содержать число элементов массива, далее вычисляется, сколько байт занимает
        массив
        data, и делится на размер байт, который занимает один элемент этого массива, в результате получаем число
        элементов
        массива.</p>
    <p>В данном случае здесь у нас шесть элементов, которые занимают 24 байта (каждый по 4), а sizeof(int) будет равен
        4,
        соответственно 24/4 = 6, N = 6.</p>
    <h3 id="2.3">2.3 Классификация массивов</h3>
    <p>Массивы бывают статическими и динамическими. У статического массива количество элементов известно заранее и не
        может
        быть изменено. У динамического массива количество элементов заранее неизвестно и определяется в процессе
        выполнения
        программы .</p>
    <p>Также массивы различаются по размерности: одномерные, двумерные, трехмерные и т.д. Примером одномерного массива
        может
        послужить вектор а{1, 4, 3, 5}. Примером двухмерного массива может послужить матрица. Примером трехмерного
        массива
        может послужить набор высот местности.</p>
    <p>Массивы различают по типу элементов. Бывают целочисленные, вещественные (состоящие из дробных чисел), символьные
        массивы.</p>
    <p>Примеры массивов:</p>
    <ol>
        <li class="with-a-bracket">вектор а{1, -4, 3, 5} &#8211; одномерный вещественный массив из четырех элементов;
        </li>
        <li class="with-a-bracket">матрица<img src="./img/2_chapter/matrix.png" alt=""> &#8211; двумерный целочисленный
            массив
            из шести элементов;
        </li>
        <li class="with-a-bracket">{"x", 3, "%"} &#8211; одномерный символьный массив;</li>
        <li class="with-a-bracket">{"x, -3.31,"%"} не является массивом, т. к. часть элементов &#8211; символы, часть
            элементов &#8211; числа.
        </li>
    </ol>
    <p><a href="glossary.html#m6">Индекс</a> &#8211; это номер элемента в массиве.</p>
    <p>У одномерного массива один индекс, обычно он обозначается i.</p>
    <p>Чтобы использовать одномерный массив в программе, необходимо:</p>
    <ol>
        <li class="with-a-bracket">объявить массив в функции main();</li>
        <li class="with-a-bracket">тип_данных имя_массива[количество элементов];</li>
        <li class="with-a-bracket">double a[3]; //статический массив а из трех дробных чисел<br>a.int b[7];
            //статический
            массив b из семи целых чисел
        </li>
        <li class="with-a-bracket">проинициализировать массив, т. е. задать каждому элементу конкретное числовое
            значение;
        </li>
        <li class="with-a-bracket">провести вычисления, исследования.</li>
    </ol>
    <p>Индексация в массиве начинается с 0, т. е. <a href="glossary.html#m6">индекс</a>  у самого первого элемента в массиве i = 0. Индексация элементов
        в
        массиве a(7) = {-10; 0.2; 3; -4.7; 0.5; -8; 11} указана в таблице 2.1.</p>
    <p>Таблица 2.1 &#8211; Индексация одномерного массива</p>
    <p class="tables"><img src="./img/2_chapter/table2.1.png" alt=""></p>
    <p>У двумерного массива имеется два индекса: i &#8211; номер строки, j &#8211; номер столбца. Индексация двумерного
        массива
        представлена на рисунке 2.2.</p>
    <p class="photo"><img src="./img/2_chapter/2.2.png" alt=""></p>
    <p class="signature">Рисунок 2.2 &#8211; Индексация двумерного массива</p>
    <p>Двумерные массивы удобно использовать для хранения таких видов информации, как, например, изображения.</p>
    <h3 id="2.4">2.4 Одномерные массивы</h3>
    <p>Одномерный массив &#8211; массив с одним параметром, характеризующим количество элементов одномерного массива.
        Фактически
        одномерный массив &#8211; это массив, у которого может быть только одна строка и n-е количество столбцов.
        Столбцы в
        одномерном массиве &#8211; это элементы массива. Одномерный массив можно инициализировать разными способами.
        Далее
        преставлены различные способы инициализации одномерных массивов.</p>
    <table>
        <tr>
            <td>1) инициализация числами:<br>
                <p class="table-photo"><img src="./img/2_chapter/table-photo2.1.png" alt=""></p></td>
            <td>
                <pre class="cpp-code"><code class="language-cpp">double a[4]={0.5, -2, 856, 1};</code></pre>
            </td>
        </tr>
        <tr>
            <td>2) с клавиатуры:<br>
                <p class="table-photo"><img src="./img/2_chapter/table-photo2.2.png" alt="" width="65%"></p></td>
            <td><pre class="cpp-code"><code class="language-cpp">double a[n];<br>int i;
for (i = 0; i < n; i = i + 1){
    cout << "a[" << i << "]=";
    cin >> a[i];
}</code></pre>
            </td>
        </tr>
        <tr>
            <td>3) из файла:<br>
                <p class="table-photo"><img src="./img/2_chapter/table-photo2.3.png" alt="" width="65%"></p></td>
            <td><pre class="cpp-code"><code class="language-cpp">double a[n]; int i;
fstream file;
file.open("1.txt", ios::in);
for (i = 0; i < n; i = i + 1){
    file >> a[i];
}
file.close();</code></pre>
            </td>
        </tr>
        <tr>
            <td>4) по заданной формуле a[i]=f(i):<br>
                <p class="table-photo"><img src="./img/2_chapter/table-photo2.4.png" alt="" width="65%"></p></td>
            <td><pre class="cpp-code"><code class="language-cpp">double a[n];
int i;
for (i = 0; i < n; i = i + 1){
    a[i] = f(i);
}</code></pre>
            </td>
        </tr>
    </table>
    <p>Вывод одномерного массива на экран представлен в ниже:</p>
    <pre class="cpp-code"><code class="language-cpp">for (i = 0; i < n; i = i + 1){
	cout << "a[" << i << "]=" << a[i] << endl;
}</code></pre>
    <p>Помимо ввода и вывода данных одномерных массивов, с ними можно реализовать работу по нарождению суммы,
        произведения,
        минимального, максимального значений.</p>
    <table>
        <tr>
            <td>1) нахождение суммы:<br>
                <p class="table-photo"><img src="./img/2_chapter/table-photo2.5.png" alt="" width="45%" height="35%">
                </p></td>
            <td>
                <pre class="cpp-code"><code class="language-cpp">c</code></pre>
            </td>
        </tr>
        <tr>
            <td>2) нахождение произведения:<br>
                <p class="table-photo"><img src="./img/2_chapter/table-photo2.6.png" alt="" width="45%" height="35%">
                </p></td>
            <td><pre class="cpp-code"><code class="language-cpp">p = 1;
for (i = 0; i < n; i = i + 1){
    p = p * a[i];
}
cout << "p = " << p << endl;</code></pre>
            </td>
        </tr>
        <tr>
            <td>3) нахождение среднего арифметического и количества элементов:<br>
                <p class="table-photo"><img src="./img/2_chapter/table-photo2.7.png" alt="" width="45%" height="35%">
                </p></td>
            <td><pre class="cpp-code"><code class="language-cpp">s = 0, k = 0;
for (i = 0; i < n; i = i + 1){
    s = s + a[i];
    k = k + 1;
}
s = s / k;
cout << "s = " << s << endl;
cout << "k = " << k << endl;</code></pre>
            </td>
        </tr>
        <tr>
            <td>4) нахождение максимального элемента:<br>
                <p class="table-photo"><img src="./img/2_chapter/table-photo2.8.png" alt="" width="45%" height="35%">
                </p></td>
            <td><pre class="cpp-code"><code class="language-cpp">max = -10E10;
imax = 0;
for (i = 0; i < n; i = i + 1){
    if (a[i] > max){
        max = a[i];
        imax = i;
    }
}
cout << "max = " << max << " imax = " << imax << endl;</code></pre>
            </td>
        </tr>
        <tr>
            <td>5) нахождение минимального элемента:<br>
                <p class="table-photo"><img src="./img/2_chapter/table-photo2.9.png" alt="" width="45%" height="35%">
                </p></td>
            <td><pre class="cpp-code"><code class="language-cpp">min = 10E10;
imin = 0;
for (i = 0; i < n; i = i + 1){
    if (a[i] < min){
        min = a[i];
        imin = i;
    }
}</code></pre>
            </td>
        </tr>
        <tr>
            <td>6) поменять местами элементы с индексами<br>i1 и i2:<br>
                <p class="table-photo"><img src="./img/2_chapter/table-photo2.10.png" alt="" width="40%" height="30%">
                </p></td>
            <td><pre class="cpp-code"><code class="language-cpp">tmp = a[i1];
a[i1] = a[i2];
a[i2] = tmp;
        </code></pre>
            </td>
        </tr>
        <tr>
            <td>7) вычисление формулы:<br>
                <p class="table-photo"><img src="./img/2_chapter/table-photo2.11.1.png" alt="" width="45%" height="35%">
                </p>
                <p class="table-photo"><img src="./img/2_chapter/table-photo2.11.2.png" alt="" width="45%" height="35%">
                </p></td>
            <td><pre class="cpp-code"><code class="language-cpp">s = 0;
for (i = 0; i < n; i = i + 1){
    s = s + f(a[i], i);
}
cout << "s = " << s << endl;</code></pre>
            </td>
        </tr>
    </table>
    <h3 id="2.5">2.5 Двумерные массивы</h3>
    <p>Двумерные массивы используют две квадратные скобки, и в каждой скобке пишется число элементов этого массива.
        Какой
        индекс считать строками, а какой столбцами, решает сам программист. Компьютер все равно будет обрабатывать
        элементы
        массива в соответствии с программой, и что такое строки и столбцы, ему неизвестно <a href="source.html#metka12">[12]</a>.</p>
    <p>Например, задан двумерный массив 100x20 элементов:</p>
    <pre class="cpp-code"><code class="language-cpp">int array2D[100][20];</code></pre>
    <p>Тогда первый элемент данного массива будет int array2D[0][0], и в него можно занести какое-либо значение.</p>
    <pre class="cpp-code"><code class="language-cpp">int array2D[0][0] = 1; //первому элементу присвоено число 1
int array2D[0][1] = 2; //второму элементу присвоено число 2
int array2D[0][2] = 3; //третьему элемент присвоено число 3</code></pre>
    <p>Для начальной инициализации двумерного массива используется синтаксис:</p>
    <pre class="cpp-code"><code class="language-cpp">short array2D[3][2] = { {1, 2}, {3, 4}, {5, 6} };</code></pre>
    <p>Сначала идут первые фигурные скобки, а во-вторых, фигурных скобках уже перечисляются элементы этого массива.</p>
    <p>Также двумерный массив можно задавать и таким образом:</p>
    <pre class="cpp-code"><code class="language-cpp">short array2D[][] = { {1, 2}, {3, 4}, {5, 6} };</code></pre>
    <p>В квадратных скобках можно не указывать размер, он сам будет определяться по числу инициализируемых
        элементов.</p>
    <p>Далее представлены способы инициализации двумерных массивов.</p>
    <table>
        <tr>
            <td>1) из файла:<br>
                <p class="table-photo"><img src="./img/2_chapter/table-photo2.12.png" alt="" width="60%" height="45%">
                </p></td>
            <td><pre class="cpp-code"><code class="language-cpp">double a[n][m];
int i, j;
fstream file;
file.open("1.txt", ios::in);
for (i = 0; i < n; i = i + 1){
    for (j = 0; j < m; j = j + 1){
        file >> a[i][j];
    }
}
file.close();</code></pre>
            </td>
        </tr>
        <tr>
            <td>2) по заданной формуле a[i][j] = f (i,j):<br>
                <p class="table-photo"><img src="./img/2_chapter/table-photo2.13.png" alt="" width="60%" height="45%">
                </p></td>
            <td><pre class="cpp-code"><code class="language-cpp">double a[n][m];
int i, j;
fstream file;
file.open("1.txt", ios::in);
for (i = 0; i < n; i = i + 1){
    for (j = 0; j < m; j = j + 1){
        file >> a[i][j];
    }
}
file.close();</code></pre>
            </td>
        </tr>
    </table>
    <p>Вывод двумерного массива на экран представлен в ниже:</p>
    <pre class="cpp-code"><code class="language-cpp">for (i = 0; i < n; i = i + 1){
	for (j = 0; j < m; j = j + 1){
		cout << setw(6) << a[i][j];
	}	cout << endl;
}</code></pre>
    <p>Далее представлена принципы нахождения таких величин, как сумма, произведение, минимальное, максимальное
        значение:</p>
    <table>
        <tr>
            <td>1) нахождение суммы:<br>
                <p class="table-photo"><img src="./img/2_chapter/table-photo2.14.png" alt="" width="45%" height="35%">
                </p></td>
            <td><pre class="cpp-code"><code class="language-cpp">s = 0;
for (i = 0; i < n; i = i + 1){
	for (j = 0; j < m; j = j + 1){
		s = s + a[i][j];
	}
}
cout << "s = " << s << endl;</code></pre>
            </td>
        </tr>
        <tr>
            <td>2) нахождение произведения:<br>
                <p class="table-photo"><img src="./img/2_chapter/table-photo2.15.png" alt="" width="45%" height="35%">
                </p></td>
            <td><pre class="cpp-code"><code class="language-cpp">p = 1;
for (i = 0; i < n; i = i + 1){
	for (j = 0; j < m; j = j + 1){
		p = p * a[i][j];
	}
}
cout << "p = " << p << endl;</code></pre>
            </td>
        </tr>
        <tr>
            <td>3) нахождение среднего арифметического и количества элементов:<br>
                <p class="table-photo"><img src="./img/2_chapter/table-photo2.16.png" alt="" width="45%" height="35%">
                </p></td>
            <td><pre class="cpp-code"><code class="language-cpp">s = 0, k = 0;
for (i = 0; i < n; i = i + 1){
	for (j = 0; j < m; j = j + 1){
		s = s + a[i][j];
		k = k + 1;
	}
}
s = s / k;
cout << "s = " << s << endl;
cout << "k = " << k << endl;</code></pre>
            </td>
        </tr>
        <tr>
            <td>4) нахождение максимального элемента:<br>
                <p class="table-photo"><img src="./img/2_chapter/table-photo2.17.png" alt="" width="60%" height="45%">
                </p></td>
            <td><pre class="cpp-code"><code class="language-cpp">max = -10E10;
imax = 0; jmax = 0;
for (i = 0; i < n; i = i + 1){
	for (j = 0; j < m; j = j + 1){
		if (a[i][j] > max) {
			max = a[i][j];
			imax = i;
			jmax = j;
		}
	}
}
cout << "max = " << max << endl;
cout << "imax = " << imax << endl;
cout << "jmax = " << jmax << endl;</code></pre>
            </td>
        </tr>
        <tr>
            <td>5) нахождение минимального элемента:<br>
                <p class="table-photo"><img src="./img/2_chapter/table-photo2.18.png" alt="" width="45%" height="35%">
                </p></td>
            <td><pre class="cpp-code"><code class="language-cpp">min = 10E10;
imin = 0; jmin = 0;
for (i = 0; i < n; i = i + 1){
	for (j = 0; j < m; j = j + 1){
		if (a[i][j] < min){
			min = a[i][j];
			imin = i;
			jmin = j;
		}
	}
}
cout << "min = " << min << endl;
cout << "imin = " << imin << endl;
cout << "jmin = " << jmin << endl;</code></pre>
            </td>
        </tr>
        <tr>
            <td>6) поменять элементы i1, j1 и i2, j2 местами:<br>
                <p class="table-photo"><img src="./img/2_chapter/table-photo2.19.png" alt="" width="45%" height="35%">
                </p></td>
            <td><pre class="cpp-code"><code class="language-cpp">tmp = a[i1][j1];
a[i1][j1] = a[i2][j2];
a[i2][j2] = tmp;</code></pre>
            </td>
        </tr>
        <tr>
            <td>7) поменять местами строки i1 и i2:<br>
                <p class="table-photo"><img src="./img/2_chapter/table-photo2.20.png" alt="" width="45%" height="35%">
                </p></td>
            <td><pre class="cpp-code"><code class="language-cpp">for (j = 0; j < m; j = j + 1){
	tmp = a[i1][j];
	a[i1][j] = a[i2][j];
	a[i2][j] = tmp;
}</code></pre>
            </td>
        </tr>
        <tr>
            <td>8) поменять местами столбцы j1 и j2:<br>
                <p class="table-photo"><img src="./img/2_chapter/table-photo2.21.png" alt="" width="45%" height="35%">
                </p></td>
            <td><pre class="cpp-code"><code class="language-cpp">for (i = 0; i < n; i = i + 1){
	tmp = a[i][j1];
	a[i][j1] = a[i][j2];
	a[i][j2] = tmp;
}</code></pre>
            </td>
        </tr>
        <tr>
            <td>9) вычисление формулы:<br>
                <p class="table-photo"><img src="./img/2_chapter/table-photo2.22.1.png" alt="" width="45%" height="35%">
                </p>
                <p class="table-photo"><img src="./img/2_chapter/table-photo2.22.2.png" alt="" width="45%" height="35%">
                </p>
            </td>
            <td><pre class="cpp-code"><code class="language-cpp">s = 0;
for (i = 0; i < n; i = i + 1){
	for (j = 0; j < m; j = j + 1){
		s = s + f(a[i][j], i, j);
	}
}
cout << "s = " << s << endl;</code></pre>
            </td>
        </tr>
    </table>
    <p>В качестве примера работы с массивами приведена программа, которая записывает в массив «Е» размерностью 10х10
        элементы, создавая единичную матрицу (рисунок 2.3).</p>
    <p class="photo"><img src="./img/2_chapter/2.3.png" alt=""></p>
    <p class="signature">Рисунок 2.3 &#8211; Единичная матрица Е</p>
    <pre class="cpp-code"><code class="language-cpp">#include &ltiostream>
using namespace std;
#define N 10
int main()
{
	setlocale(LC_ALL, "rus");
	short E[N][N]; //задаем массив Е через константу
	for (int i = 0; i < N; ++i)
		for (int j = 0; j < N; ++j) //два цикла, один вложенный в другой,
    //где i и j принимают значения от 0 до 9
			if (i == j) E[i][j] = 1;
    // если i и j будут равны, то есть мы идем по главной диагонали,
	//в этом случаем мы должны записать в массив 1, а иначе будем попадать
    // в другие места, и тогда будем записывать 0
			else E[i][j] = 0;
	for (int i = 0; i < N; ++i){  //вывод на экран этого массива
		for (int j = 0; j < N; ++j)
			cout << E[i][j] << " ";
		cout << endl;
	} return 0;
}</code></pre>
    <p>Результат выполнения данного программного кода представлен на рисунке 2.4.</p>
    <p class="photo"><img src="./img/2_chapter/2.2.png" alt=""></p>
    <p class="signature">Рисунок 2.4 &#8211; Результат программы, заполняющей массив </p>
    <p>Как видно на рисунке 2.4, была получена единичная матрица размерностью 10 на 10 элементов.</p>
    <h3 id="2.6">2.6 Обработка элементов массива</h3>
    <p>В практике программирования существует несколько стандартных алгоритмов обработки элементов массива. Они
        заключаются
        в следующем:</p>
    <ol>
        <li class="without-parentheses">вставка значения в массив по определенному индексу;</li>
        <li class="without-parentheses">удаление значения из массива по определенному индексу;</li>
        <li class="without-parentheses">сортировка элементов массива.</li>
    </ol>
    <p>Далее расписаны подробно каждый из алгоритмов <a href="source.html#metka13">[13]</a>:</p>
    <p>1) Реализация первого алгоритма. Вставка значения в массив по определенному индексу.
        Предположим, что есть массив из девяти элементов.</p>
    <pre class="cpp-code"><code class="language-cpp">short a[9] {1, 2, 3, 5, 6, 7, 8, 9};</code></pre>
    <p>Необходимо перед четвертым элементом (пятеркой) добавить значение четыре. Это означает, что все последующие
        элементы сдвинуться вправо на один элемент. Для такой вставки необходимо выполнить следующую операцию над
        элементами массива (рисунок 2.5).</p>
    <p class="photo"><img src="./img/2_chapter/2.5.png" alt=""></p>
    <p class="signature">Рисунок 2.5 &#8211; Вставка элементов массива</p>
    <p>В исходном массиве необходимо начинать работу с конца. Девятку следует переместить вправо, на место х, затем
        на место девятки помещается восемь и т. д. (в соответствии со стрелками, изображенными на рисунке 2.5). В
        результате в получившемся массиве на месте пятерки мы записываем четверку (а[3] = 4). Сдвиг осуществляется с
        конца не просто так. Если бы сначала начали перемещать элементы, начиная с пятерки, то она заняла бы все
        последующие места (вместо 6 была бы 5 и т. д.).</p>
    <p>Далее представлен код программы, в котором реализован данный пример:</p>
    <pre class="cpp-code"><code class="language-cpp">#include &ltiostream>
using namespace std;
int main(){
	setlocale(LC_ALL, "rus");
	short a[9] = { 1, 2, 3, 5, 6, 7, 8, 9 }; //исходный массив без цифры 4
	for (int i = 8; i > 3; --i) //цикл, i = 8, потому что последний индекс нашего массива 8,
            //i > 3 – то есть последнее значение i будет равно 4, и i на каждом шаге уменьшается на 1
		a[i] = a[i - 1]; //что означает, что при а[8] получим а[7] и т. д.
	a[3] = 4; // в a[3] записываем 4
	for (int i = 0; i < 9; ++i) //вывод этого массива на экран
		cout << a[i] << " ";
	return 0;
}</code></pre>
    <p>Результат выполнения данного программного кода представлен на рисунке 2.6.</p>
    <p class="photo"><img src="./img/2_chapter/2.6.png" alt=""></p>
    <p class="signature">Рисунок 2.6 &#8211; Результат программы, осуществляющей сдвиг значения элемента в
        массиве</p>
    <p>2) Реализация второго алгоритма. Удаление значения из массива по определенному индексу.</p>
    <p>Предположим, что есть массив из девяти элементов:</p>
    <pre class="cpp-code"><code class="language-cpp">short a[9] {1, 2, 3, 4, 5, 6, 7, 8, 9};</code></pre>
    <p>В нем необходимо удалить цифру 6. Для этого следует сдвинуть все элементы влево. В результате получается такой
        массив
        <strong>a[9] {1, 2, 3, 4, 5, 7, 8, 9, 9};</strong>. Причем сначала смещаем семерку на место шестерки, потом
        восьмерку на место семерки и девятку на место восьмерки.</p>
    <p>Программа, реализующая данный алгоритм, представлена далее:</p>
    <pre class="cpp-code"><code class="language-cpp">#include &ltiostream>
using namespace std;
int main(){
	setlocale(LC_ALL, "rus");
	short a[9] = { 1, 2, 3, 4, 5, 6, 7, 8, 9 };
	for (int i = 5; i < 8; ++i)  //устанавливается счетчик, равный пяти,
    //потому что мы начинаем перемещать 7 на место 6 с индексом пять
		a[i] = a[i + 1]; //берем пятый индекс и присваиваем ему следующий, то есть шестой, a[5] = a [6]
	for (int i = 0; i < 9; ++i) // вывод массива на экран
		cout << a[i] << " ";
	return 0;
}</code></pre>
    <p>Результат выполнения данного программного кода представлен на рисунке 2.7.</p>
    <p class="photo"><img src="./img/2_chapter/2.7.png" alt=""></p>
    <p class="signature">Рисунок 2.7 &#8211; Результат программы, удаляющей значение элемента из массива </p>
    <p>3) Реализация третьего алгоритма. Сортировка элементов массива.</p>
    <p>Далее представлен алгоритм сортировки элементов массива по методу всплывающего пузырька. Принцип его работы
        следующий: предположим, нам дан массив, представленный на рисунке 2.8. Нам нужно его отсортировать по
        возрастанию.</p>
    <p class="photo"><img src="./img/2_chapter/2.8.png" alt=""></p>
    <p class="signature">Рисунок 2.8 &#8211; Исходный массив для сортировки</p>
    <p>Для этого мы находим минимальный элемент массива (1), эта единичка ставится на первое место, а тройку ставится на
        место единицы (рисунок 2.9).</p>
    <p class="photo"><img src="./img/2_chapter/2.9.png" alt=""></p>
    <p class="signature">Рисунок 2.9 &#8211; Сортировка массива. Шаг 1</p>
    <p>Далее продолжается обработка этого массива, но уже со второго элемента, применяется все тот же алгоритм. Ищем
        минимальный элемент, в данном случае это 2. И меняем ее не с первым элементом, а со вторым. То есть 5 и 2
        поменяются местами (рисунок 2.10).</p>
    <p class="photo"><img src="./img/2_chapter/2.10.png" alt=""></p>
    <p class="signature">Рисунок 2.10 &#8211; Сортировка массива. Шаг 2</p>
    <p>Далее обработка массива начинается с третьего элемента и так далее, пока массив не будет отсортирован (рисунок
        2.11).</p>
    <p class="photo"><img src="./img/2_chapter/2.11.png" alt=""></p>
    <p class="signature">Рисунок 2.11 &#8211; Сортировка массива. Шаг 3</p>
    <p>Таким образом работает метод всплывающего пузырька.</p>
    <p>Пример программы на языке С++, который реализует метод всплывающего пузырька, представлен ниже.</p>
    <pre class="cpp-code"><code class="language-cpp">#include &ltiostream>
using namespace std;
int main(){
    setlocale(LC_ALL, "rus");
    short a[] = { 3, 5, 1, 6, 2, 4 };
    int N = sizeof(a) / sizeof(short);
    for (int i = 0; i < N - 1; ++i){ //первый цикл отвечает за сдвиг рубежа, который определяет первый элемент массива
        short min = a[i];
        short pos = i;
        for (int j = i + 1; j < N; ++j) //второй цикл ищет минимальные значения среди оставшихся,
    //начиная от этого рубежа, и запоминает минимальное значение и позицию этого элемента
            if (min > a[j]){ //если хотим отсортировать по убыванию,
    //то достаточно здесь поменять знак на противоположный
                pos = j;
                min = a[j];
            }
        short t = a[i]; //в этих трех строчках происходим обмен значениями
        a[i] = a[pos];
        a[pos] = t;
    }
    for (int i = 0; i < N; ++i) // выводим массив на экран
        cout << a[i] << " ";
    return 0;
}</code></pre>
    <p>На рисунке 2.12 отражена работа данного алгоритма:</p>
    <p class="photo"><img src="./img/2_chapter/2.12.png" alt=""></p>
    <p class="signature">Рисунок 2.12 &#8211; Работа алгоритма всплывающего пузырька</p>
    <p>Результат описанного программного кода по сортировке массива по возрастанию и убыванию представлен на рисунках
        2.13 &#8211; 2.14.</p>
    <p class="photo"><img src="./img/2_chapter/2.13.png" alt=""></p>
    <p class="signature">Рисунок 2.13 &#8211; Результат программы с сортировкой массива по возрастанию</p>
    <p class="photo"><img src="./img/2_chapter/2.14.png" alt=""></p>
    <p class="signature">Рисунок 2.14 &#8211; Результат программы с сортировкой массива по убыванию</p>

     <p>На видео 7 представлена лекция по массивам и методу всплывающего пузырька.</p>
    <video controls="controls" poster="./img/video.jpg" src="./video/video_7_l.mp4"></video>
    <p class="signature">Видео 7 &#8211; Массивы, метод всплывающего пузырька</p>

    <h3 id="2.7">2.7 Примеры работы с массивами</h3>
    <p>Для более глубокого понимания представлены примеры работы с массивами.</p>
    <p><strong>Пример 1.</strong> Написать программу вычисления суммы значений элементов одномерного массива длинной N =
        10.
        Значения массива задаются при его инициализации.</p>
    <pre class="cpp-code"><code class="language-cpp">#include &ltiostream>
using namespace std;
#define N 10 // c помощью константы определяем число элементов массива
int main(){
	setlocale(LC_ALL, "rus");
    //задаем этот массив и инициализируем его значениями
	double ar[N] = { 0.5, -1.7, 2.6, 3.5, -22.7, -8.5, -1.1, 3.0, 4.8, 2.3 };
	double S = 0; //задаем вспомогательную переменную, в которой будем хранить сумму
	for (int i = 0; i < N; ++i) // с помощью данного цикла подсчитываем эту сумму
		S += ar[i];
	printf("S = % 1f\n", S); // вывод на экран
	return 0;
}</code></pre>
    <p>Результат выполнения данного программного кода представлен на рисунке 2.15.</p>
    <p class="photo"><img src="./img/2_chapter/2.15.png" alt=""></p>
    <p class="signature">Рисунок 2.15 &#8211; Результат работы программы, вычисляющей сумму значений элементов
        одномерного
        массива</p>
    <p><strong>Пример 2.</strong> Написать программу вычисления среднего арифметического целочисленных значений
        элементов
        одномерного массива
        длиной N = 11. Значения массива вводятся с клавиатуры.</p>
    <pre class="cpp-code"><code class="language-cpp">#include &ltiostream>
using namespace std;
#define N 11 // c помощью константы определяем число элементов массива
int main(){
	setlocale(LC_ALL, "rus");
	int ar[N]; //объявление массива
	double S = 0; //переменная, которая будет хранить среднее арифметическое
	for (int i = 0; i < N; ++i){ //с помощью этого цикла вводим значения в массив
		printf("Введите %d - й элемент: ", i + 1);
		scanf_s(" %d", &ar[i]);
	}
	for (int i = 0; i < N; ++i)//вычисляем его сумму
		S += ar[i];
	S /= N; //так как считаем среднее арифметическое, всю сумму делим на число элементов массива
	printf("S = % 1f\n", S); // вывод на экран
	return 0;
}</code></pre>
    <p>Результат выполнения данного программного кода представлен на рисунке 2.16.</p>
    <p class="photo"><img src="./img/2_chapter/2.16.png" alt=""></p>
    <p class="signature">Рисунок 2.16 &#8211; Результат программы, вычисляющей среднее арифметическое целочисленных
        значений
        элементов одномерного массива</p>
    <h3 id="2.8">2.8 Контрольные вопросы для закрепления изученного материала</h3>
    <ol>
        <li class="with-a-bracket">Что понимают под массивом данных?</li>
        <li class="with-a-bracket">Что называют размерностью массива?</li>
        <li class="with-a-bracket">Какой массив называется одномерным?</li>
        <li class="with-a-bracket">Поясните понятия двумерного массива, матрицы.</li>
        <li class="with-a-bracket">Что обозначают индексы матрицы?</li>
    </ol>
</script>

<script id="page2.9" type="text/html">
    <TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0>
        <TR>
            <TD width="50%"><a name="3"></a>
                <HR>
<div align=justify><h1>Тренировочные упражнения</h1></div>
    <form>
<ol>	
 	<li class="without-parentheses"> Заполните пропуски в программном коде таким образом, чтобы цифра 4 была удалена из массива <b>short a[9] {1, 2, 3, 4, 5, 6, 7, 8, 9};</b> В результате на экране должен появится следующий набор чисел: <b>1 2 3 5 6 7 8 9</b>
        <pre class="cpp-code"><code class="language-cpp">
#include &ltiostream>
using namespace <input type="text" id="glav2_1_1" size=1>;
int main(){
	setlocale(LC_ALL, "rus");
	short a[9] = { 1, 2, 3, 4, 5, 6, 7, 8, 9 };
	for (int i = <input type="text" id="glav2_1_2" size="1">; i < 8; ++i)  
		a[i] = a[i + 1]; 
	for (int i = 0; i <  <input type="text" id="glav2_1_3" size="1">; ++i) // вывод массива на экран
		cout << a[i] << " ";
	return 0;
}
        </code></pre>
 <input type="button" value="Ответить" class="proverit_glav2_1"></input>
              <input type="reset" value ="Очистить"></input>
              <br><br>
                 <div id="resultat"></div>
    </li><br><br>
<li class="without-parentheses"> Какой классификации соответствуют данные целочисленные массивы?
	<pre class="cpp-code"><code class="language-cpp">
1)	int array2D[100][20];                     <input type="text" id="glav2_2_1">
2)	double a[4]={5, -2, 856, 1};		<input type="text" id="glav2_2_2">
	</code></pre>

 <input type="button" value="Ответить" class="proverit_glav2_2"></input>
              <input type="reset" value ="Очистить"></input>
              <br><br>
                 <div id="resultat_1"></div>
</li>

</ol>
    </form>

            </TD>
        </TR>
    </TABLE>
</script>

<script id="page2.10" type="text/html">
    <TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0>
        <TR>
            <TD width="50%"><a name="3"></a>
                <HR>
                <div align=justify><h1>Тестирование по второй главе</h1></div>
                <form name=test>
                    <ol>
                        <li>
                            <h4><input type=text name=T1 style="height: 15px; width:15px;" value=''> Отметьте верный
                                вариант
                                задания массива:</h4>
                            <input type=radio name=Q1> задается одномерный целочисленный массив числами int a;<br>
                            <input type=radio name=Q1> задается одномерный массив по:
                            <pre class="cpp-code"><code class="language-cpp">for (i = 0; i = i + 1){
    a[i] = i + 1;
}</code></pre>
                            <input type=radio name=Q1> задается одномерный целочисленный массив числами double a[4] = {
                            0.5, -2, 856, 1 };<br>
                            <input type=radio name=Q1> задается одномерный массив с клавиатуры
                            <pre class="cpp-code"><code class="language-cpp">for (i = 0; i < 4; i = i + 1){
    cin >> a[i];
}</code></pre>
                            <input type=radio name=Q1> задается одномерный массив с клавиатуры a [4] = {0.5, -2, 856, 1}<br>
                        </li>
                        <li>
                            <h4><input type=text name=T2 style="height: 15px; width:15px;" value=''> Если в списке
                                инициализации массива из элементов простых типов (POD типов) элементов меньше, чем
                                объявленный размер массива, например:
                                <pre class="cpp-code"><code class="language-cpp">int v[5] = {1, 2, 3};</code></pre>
                            </h4>
                            <input type=radio name=Q2> всем остальным элементам присвоится значение 0;<br>
                            <input type=radio name=Q2> произойдет ошибка компиляции;<br>
                            <input type=radio name=Q2> значения остальных элементов зависят от используемого
                            компилятора;<br>
                            <input type=radio name=Q2> остальные элементы не будут инициализированы;<br>
                            <input type=radio name=Q2> нет верного ответа.<br>
                            <br>
                        </li>
                        <li>
                            <h4><input type=text name=T3 style="height: 15px; width:15px;" value=''> Какой код является
                                ошибочным?</h4>
                            <input type=radio name=Q3> float bigMassiv[1];<br>
                            <input type=radio name=Q3> int union[100];<br>
                            <input type=radio name=Q3> longtestType[-1 + 10];<br>
                            <input type=radio name=Q3> double test[0];<br>
                            <input type=radio name=Q3> нет верного ответа.<br>
                            <br>
                        </li>
                        <li>
                            <h4><input type=text name=T4 style="height: 15px; width:15px;" value=''> Сколько
                                размерностей
                                массива можно использовать в программах?</h4>
                            <input type=radio name=Q4> не более трех;<br>
                            <input type=radio name=Q4> можно использовать только многомерные массивы;<br>
                            <input type=radio name=Q4> до десяти, поскольку разработчики C++ посчитали это максимальным
                            допустимым значением;<br>
                            <input type=radio name=Q4> можно использовать только одномерные массивы;<br>
                            <input type=radio name=Q4> не ограничено.<br>
                            <br>
                        </li>
                        <li>
                            <h4><input type=text name=T5 style="height: 15px; width:15px;" value=''> В какой из
                                следующих
                                строк выполняется обращение к седьмому элементу массива, размер массива равен 10?</h4>
                            <input type=radio name=Q5> mas[6];<br>
                            <input type=radio name=Q5> mas[7];<br>
                            <input type=radio name=Q5> mas;<br>
                            <input type=radio name=Q5> mas(7);<br>
                            <input type=radio name=Q5> mas(n=10).<br>
                            <br>
                        </li>
                        <li>
                            <h4><input type=text name=T6 style="height: 15px; width:15px;" value=''> Укажите строку,
                                которая
                                возвращает адрес первого элемента в массиве arr:</h4>
                            <input type=radio name=Q6> &arr;<br>
                            <input type=radio name=Q6> arr[0];<br>
                            <input type=radio name=Q6> arr;<br>
                            <input type=radio name=Q6> arr(return 0);<br>
                            <input type=radio name=Q6> arr[1].<br>
                            <br>
                        </li>
                        <li>
                            <h4><input type=text name=T7 style="height: 15px; width:15px;" value=''> Какой порядковый
                                номер
                                последнего элемента массива, если размер массива 19?</h4>
                            <input type=radio name=Q7> порядковый номер определяется программистом;<br>
                            <input type=radio name=Q7> 19;<br>
                            <input type=radio name=Q7> 0;<br>
                            <input type=radio name=Q7> 18;<br>
                            <input type=radio name=Q7> 10.<br>
                            <br>
                        </li>
                        <li>
                            <h4><input type=text name=T8 style="height: 15px; width:15px;" value=''> Какими бывают
                                массивы?
                            </h4>
                            <input type=radio name=Q8> простые и сложные;<br>
                            <input type=radio name=Q8> однородные и разнородные;<br>
                            <input type=radio name=Q8> одномерные и многомерные;<br>
                            <input type=radio name=Q8> все ответы верны;<br>
                            <input type=radio name=Q8> нет верного ответа.<br>
                            <br>
                        </li>
                        <li>
                            <h4><input type=text name=T9 style="height: 15px; width:15px;" value=''> Что такое массив?
                            </h4>
                            <input type=radio name=Q9> таблица, хранящая различные значения;<br>
                            <input type=radio name=Q9> структура данных, хранящая набор значений одного типа,
                            объединенных
                            под одним единым именем и идентифицируемых по индексу;<br>
                            <input type=radio name=Q9> ячейка в памяти компьютера, где может храниться одно
                            значение;<br>
                            <input type=radio name=Q9> все ответы верны;<br>
                            <input type=radio name=Q9> нет верного ответа.<br>
                            <br>
                        </li>
                        <li>
                            <h4><input type=text name=T10 style="height: 15px; width:15px;" value=''> Что производит
                                следующий фрагмент программы?</h4>
                            <pre class="cpp-code"><code class="language-cpp">for (int i = 0;  i < n; i++)
{
    cout << a[i] << ' ';
}</code></pre>
                            <input type=radio name=Q10> ввод элементов массива с клавиатуры;<br>
                            <input type=radio name=Q10> вывод элементов массива на экран монитора;<br>
                            <input type=radio name=Q10> ввод элементов массива из файла;<br>
                            <input type=radio name=Q10> вывод элементов массива в файла;<br>
                            <input type=radio name=Q10> нет верного ответа.<br>
                            <br>
                        </li>
                    </ol>
                    <div align="center">
                        <div>
                            <input type=button value="Показать результат" onClick="test1('NDEyNTExNDMyMg', 10)">
                        </div>
                        <div>
                            <textarea style="margin-top:6px" rows=5 cols="100%" name=s1></textarea>
                        </div>
                        <div>
                            <input type=reset value="Очистить выбранные пункты">
                        </div>
                        <br>
                        <Div align=center>
                            <a href="#3">В начало страницы</a>
                        </div>
                        <br>
                    </div>
                </form>
            </TD>
        </TR>
    </TABLE>
</script>

<!-- /page3 -->
<script id="page3" type="text/html">
    <h2 id="3">3 Работа со строками в С++</h2>
    <h3 id="3.1">3.1 Инициализация строк</h3>
    <p>Кроме числовой информации, компьютер может обрабатывать символьную информацию. Для представления текстовой
        информации
        в языке С++ используются символы (символьные константы), символьные переменные и строки (строковые константы)
        <a href="source.html#metka13">[14]</a>.</p>
    <p><a href="glossary.html#m10">Символ (символьная константа)</a> &#8211; это буква, цифра или любой другой изображаемый знак, заключенный в
        одинарные
        кавычки (апострофы).</p>
    <p>Например: <strong>'F' 'x' '7' '+' '>' ';'</strong></p>
    <p>Для хранения и обработки символов используют переменные типа char. Значением переменной char может быть любой
        символ.</p>
    <p>Переменные символьного типа должны быть описаны следующим образом:</p>
    <pre class="cpp-code"><code class="language-cpp">char список имен переменных;</code></pre>
    <p>Например:</p>
    <pre class="cpp-code"><code class="language-cpp">char ch;
ch = 'a';
ch = '#';
ch = '"';</code></pre>
    <p>В данном случае была объявлена символьная переменная с именем «ch». Такой символьной переменной можно присвоить
        различные символы в одинарных кавычках (апострофах).</p>
    <p>Изначально в базовом варианте языка С строковых переменных как таковых не было, и строки задавались как массив
        символов. Например, таким образом:</p>
    <pre class="cpp-code"><code class="language-cpp">char str[100];</code></pre>
    <p>В данном случае использовалось объявление строки str, содержащую максимально 100 символов. Подобное использование
        строк остается актуальным и по сей день.</p>
    <p>Переменную символьного типа можно сравнивать с другой переменной типа char. Сравнение основано на том, что
        каждому
        символу поставлено в соответствие число (внутренний код), причем символу '0' соответствует число меньшее, чем
        символу '9', символу 'A' &#8211; меньшее, чем 'B', символу 'Z' &#8211; меньшее, чем 'a'. Таким образом, можно
        записать:</p>
    <pre class="cpp-code"><code class="language-cpp">'0'<'1'<...<'9'<...<'A'<...<'B'<...<'Z'<'a'<'b'<...'z'</code></pre>
    <p><a href="glossary.html#m11">Строка (строковая константа)</a> &#8211; это последовательность символов, заключенная в двойные кавычки.
        Например:</p>
    <pre class="cpp-code"><code class="language-cpp">"1234567890"
"\t Строковая константа"
" Начало строки \n и конец строки"</code></pre>
    <p>В программе любая строка объявляется как массив символов:</p>
    <pre class="cpp-code"><code class="language-cpp">char mm[]="массив символов";</code></pre>
    <p>Строка представляет собой массив символов, заканчивающийся нуль-символом. При объявлении в программе строковой
        константы транслятор С++ автоматически добавляет в конец строки NULL символ (\0), поэтому длина строковой
        константы
        на 1 больше, чем количество символов в ней.</p>
    <p>Когда работа идет с массивом из таких переменных, то можно образовывать целые строки:</p>
    <pre class="cpp-code"><code class="language-cpp">char str_1[100] = { 'П','р','и','в','е','т','\0' };</code></pre>
    <p>Последний символ \0 &#8211; это символ конца строки. Т. е. когда на экран выводится строка str_1, то оператору
        cout
        известно, где заканчивается эта строка и сколько из этих 100 символов нужно вывести <a href="source.html#metka15">[15]</a>.</p>
    <p>Когда объявлялась строка str_1, то все символы в этой строке были заданы в одинарных кавычках &#8211; это не
        очень
        удобно,
        поэтому создатели языка С++ предусмотрели следующие варианты объявления строк:</p>
    <pre class="cpp-code"><code class="language-cpp">char str_2[100] = "Привет";
char str_3[] = "Привет";</code></pre>
    <p>Следует обратить внимание на то, что в данном примере символ конца строки дописывается автоматически после буквы
        «т».</p>
    <p>Рассмотрим еще один пример. Предположим, задается строка a:</p>
    <pre class="cpp-code"><code class="language-cpp">char a[100];</code></pre>
    <p>Затем этой строке следует присвоить слово «Привет».</p>
    <pre class="cpp-code"><code class="language-cpp">a = "Привет";</code></pre>
    <p>Так делать нельзя, присваивать строки можно только в момент объявления массива символов. Следующим образом:</p>
    <pre class="cpp-code"><code class="language-cpp">char str_1[100] = { 'П','р','и','в','е','т','\0' };
char str_2[100] = "Привет";
char str_3[] = "Привет"; //правильная инициализация строк</code></pre>
    <h3 id="3.2">3.2 Функции работы со строками</h3>
    <p>В языке С++ появилась возможность работы с целыми строками, используя библиотеку string.h. Имеется несколько
        распространённых функций работы со строками, которые представлены в таблице 3.1.</p>
    <p>Таблица 3.1 &#8211; Функции работы со строками</p>
    <p class="tables"><img src="./img/3_chapter/table3.1.png" alt=""></p>
    <p>Как видно в таблице 3.1, для того чтобы использовать функции работы со строками, необходимо подключить string.h
        &#8211;
        заголовочный файл стандартной библиотеки языка С.</p>
    <p>Далее представлены примеры работ с описанными функциями. Первым рассмотрен пример работы функции strlen(), с
        помощью
        которой можно вычислить длину строки в символах.</p>
    <pre class="cpp-code"><code class="language-cpp">#include &ltiostream>
#include &ltstring.h>
using namespace std;
int main(){
    setlocale(LC_ALL, "rus");
    char a[100]; //объявление строки а
    strcpy_s(a, "Привет"); //копирование в строку «а» слова «Привет»
    strcat_s(a, " мир!"); //добавление к строке «а» слова «мир»
    int N = strlen(a); // вычисление длины строки «а» с помощью функции
                       // strlen()
    cout << N << endl; //вывод на экран строки а
    return 0;
}</code></pre>
    <p>В результате работы данной функции на экране должно появиться число 11. Результат выполнения данного программного
        кода представлен на рисунке 3.1.</p>
    <p class="photo"><img src="./img/3_chapter/3.1.png" alt=""></p>
    <p class="signature">Рисунок 3.1 &#8211; Результат работы функции strlen()</p>
    <p>Для присваивания одной строке значения другой в С++ используется функция strcpy(). В компиляторе MS Visual Studio
        она
        записывается strcpy_s() и позволяет копировать одну строку в другую. Далее представлен код, реализующий работу
        данной функции:</p>
    <pre class="cpp-code"><code class="language-cpp">#include &ltiostream>
#include &ltstring.h>
using namespace std;
int main(){
    setlocale(LC_ALL, "rus");
    char a[100];                    //объявление строки «а»
    strcpy_s(a, "Привет"); //копирование в строку «а» слова «Привет»
    cout << a << endl;        //вывод на экран строки «а»
    return 0;
}</code></pre>
    <p>Результат выполнения данного программного кода представлен на рисунке 3.2.</p>
    <p class="photo"><img src="./img/3_chapter/3.2.png" alt=""></p>
    <p class="signature">Рисунок 3.2 &#8211; Результат работы функции strcpy_s()</p>
    <p>Далее приведен пример работы функции strcat(), с помощью которой можно добавить одну строку к другой:</p>
    <pre class="cpp-code"><code class="language-cpp">#include &ltiostream>
#include &ltstring.h>
using namespace std;
int main(){
    setlocale(LC_ALL, "rus");
    char a[100];//объявление строки а
    strcpy_s(a, "Привет,"); //копирование в строку «а» слова «Привет»
    strcat_s(a, " мир!");      //добавление к строке «а» слова «мир!»
    cout << a << endl;   //вывод на экран строки «а»
    return 0;
}</code></pre>
    <p>Результат выполнения данного программного кода представлен на рисунке 3.3.</p>
    <p class="photo"><img src="./img/3_chapter/3.3.png" alt=""></p>
    <p class="signature">Рисунок 3.3 &#8211; Результат добавления в строку «а» слова «мир!»</p>
    <p>Далее рассмотрена функция strcpm(), с помощью которой можно сравнивать две строки. Заданы две строки «a» и «b»,
        длина которых 100 и 20 символов соответственно.</p>
    <pre class="cpp-code"><code class="language-cpp">#include &ltiostream>
#include &ltstring.h>
using namespace std;
int main(){
    setlocale(LC_ALL, "rus");
    char a[100]; // объявление строки а
    char b[20]; // объявление строки b
    cin >> b;
    strcpy_s(a, "Hello");
    int cmp = strcmp(a, b);
    if (cmp == 0)
        cout << "Строки равны\n";
    else
        cout << "Строки не равны\n";
    return 0;
}</code></pre>
    <p>Если ввести с клавиатуры слово, не равное строке «а», то на экран выведется «Строки не равны». Результат
        выполнения
        данного программного кода представлен на рисунках 3.4 и 3.5.</p>
    <p class="photo"><img src="./img/3_chapter/3.4.png" alt=""></p>
    <p class="signature">Рисунок 3.4 &#8211; Введение с клавиатуры символов «hhh»</p>
    <p class="photo"><img src="./img/3_chapter/3.5.png" alt=""></p>
    <p class="signature">Рисунок 3.5 &#8211; Результат сравнения двух строк</p>
    <p>Если же ввести с клавиатуры слово, равное строке «а», то на экран выведется «Строки равны». Введем «Hello».
        Результат
        выполнения данного программного кода представлен на рисунке 3.6.</p>
    <p class="photo"><img src="./img/3_chapter/3.6.png" alt=""></p>
    <p class="signature">Рисунок 3.6 &#8211; Результат сравнения двух строк</p>
    <p>Следует обратить внимание на данные две строчки:</p>
    <pre class="cpp-code"><code class="language-cpp">int cmp = strcmp(a, b);
if (cmp == 0)</code></pre>
    <p>Можно объединить и сделать короче таким образом:</p>
    <pre class="cpp-code"><code class="language-cpp">if (strcmp (a, b) == 0)</code></pre>
    <p>Результат работы такой программы будет аналогичным предыдущей.</p>
    <p>Если сравнивать строку не «Hello», а «Hello, World», то программа будет работать неверно. Соответственно с
        клавиатуры
        вводится строка «Hello, World».</p>
    <pre class="cpp-code"><code class="language-cpp">#include &ltiostream>
#include &ltstring.h>
using namespace std;
int main(){
    setlocale(LC_ALL, "rus");
    char a[100];//объявление строки а
    char b[20]; // объявление строки b
    cin >> b;
    strcpy_s(a, "Hello, World");
    if (strcmp(a, b) == 0)
        cout << "Строки равны\n";
    else
        cout << "Строки не равны\n";
    return 0;
}</code></pre>
    <p>Результат выполнения данного программного кода представлен на рисунках 3.7 и 3.8.</p>
    <p class="photo"><img src="./img/3_chapter/3.7.png" alt=""></p>
    <p class="signature">Рисунок 3.7 &#8211; Ввод строки «Hello, World»</p>
    <p class="photo"><img src="./img/3_chapter/3.8.png" alt=""></p>
    <p class="signature">Рисунок 3.8 &#8211; Результат сравнения двух строк</p>
    <p>Проблема в том, что когда оператор cin вводит в строку «b» слова «Hello, World», то пробел между этими словами
        для
        оператора cin означает окончание ввода этого слова. Т. е. в переменной «b» будет записано первое слово до
        пробела
        (т. е. «Hello,»), а второе слово «World» будет отсутствовать. Эту проблему можно решить с помощью функции
        gets(),
        которая позволяет вводить слова вместе с пробелами.</p>
    <p>Далее представлен этот же пример, но с использованием функции gets_s:</p>
    <pre class="cpp-code"><code class="language-cpp">#include &ltiostream>
#include &ltstring.h>
using namespace std;
int main(){
    setlocale(LC_ALL, "rus");
    char a[100];//объявление строки а
    char b[20];
    gets_s(b);
    strcpy_s(a, "Hello, World");
    if (strcmp(a, b) == 0)
        cout << "Строки равны\n";
    else
        cout << "Строки не равны\n";
    return 0;
}</code></pre>
    <p>Результат выполнения данного программного кода представлен на рисунке 3.9.</p>
    <p class="photo"><img src="./img/3_chapter/3.9.png" alt=""></p>
    <p class="signature">Рисунок 3.9 &#8211; Результат сравнения двух строк</p>
    <p>Т. е. если нужно ввести несколько слов или целое предложение через пробелы, то нужно использовать функцию gets(),
        а
        если нужно ввести одно слово, то можно использовать оператор cin <a href="source.html#metka1">[1]</a>.</p>
    <p>Далее рассмотрена работа функции puts(), с помощью которой можно производить вывод строки на экран с переходом на
        следующую строку:</p>
    <pre class="cpp-code"><code class="language-cpp">#include &ltiostream>
#include &ltstring.h>
using namespace std;
int main(){
	setlocale(LC_ALL, "rus");
	char a[100] = "Привет";
	char b[20] = "мир!";
	puts(a);
	puts(b);
	return 0;
}</code></pre>
    <p>Результат выполнения данного программного кода представлен на рисунке 3.10.</p>
    <p class="photo"><img src="./img/3_chapter/3.10.png" alt=""></p>
    <p class="signature">Рисунок 3.10 &#8211; Вывод строк на экран с помощью функции puts()</p>
    <p>Далее представлен пример работы функции sprintf(), которая позволяет формировать строку по определенному шаблону
        и
        записывать разные данные в одну строку.</p>
    <pre class="cpp-code"><code class="language-cpp">#include &ltiostream>
#include &ltstring.h>
using namespace std;
int main(){
    setlocale(LC_ALL, "rus");
    int age = 20;
    double weight = 70.5;
    char name[100] = "Иван";
    char str[200];
    sprintf_s(str, "Здравствуйте, %s! Ваш возраст %d лет, вес %f кг", name, age, weight);
    cout << str << endl;
    return 0;
}</code></pre>
    <p>В данном примере с помощью функции sprintf() такие данные, как возраст, вес и имя, записываются в одну строку
        str. В
        круглых скобках после функции sprintf() сначала записывается имя строки, в которую записывают данные, после
        запятой
        записываются сами данные. Следует обратить внимание на %s, %d, %f &#8211; это спецификаторы, которым будут
        переданы
        значения переменных name, age и weight соответственно.</p>
    <p>Результат выполнения данного программного кода представлен на рисунке 3.11.</p>
    <p class="photo"><img src="./img/3_chapter/3.11.png" alt=""></p>
    <p class="signature">Рисунок 3.11 &#8211; Результат записи данных в одну строку</p>
    <p>Также следует обратить внимание, что когда на экран выводится возраст, то выводится 70,50000. Если нужно вывести
        с
        точностью до сотых, то спецификатор %f следует переписать как %.2f.</p>
    <pre class="cpp-code"><code class="language-cpp">#include &ltiostream>
using namespace std;
int main(){
    setlocale(LC_ALL, "rus");
    int age = 20;
    double weight = 70.5;
    char name[100] = "Иван";
    char str[200];
    sprintf_s(str, "Здравствуйте, %s! Ваш возраст %d лет, вес %.2f кг", name,
        age, weight);
    cout << str << endl;
    return 0;
}</code></pre>
    <p>На рисунке 3.12 приведен пример работы программы.</p>
    <p class="photo"><img src="./img/3_chapter/3.12.png" alt=""></p>
    <p class="signature">Рисунок 3.12 &#8211; Результат работы программы</p>
    <p>Следует обратить внимание, что у функции sprintf() имеется несколько основных видов спецификаторов (таблица
        3.2).</p>
    <p>Таблица 3.2 &#8211; Спецификаторы функции sprintf()</p>
    <p class="tables"><img src="./img/3_chapter/table3.2.png" alt=""></p>
    <p>Далее рассмотрена работа функций atoi() и atof(), которые позволяют преобразовывать числа, представленные в виде
        строк, в обычные числа.</p>
    <pre class="cpp-code"><code class="language-cpp">#include &ltiostream>
#include &ltstring.h>
using namespace std;
int main(){
    setlocale(LC_ALL, "rus");
    char str_i[] = "120";
    char str_f[] = "120,50";
    int i = atoi(str_i);
    float f = atof(str_f);
    cout << i << " " << f << endl;
    return 0;
}</code></pre>
    <p>Если нужно строку str_i преобразовать в число, т. е. получить число 120, а не строку 120, нужно использовать
        функцию
        atoi(). Функция atof() делает то же самое, но только с вещественными числами. В данной программе переменная i
        будет
        содержать результат работы функции atoi(), а переменная f &#8211; результат работы функции atof(). На рисунке
        3.13
        приведен пример работы программы.</p>
    <p class="photo"><img src="./img/3_chapter/3.13.png" alt=""></p>
    <p class="signature">Рисунок 3.13 &#8211; Результат работы функций atoi() и atof()</p>
    <p>Следует обратить внимание, что у вещественного числа 120,50 дробная часть отделяется запятой &#8211; это
        особенность
        настройки операционной системы Windows и работы Visual Studio, в других средах разработки или при других
        настройках
        дробная часть может отделяться точкой.</p>
    <h3 id="3.3">3.3 Примеры работы со строками</h3>
    <p>Для более глубоко понимания принципа работы с функциями обработки строк далее представлены конкретные примеры
        работы
        со строками.</p>
    <p><strong>Пример 1.</strong> Пользователь вводит с клавиатуры строку. Необходимо все буквы латинского алфавита (от
        a до
        z) перевести в
        верхний регистр (сделать заглавными).</p>
    <p>Реализация данного примера представлена ниже:</p>
    <pre class="cpp-code"><code class="language-cpp">#include &ltiostream>
#include &ltstring.h>
using namespace std;
int main(){
    setlocale(LC_ALL, "rus");
    char str[100];
    gets_s(str, sizeof(str));
    char off_eng = 'A' - 'a';
    int N = strlen(str);
    for (int i = 0; i < N; i++)
        if (str[i] >= 'a' && str[i] <= 'z')
            str[i] += off_eng;
    puts(str);
    return 0;
}</code></pre>
    <p>На рисунке 3.14 приведен результат работы данного кода.</p>
    <p class="photo"><img src="./img/3_chapter/3.14.png" alt=""></p>
    <p class="signature">Рисунок 3.14 &#8211; Результат работы программы</p>
    <p>В данном примере сначала происходит объявление строки str, затем пользователь вводит что-то в эту строчку с
        помощью
        функции gets(). Дальше объявляется смещение. Дело в том, что символы латинского алфавита в кодовой таблице идут
        по
        порядку, поэтому для того, чтобы перевести малые буквы латинского алфавита в заглавные, можно к малым буквам
        добавить смещение, и они автоматически станут заглавными. Для того чтобы понять, что работа идет с малыми
        буквами
        латинского алфавита, реализована проверка через условие if, т. е. символ «а» имеет наименьшее значение кода в
        кодовой таблице, а символ «z» наибольшее значение. Далее идет превращение малых букв в заглавные и вывод строки
        на
        экран.</p>
    <p><strong>Пример 2.</strong> Пользователь вводит строку с клавиатуры. Необходимо определить: если это строка «Hello
        World!» (неважно, в
        каком регистре), то вывести на экран сообщение «Строка hello world», иначе сообщение «Другая строка».</p>
    <p>Далее представлена реализация данной программы:</p>
    <pre class="cpp-code"><code class="language-cpp">#include &ltiostream>
#include &ltstring.h>
using namespace std;
int main(){
    setlocale(LC_ALL, "rus");
    char str[100];
    printf("Введите строку: ");
    gets_s(str, sizeof(str));
    if (_stricmp(str, "hello world") == 0)
        puts("Строка hello world");
    return 0;
}</code></pre>
    <p>Результат выполнения данного программного кода представлен на рисунке 3.15.</p>
    <p class="photo"><img src="./img/3_chapter/3.15.png" alt=""></p>
    <p class="signature">Рисунок 3.15 &#8211; Результат работы программы</p>
    <p>В данном примере сначала происходит объявление строки «str», затем пользователь вводит что-то в эту строчку с
        помощью
        функции gets(). Далее происходит сравнение с помощью условия if и функции _stricmp(). Причем буква i посередине
        этой
        функции означает, что проверка будет происходить без учета регистра. Далее происходит вывод строки на экран.</p>
    <p><strong>Пример 3.</strong> Пользователь вводит с клавиатуры предложение, в котором слова разделяются одним или
        несколькими пробелами.
        Нужно выделить все слова из предложения и вывести их в столбик в консоль.</p>
    <p>Реализация данного примера представлена ниже:</p>
    <pre class="cpp-code"><code class="language-cpp">#include &ltiostream>
#include &ltstring.h>
using namespace std;
int main(){
    setlocale(LC_ALL, "rus");
    char str[100], word[100];
    printf("Введите строку: ");
    gets_s(str);
    const int N = strlen(str);
    for (int i = 0; i < N; i++){
        if (str[i] != ' '){
            int j = i, k = 0;
            for (; j < N && str[j] != ' '; j++, k++)
                word[k] = str[j];
            word[k] = '\0';
            i = j;
            puts(word);
        }
    }
    return 0;
}</code></pre>
    <p>На рисунке 3.16 приведен пример работы данного кода.</p>
    <p class="photo"><img src="./img/3_chapter/3.16.png" alt=""></p>
    <p class="signature">Рисунок 3.16 &#8211; Ввод строки и результат работы программы</p>
    <p>В данном примере сначала происходит объявление строки str, в которую будут что-то вводить, и word
        (вспомогательный
        массив). Далее реализован цикл for, который проходит все символы строки str, и происходит выполнение условия,
        если
        текущий символ не равен символу пробела, то начинает выполняться цикл for до тех пор, пока он не дойдет до
        символа
        пробела, j и k в данном случае &#8211; вспомогательные переменные, j будет индексом символов строки str, а k
        &#8211; это <a href="glossary.html#m6">индекс</a> 
        для вспомогательного массива word. Далее происходит заполнение массива word[k] соответствующими символами строки
        str[j], т. е. выделяем слово. И после того, как выделяются все символы текущего слова, последним символом
        word[k]
        прописывается символ конца строки \0. Далее индексу i присваивается значение индекса j, чтобы продолжать
        движение по
        строке. В конце происходит вывод слова на экран.</p>
        <p>На видео 8 представлена подробная лекция по строкам и функциям работы с ними.</p>
    <video controls="controls" poster="./img/video.jpg" src="./video/video_8_l.mp4"></video>
    <p class="signature">Видео 8 &#8211; Строки и функции работы со строками</p>
    <h3 id="3.4">3.4 Контрольные вопросы для закрепления изученного материала</h3>


    <ol>
        <li class="with-a-bracket">Как правильно задать строку в С++?</li>
        <li class="with-a-bracket">Какая функция используется для сравнения строк?</li>
        <li class="with-a-bracket">Какая функция используется для вычисления длины строки?</li>
        <li class="with-a-bracket">Какая функция используется для преобразования строки в целое число?</li>
        <li class="with-a-bracket">Какая функция используется для преобразования строки в вещественное число?</li>
    </ol>
</script>

<script id="page3.5" type="text/html">
    <TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0>
        <TR>
            <TD width="50%"><a name="3"></a>
                <HR>
                <div align=justify><h1>Тренировочные упражнения</h1></div>
  <form>
   <ol> 
   	<li class="without-parentheses">Дополните код недостающими строковыми функциями вместо пропусков, чтобы комментарии соответствовали им. Не забудьте указать библиотеку для работы со строками.
   	 <pre class="cpp-code"><code class="language-cpp">
#include &ltiostream>
#include <<input type="text" id="glav3_1_1" size="5">>
using namespace std;
int main(){
    setlocale(LC_ALL, "rus");
    char a[100]; //объявление строки а
    <input type="text" id="glav3_1_2" size="5">(a, "Hello"); //копирование в строку «а» слова «Привет»
    <input type="text" id="glav3_1_3" size="5">(a, " World!"); //добавление к строке «а» слова «мир»
    int N = <input type="text" id="glav3_1_4" size="5">(a); // вычисление длины строки «а» 
    cout << N << endl; //вывод на экран строки а
    return 0;
}  
</code></pre>  
 <input type="button" value="Ответить" class="proverit_glav_3_1"></input>
              <input type="reset" value ="Очистить"></input>
              <br><br>
                 <div id="resultat_3_1"></div>
                  </form>
              </li><br><br>
<table class="table_center">
	
    <li class="without-parentheses"> С помощью какой функции в языке С++ можно выводить строки на экран с переходом на следующую строку?</li>
    <tr>
        <td>
            <ul class="static_ul static_glava3">
                <li>strlen()</li>
                <li>strcpy()</li>
                <li>strcat()</li>
                <li>strcmp()</li>
            </ul>
        </td>
        <td>
            <ul class="droppable_ul1 droppable_ul drop_glava3" id="parent1">
            </ul>
            <ul class="droppable_ul2 droppable_ul drop_glava3" id="parent2">
            </ul>
            <ul class="droppable_ul3 droppable_ul drop_glava3" id="parent3">
            </ul>
            <ul class="droppable_ul4 droppable_ul drop_glava3" id="parent4">
            </ul>
        </td>
        <td>
            <ul class="draggable_ul drag_glava3">
                <li class="ufo draggable_li" id="ufo1" draggable="true">Вычисление длины строки</li>
                <li class="ufo2 draggable_li" id="ufo2" draggable="true">Копирование одной строки в другую</li>
                <li class="ufo3 draggable_li" id="ufo3" draggable="true">Добавление одной строки к другой</li>
                <li class="ufo4 draggable_li" id="ufo4" draggable="true">Сравнение двух строк</li>
            </ul>
        </td>
    </tr>
</table>
 <input type="button" value="Ответить" onclick="provet()"></input>
 <input type="button" value ="Сбросить" onclick="provet_del()"></input>
   <br><br>
    <div id="resultat_2"></div>
</ol>
</script> 


<script id="page3.6" type="text/html">
    <table BORDER=0 CELLPADDING=0 CELLSPACING=0>
        <tr>
            <td width="50%"><a name="3"></a>
                <hr>
                <div align=justify><h1 align="center">Тестирование по третьей главе</h1></div>
                <form name=test>
                    <ol>
                        <li>
                            <h4><input type=text name=T1 style="height: 15px; width:15px;" value=''> Какая функция
                                сравнивает две строки?</h4>
                            <input type=radio name=Q1> strcat();<br>
                            <input type=radio name=Q1> strcpy();<br>
                            <input type=radio name=Q1> atof();<br>
                            <input type=radio name=Q1> sprint();<br>
                            <input type=radio name=Q1> strcmp().<br>
                            <br>
                        </li>
                        <li>
                            <h4><input type=text name=T2 style="height: 15px; width:15px;" value=''> Словосочетание
                                «Hello world!» может быть сохранено
                                в символьном массиве размером n элементов. Укажите, чему равно n?</h4>
                            <input type=radio name=Q2> 12;<br>
                            <input type=radio name=Q2> 10;<br>
                            <input type=radio name=Q2> 13;<br>
                            <input type=radio name=Q2> 11;<br>
                            <input type=radio name=Q2> 9.<br>
                            <br>
                        </li>
                        <li>
                            <h4><input type=text name=T3 style="height: 15px; width:15px;" value=''> Строковый тип
                                данных в
                                C++:</h4>
                            <input type=radio name=Q3> строки в C++ представляются как массивы элементов типа char,
                            заканчивающиеся терминатором строки &mdash; символом с нулевым значением '0';<br>
                            <input type=radio name=Q3> строки в C++ представляются как массивы элементов типа char,
                            заканчивающиеся терминатором строки &mdash; символом с нулевым значением (‘/0’);<br>
                            <input type=radio name=Q3> строки в C++ представляются как массивы элементов типа char,
                            заканчивающиеся терминатором строки &mdash; символом с нулевым значением (‘’);<br>
                            <input type=radio name=Q3> нет верного ответа;<br>
                            <input type=radio name=Q3> все ответы верны.<br>
                            <br>
                        </li>
                        <li>
                            <h4><input type=text name=T4 style="height: 15px; width:15px;" value=''> Укажите корректное
                                определение строковой
                                переменной:</h4>
                            <input type=radio name=Q4> char mystr[20];<br>
                            <input type=radio name=Q4> string mystr;<br>
                            <input type=radio name=Q4> string[20] mystr;<br>
                            <input type=radio name=Q4> string mystr[20];<br>
                            <input type=radio name=Q4> нет верного ответа.<br>
                            <br>
                        </li>
                        <li>
                            <h4><input type=text name=T5 style="height: 15px; width:15px;" value=''> Допустим, есть код:
                            </h4>
                            <pre class="cpp-code"><code class="language-cpp">char arr[8];
cin >> arr;</code></pre>
                            <h4><p>И в массив arr мы попытались записать следующий набор символов: «Hello World». Что в
                                действительности будет содержать массив arr?</p></h4>
                            <input type=radio name=Q5> Hello World;<br>
                            <input type=radio name=Q5> Другой ответ;<br>
                            <input type=radio name=Q5> Hello Wo;<br>
                            <input type=radio name=Q5> Hello W;<br>
                            <input type=radio name=Q5> Hello.<br>
                            <br>
                        </li>
                        <li>
                            <h4><input type=text name=T6 style="height: 15px; width:15px;" value=''> Какая из следующих
                                записей возвращает значение переменной a, хранящееся в памяти по адресу, на который
                                указывает указатель?</h4>
                            <input type=radio name=Q6> &a;<br>
                            <input type=radio name=Q6> a;<br>
                            <input type=radio name=Q6> *a;<br>
                            <input type=radio name=Q6> val(a);<br>
                            <input type=radio name=Q6> нет правильного ответа.<br>
                            <br>
                        </li>
                        <li>
                            <h4><input type=text name=T7 style="height: 15px; width:15px;" value=''> Какая функция
                                преобразовывает строку в вещественное число?</h4>
                            <input type=radio name=Q7> strcat();<br>
                            <input type=radio name=Q7> strcpy();<br>
                            <input type=radio name=Q7> atoi();<br>
                            <input type=radio name=Q7> sprint();<br>
                            <input type=radio name=Q7> strcmp().<br>
                            <br>
                        </li>
                        <li>
                            <h4><input type=text name=T8 style="height: 15px; width:15px;" value=''> Какая функция
                                добавляет
                                одну строку к другой?</h4>
                            <input type=radio name=Q8> strcat();<br>
                            <input type=radio name=Q8> strcpy();<br>
                            <input type=radio name=Q8> atof();<br>
                            <input type=radio name=Q8> sprint();<br>
                            <input type=radio name=Q8> strcmp().<br>
                            <br>
                        </li>
                        <li>
                            <h4><input type=text name=T9 style="height: 15px; width:15px;" value=''> Какую библиотеку
                                необходимо подключить в код для работы со строками?</h4>
                            <input type=radio name=Q9> &ltchar&gt;<br>
                            <input type=radio name=Q9> &ltstring&gt;<br>
                            <input type=radio name=Q9> &ltrandom&gt;<br>
                            <input type=radio name=Q9> &ltwords&gt;<br>
                            <input type=radio name=Q9> &ltsentence&gt.<br>
                            <br>
                        </li>
                        <li>
                            <h4><input type=text name=T10 style="height: 15px; width:15px;" value=''> Какая из следующих
                                функций считывает 100 символов из входного потока в строку x?</h4>
                            <input type=radio name=Q10> cin.getline(100, x, '\n');<br>
                            <input type=radio name=Q10> read(x);<br>
                            <input type=radio name=Q10> readline(x, 100, 'n');<br>
                            <input type=radio name=Q10> write(x);<br>
                            <input type=radio name=Q10> cin.getline(x, 100, '\n').<br>
                            <br>
                        </li>
                    </ol>
                    <div align="center">
                        <div>
                            <input type=button value="Показать результат" onClick="test1('NTMyMTExMzQyNQ', 10)">
                        </div>
                        <div>
                            <textarea style="margin-top:6px" rows=5 cols="100%" name=s1></textarea>
                        </div>
                        <div>
                            <input type=reset value="Очистить выбранные пункты">
                        </div>
                        <br>
                        <Div align=center>
                            <a href="#3">В начало страницы</a>
                        </div>
                        <br>
                    </div>
                </form>
            </td>
        </tr>
    </table>
</script>

<!-- /page4 -->
<script id="page4" type="text/html">
    <h2 id="4">4 Использование указателей в языке С++</h2>
    <h3 id="4.1">4.1 Инициализация указателей </h3>
    <p><a href="glossary.html#m11">Указатель</a> &#8211; переменная, значением которой является адрес ячейки памяти. То есть указатель ссылается на блок
        данных из
        области памяти, причём на самое его начало.</p>
    <p>Для понимания работы указателей неоходимо разобраться, как хранятся в памяти компьютера различные переменные.
        Когда
        создается целочисленная переменная а (int a;), то где-то в памяти компьютера выделяется 4 байта для её хранения,
        условно это можно изобразить таким образом: память разбита на байты и 4 байта, и с 1000 ячейки отводится для
        хранения значения переменной а.</p>
    <p class="photo"><img src="./img/4_chapter/4.1.png" alt=""></p>
    <p class="signature">Рисунок 4.1 &#8211; Хранение данных в памяти компьютера</p>
    <p>Если, например, переменная а = 0, то в этих четырех ячейках будут записаны нули, если а = 1, то в операционной
        системе
        Windows в первой ячейке будет записана 1, остальные будут нули. А если, например, 256, то во второй ячейке будет
        записана 1, все остальные ячейки будут равны нулю. То есть при изменении содержимого этих ячеек переменная «а»
        также
        будет менять свое значение.</p>
    <p class="photo"><img src="./img/4_chapter/4.2.png" alt=""></p>
    <p class="signature">Рисунок 4.2 &#8211; Выделение памяти под данные</p>
    <p>Тогда можно обратиться напрямую к памяти, поменять значение этих ячеек. Это отразится на значении переменной «а»,
        именно такую операцию можно сделать с помощью указателей. Но для начала этот указатель нужно объявить. Сначала
        указывается тип указателя, потом ставится знак «*» и затем прописывается имя указателя.</p>
    <p>Синтаксис:</p>
    <pre class="cpp-code"><code class="language-cpp">тип *имя указателя;</code></pre>
    <p>В данном примере это запишется следующим образом:</p>
    <pre class="cpp-code"><code class="language-cpp">int *ptr;</code></pre>
    <p>где имя ptr &#8211; имя указателя, int &#8211; тип указателя, с которым этот указатель будет работать.</p>
    <p>Теперь, когда указатель задан, нужно, чтобы он работал, начиная с 1000-й ячейки памяти. И это записывается
        следующим
        образом: присваивается указателю ptr значение 1000.</p>
    <pre class="cpp-code"><code class="language-cpp">ptr = 1000;</code></pre>
    <p>Число 1000 называется адресом переменной «а». То есть 1000 &#8211; это номер ячейки, начиная с которой переменная
        «а»
        хранит свое значение.</p>
    <p>Предположим, что необходимо с помощью указателя ptr поменять значение «а» на 2, это делается так: пишется *,
        далее
        имя указателя ptr и далее присваивается значение 2.</p>
    <pre class="cpp-code"><code class="language-cpp">*ptr = 2;</code></pre>
    <p>В данном случае представлено две записи указателей. Нужно понимать разницу: если имя указателя ptr записывается
        без
        знака «*», то это означает, что ему присваивается адрес, а если со звёздочкой, то это означает, что по этому
        адресу
        записывается значение 2.</p>
    <p>Далее получается следующая картина: в 1000-ю ячейку записывается значение 2, а остальные ячейки будут равны 0, и
        в
        итоге переменная «а» будет принимать значение 2. Следует обратить внимание, что запись здесь будет сделана сразу
        в
        четыре
        ячейки, так как тип указателя int, а значит, он работает сразу с четырьмя байтами.</p>
    <p class="photo"><img src="./img/4_chapter/4.3.png" alt=""></p>
    <p class="signature">Рисунок 4.3 &#8211; Присваивание значения переменной</p>
    <p>Так с помощью указателя можно поменять значение переменной а. Для того чтобы узнать, по какому адресу расположена
        та
        или иная переменная, необходимо использовать оператор & (амперсант), который записывается перед именем
        переменной.</p>
    <pre class="cpp-code"><code class="language-cpp">ptr = &#38;a;</code></pre>
    <p>Знак «&» возвращает адрес, по которому расположена эта переменная «а», и этот адрес присваивается указателю ptr.
        Вот
        так следует интерпретировать эту строчку.</p>
    <p>Далее представлен код, реализующий работу с указателями:</p>
    <pre class="cpp-code"><code class="language-cpp">#include &ltiostream>
using namespace std;
int main(){
	setlocale(LC_ALL, "Russian");
	int a = 0; // инициируется переменная «a»
	cout << a << endl; //вывод значения переменной на экран
	int* p;
	p = &#38;a;
	*p = 2; // меняется значение переменной «a» на 2
	cout << a << endl; //вывод значения переменной на экран
	return 0;
}</code></pre>
    <p>В программе инициализируется переменная «а» со значением 0, далее значение переменной «а» выводится на экран,
        затем с
        помощью указателя «p» меняется значение переменной «a» на 2, снова на экран выводится переменная «а». Результат
        работы данной программы представлен на рисунке 4.4.</p>
    <p class="photo"><img src="./img/4_chapter/4.4.png" alt=""></p>
    <p class="signature">Рисунок 4.4 &#8211; Пример работы с указателями</p>
    <p>Как видно на рисунке 4.4, сначала переменная а была равна 0, а после стала равна 2.</p>
    <p>Следует отметить, что вот эти две строчки:</p>
    <pre class="cpp-code"><code class="language-cpp">int *p;
p = &#38;a;</code></pre>
    <p>можно записать следующим образом:</p>
    <pre class="cpp-code"><code class="language-cpp">int *p = &#38;a;</code></pre>
    <p>Когда объявляют указатель, то присваивают всегда адрес, несмотря на звёздочку, эта звёздочка говорит о том, что
        объявляется указатель, но потом, когда при его объявлении присваивается какое-либо значение, &#8211; это
        означает,
        что ему
        присваивается адрес. Поэтому здесь можно покороче записать сразу объявление указателя «p» и присвоение ему
        адреса
        переменной «а», а потом по этому адресу записать значение 2. Работать будет одинаково. И лучше использовать
        такую
        более короткую конструкцию.</p>
    <p>Таким образом, указатель &#8211; это некая переменная, которая в 32-разрядных операционных системах занимает 4
        байта,
        потому что 4 байта &#8211; это 32 бита, в этих 4 байтах хранится адрес памяти, с которой этот указатель ptr
        работает. И то
        же самое для 64-разрядных операционных систем, только в этом случае указатель ptr уже занимает 8 байт, потому
        что 8
        байт &#8211; это 64 бита <a href="source.html#metka15">[15]</a>. </p>
    <p>И в эти 8 байт прописывается адрес, с которым работает указатель ptr, т. е. указатель ptr &#8211; это некая
        переменная,
        которая хранит адрес памяти, а вот тип данных, который записывается перед указателем, говорит о том, с каким
        числом
        байтов будет работать этот указатель.</p>
    <p class="photo"><img src="./img/4_chapter/4.5.png" alt=""></p>
    <p class="signature">Рисунок 4.5 &#8211; Выделение памяти в разных ОС</p>
    <p>Например, если задаётся указатель типа char, то работа будет происходить с 1 байтом, если создается указатель
        типа
        short, то будем работать уже с двумя байтами, int &#8211; с четырьмя байтами, а double &#8211; c 8 байтами.</p>
    <pre class="cpp-code"><code class="language-cpp">char *ptr1;      // работаем с одним байтом
short *ptr2;    // работаем с двумя байтами
int *ptr3;         // работаем с четырьмя байтами
double *ptr4;  // работаем с восемью байтами</code></pre>
    <p>Но что это значит &#8211; работать с одним байтом или с четырьмя? Далее представлен такой код, в котором показано
        данное отличие:</p>
    <pre class="cpp-code"><code class="language-cpp">#include &ltiostream>
using namespace std;
int main(){
	setlocale(LC_ALL, "Russian");
	int a[] = { 1, 2, 3, 4 };  // обьявление массива
	int* p = a;              // одному указателю присваиваем значение другого
	cout << *p << endl;
	p++;
	cout << *p << endl;
	p++;
	cout << *p << endl;
	p++;
	cout << *p << endl;
	p++;
	return 0;
}</code></pre>
    <p>Например, если используется массив с целочисленными элементами, далее указателю присваивается адрес этого
        массива, т.
        е. номер байта, начиная с которого этот массив хранится в памяти. Причем имя массива в С++ является указателем.
        Т.
        е. имя массива «а» &#8211; это на самом деле есть указатель, поэтому здесь одному указателю присваивается адрес
        другого
        указателя, в итоге указатель «p» также указывает на этот массив «а», далее выводится первый.</p>
    <p>В этом случае значение изменится не на единицу, а сразу на 4, так как тип int занимает 4 байта &#8211; это
        особенность
        адресной арифметики указателей. Сделано это для того, чтобы сразу переходили к следующему элементу массива, к
        двойке в данном случае, а не сдвигались на 1 байт. Т. е. адрес увеличивается на 4 байта. Значит, второй оператор
        cout должен вывести 2. После этого адрес сдвигается еще на 4 байта и выводится следующий элемент массива &#8211;
        3,
        опять
        сдвигаемся, и выводится 4. Далее приведена экранная форма, как работает данная программа.</p>
    <p class="photo"><img src="./img/4_chapter/4.6.png" alt=""></p>
    <p class="signature">Рисунок 4.6 &#8211; Работа с массивами и указателями</p>
    <p>Как видно на рисунке 4.6, программа вывела все элементы массива: 1, 2, 3, 4. В этом примере было
        продемонстрировано,
        что указатели можно присваивать друг другу.</p>
    <h3 id="4.2">4.2 Использование указателей разных типов</h3>
    <p>Если указатели будут иметь разные типы, один тип int, а другой char, можно ли далее одному указателю присвоить
        значение другого?</p>
    <pre class="cpp-code"><code class="language-cpp">int a=10;
int *p=&#38;a;
char *p2;
p2≠p1;</code></pre>
    <p>На самом деле так делать нельзя. Чтобы присвоить указателю p2 (char) значение указателя p1, который имеет тип
        int,
        нужно сделать такое преобразование типов:</p>
    <pre class="cpp-code"><code class="language-cpp">p2=(char*)p1;</code></pre>
    <p>В круглых скобках указать char*, в этом случае p1 преобразуется к указателю типа char, и только потом происходит
        присваивание их адресов, а так как указатель p2 работает с 1 байтом, то с его помощью можно вывести на экран
        значение
        отдельных байтов переменной «а». Потому что указатель р1 указывает на эту переменную, и указателю p2 был
        присвоен
        адрес, начиная с которого переменная «а» хранится, значит, сдвигаясь по одному байту, можно побайтно вывести
        значения
        ячеек, в которых хранится переменная «а».</p>
    <p>Программа, которая это делает, выглядит следующим образом:</p>
    <pre class="cpp-code"><code class="language-cpp">#include &ltiostream>
using namespace std;
int main(){
	setlocale(LC_ALL, "Russian");
	int a = 10;
	int* p1 = &#38;a;
	char* p2 = (char*)p1;
	for (int i = 0; i < sizeof(int); i++)
		cout << (int)(*p2++) << endl;
	return 0;
}</code></pre>
    <p>В данном примере p2 указывает на переменную «а» и имеет тип char, далее побайтно в цикле for выводится каждая
        ячейка,
        в которой хранится переменная «а». Далее представлен результат выполнения программы:</p>
    <p class="photo"><img src="./img/4_chapter/4.7.png" alt=""></p>
    <p class="signature">Рисунок 4.7 &#8211; Использование указателей разных типов</p>
    <p>Видно, что в первой ячейке хранится число 10, а остальные ячейки равны 0. Что верно, потому что переменная а
        равна
        10. Следует обратить внимание, что указатель p2 &#8211; это на самом деле массив, состоящий из 4 однобайтовых
        элементов.</p>
    <p>При этом можно использовать синтаксис массива для вывода его элементов на экран. Зная особенности адресной
        арифметики, можно присваивать разные типы разным указателям. В таблице 4.1 приведены списки операторов, которые
        реализуют эту арифметику. Такие операции адресной арифметики можно делать с указателями.</p>
    <p>Таблица 4.1 &#8211; Адресная арифметика</p>
    <p class="tables"><img src="./img/4_chapter/table4.1.png" alt=""></p>
    <p>Согласно адресной арифметике, можно присваивать одному указателю значение другого указателя, если типы этих
        указателей одинаковы. Если типы этих указателей разные, то нужно делать приведение типов. Если нужно увеличить
        значение указателя, то можно использовать оператор +=. Если написать -=, то уменьшится значение указателя. С
        оператором pt++ или ++pt, что одно и то же в данном случае, значение увеличивается на 1, аналогично с
        операторами
        pt-- и –pt, только происходит уменьшение значения на 1.</p>
    <h3 id="4.3">4.3 Указатели и структуры</h3>
    <p>Указатели можно использовать не только для работы с массивами, но и со структурами и объединениями. Далее
        приведен
        пример работы программы, в которой используются указатели на структуры данных.</p>
    <pre class="cpp-code"><code class="language-cpp">#include &ltiostream>
using namespace std;
typedef struct{
	char a; // объявление структуры
	int b;
}
VAR;
int main(){
	setlocale(LC_ALL, "Russian");
	VAR v = { '#', 5 };   // присвоение значений структуре
	VAR* p = &#38;v;        // указателю p присваивается адрес структуры
	cout << (*p).a << " " << (*p).b << endl;
	p->a = '*';
	p->b = -8;
	cout << p->a << " " << p->b << endl;
	return 0;
}</code></pre>
    <p>Здесь в самом начале задана<a href="glossary.html#m11">структура</a> типа var и два элемента «а» и «b». Далее эта структура задается, и ей сразу
        присваивается два значения: символ # и число 5. Затем для этой структуру задается указатель типа var, которому
        присваивается адрес этой структуры. Далее выводится через указатель p значения переменных а и b.</p>
    <p>После этого используется уже немного другой синтаксис: записывается указатель p, далее знак ->, и прописывается
        тот
        элемент, с которым мы работаем. После чего присваиваем ему символ *. То же самое с элементом b: присваиваем ему
        значение -8. Затем на экран выводится значение элементов этой структуры (рисунок 4.8).</p>
    <p class="photo"><img src="./img/4_chapter/4.8.png" alt=""></p>
    <p class="signature">Рисунок 4.8 &#8211; Результат работы указателей и структур</p>
    <p>Как видно на рисунке 4.8, сначала выводится исходное значение # 5, а затем измененное &#8211; * -8.</p>
    <p>То есть, когда реализуется работа через указатель со структурой, можно использовать либо классический синтаксис
        (*p).a, либо можно использовать специальный оператор ->, который позволяет через указатель обращаться к
        элементам
        структуры. Такой оператор прописать гораздо короче, чем конструкцию (*p).a. Поэтому часто используется такая
        запись:
        p->a= ‘*’; при обращении через указатель к элементам структуры.</p>
    <h3 id="4.4">4.4 Выделение памяти</h3>
    <p>Следует обратить внимание, что во всех предыдущих примерах были использованы переменная или массив, с которыми
        работали через указатели. Однако ситуация изменится, если работать с произвольной областью памяти, записывая
        туда
        значения или считывать их.</p>
    <p>Например, в следующем примере задан указатель ptr типа short, которому присвоено значение 10000, т. е. он будет
        работать с ячейкой памяти 10000 и 10001. В данный указатель необходимо будет записать число 0.</p>
    <pre class="cpp-code"><code class="language-cpp">short *ptr=1000;
*ptr=0;</code></pre>
    <p>Скорее всего, операционная система не разрешит выполнить такую операцию, так как эта область памяти (10000 и
        10001)
        не зарезервирована программой и записывать данные можно только в выделенную область памяти.</p>
    <p>Т. е. прежде чем куда что-либо записывать, сначала необходимо выделить память, а потом уже записывать туда
        данные.
        Когда создавались переменные, то память под них выделялась автоматически. Если же не реализуется работа с
        переменными
        через указатели, то необходимо самостоятельно выделить память, чтобы сохранять в ней информацию. Для этого в С++
        используется оператор new.</p>
    <p>Синтаксис:</p>
    <pre class="cpp-code"><code class="language-cpp">new &ltтип данных></code></pre>
    <p>или для массивов
    <pre class="cpp-code"><code class="language-cpp">new &ltтип данных>[&ltчисло элементов>]</code></pre></p>
    <p>Также можно воспользоваться функцией malloc.</p>
    <p>Синтаксис:</p>
    <pre class="cpp-code"><code class="language-cpp">void *malloc(&ltчисло выделяемых байт>);</code></pre>
    <p>Функция malloc изначально используется в языке С и просто выделяет то же число байт, а вот оператор new появился
        в
        связи с объектно-ориентированным программированием и не только выделяет память, но и вызывает <a href="glossary.html#m7">конструктор</a>
        объекта.
        Чаще выбирают оператор new, так как он удобнее в использовании.</p>
    <p>Далее приведен простой пример выделения памяти:</p>
    <pre class="cpp-code"><code class="language-cpp">#include &ltiostream>
using namespace std;
int main(){
	setlocale(LC_ALL, "Russian");
	int* p = new int;
	int* p2 = (int*)malloc(sizeof(int));
	*p = 1;
	*p2 = 2;
	cout << *p << " " << *p2 << endl;
	return 0;
}</code></pre>
    <p>В данном примере происходит выделение памяти с помощью оператора new для типа int, а потом то же самое только с
        помощью функции malloc. Причем перед функцией malloc идет приведение типов, так как функция malloc имеет тип
        void,
        а нужен тип int. В итоге указатель p указывает на выделенную область памяти, состоящую из 4 байт, то же самое
        указатель p2 уже на другую область памяти, состоящую также из 4 байт. Далее в области памяти p и p2 записываются
        значения 1 и 2 соответственно. Далее происходит вывод на экран (рисунок 4.9).</p>
    <p class="photo"><img src="./img/4_chapter/4.9.png" alt=""></p>
    <p class="signature">Рисунок 4.9 &#8211; Пример использования функций для выделения памяти</p>
    <p>Однако у этой программы есть один недостаток. После того, как выделяется память, ею воспользовались и она нам
        больше
        не нужна, ее следует освободить. Т. е. дать возможность использовать ее другим программам. Кроме того, если
        выделение памяти происходит, например, в цикле, а освобождать мы ее забываем, то наша программа будет поглощать
        все
        больше и больше памяти компьютера, пока ее не будет хватать. Такая ситуация называется утечкой памяти и
        возникает,
        когда забывают освободить уже ненужную ранее выделенную память.</p>
    <p>Для освобождения памяти используется оператор delete. Записывается он так delete&ltуказатель> или
        delete[]&ltуказатель>, если память освобождается от массива <a href="source.html#metka15">[16]</a>.</p>
    <p>Синтаксис:</p>
    <pre class="cpp-code"><code class="language-cpp">delete &ltуказатель>;
delete[]&ltуказатель>;</code></pre>
    <p>Если же память была выделена с помощью функции malloc, то освобождать ее нужно с помощью функции
        free(&ltуказатель>).</p>
    <p>Синтаксис:</p>
    <pre class="cpp-code"><code class="language-cpp">free (&ltуказатель>;)</code></pre>
    <p>Освободим память в нашей программе. Для этого в конце необходимо указать две строчки:</p>
    <pre class="cpp-code"><code class="language-cpp">delete p;
free (p2);</code></pre>
    <p>Далее приведен исправленный код, приведенной ранее программы:</p>
    <pre class="cpp-code"><code class="language-cpp">#include &ltiostream>
using namespace std;
int main(){
	setlocale(LC_ALL, "Russian");
	int* p = new int;
	int* p2 = (int*)malloc(sizeof(int));
	*p = 1;
	*p2 = 2;
	cout << *p << " " << *p2 << endl;
	delete p;
	free(p2);
	return 0;
}</code></pre>
    <p class="photo"><img src="./img/4_chapter/4.10.png" alt=""></p>
    <p class="signature">Рисунок 4.10 &#8211; Пример использования функции для высвобождения памяти</p>
    <p>Если же память выделяется под массив, то освобождение памяти реализуется аналогичным образом. Таким образом,
        использование указателей накладывает на программиста дополнительную ответственность за контроль памяти, чтобы не
        возникало утечек, а также за контроль значений указателя, чтобы он указывал на выделенную память, а не на
        произвольную. Из-за этих вещей использование указателей может приводить к серьезным и трудно определяемым
        ошибкам.</p>
    <h3 id="4.5">4.5 Динамические массивы</h3>
    <p>Далее приведен пример работы с массивами, где для указателя р выделяется n элементов типа int, и далее в каждый
        элемент массива записываются значения 1, 2, 3, 4 соответственно. Далее они выводятся на экран, и память
        освобождается.</p>
    <pre class="cpp-code"><code class="language-cpp">#include &ltiostream>
using namespace std;
int main(){
	setlocale(LC_ALL, "Russian");
	int n = 4;
	int* p = new int[n];
	p[0] = 1; p[1] = 2; p[2] = 3; p[3] = 4;
	for (int i = 0; i < n; i++)
		cout << p[i] << " ";
	delete[]p;
	return 0;
}</code></pre>
    <p class="photo"><img src="./img/4_chapter/4.11.png" alt=""></p>
    <p class="signature">Рисунок 4.11 &#8211; Работа с динамическими массивами</p>
    <p>Причем здесь стоит обратить внимание, что при создании массива указывается число его элементов через переменную
        n,
        тогда как при создании обычных массивов так делать нельзя. Т. е. этот пример показывает, как можно создавать
        динамические массивы, т. е. массивы, число элементов которых зависит от значения некоторой переменной. Без
        указателей в С++ этого сделать было бы невозможно.</p>
    <p>Таким образом, использование указателей повышает гибкость построения программы, например, с их помощью создаются
        динамические структуры данных, такие как динамические массивы, стеки, связные списки, бинарные деревья и многие
        другие.</p>
    <h3 id="4.6">4.6 Ссылки</h3>
    <p>Ссылка представляет собой псевдоним или второе имя, которое <a href="glossary.html#m9">программа</a> может использовать для обращения к
        переменной.
        Для объявления ссылки в программе используется знак &.</p>
    <pre class="cpp-code"><code class="language-cpp">int var;
int &var2=var;</code></pre>
    <p>Особенность использования ссылок заключается в необходимости их инициализации сразу же при объявлении. Например,
        как
        в вышеописанном случае объявили ссылку var2 и сразу проинициализировали ее на переменную var. Т. е. в данном
        случае
        получается, что переменная var2 имеет два имени var2 и var.</p>
    <p>Преимущество использования ссылок перед указателями заключается в их обязательной инициализации. Поэтому
        программист
        всегда уверен, что переменная var2 работает с выделенной областью памяти, а не с произвольной, что бывает при
        использовании указателей. В отличие от указателей ссылка инициализируется только один раз, при ее объявлении,
        повторная инициализация приведет к ошибке. Благодаря этому обеспечивается надежность использования ссылок, но
        снижается гибкость их применения. Обычно ссылки используются в качестве аргументов функции. Далее приведен
        пример
        программы с использованием ссылок:</p>
    <pre class="cpp-code"><code class="language-cpp">#include &ltiostream>
using namespace std;
void swap(int& a, int& b){
	int temp = a;
	a = b;
	b = temp;
}
int main(){
	int arg1 = 10, arg2 = 5;
	cout << arg1 << " " << arg2 << endl;
	swap(arg1, arg2);
	cout << arg1 << " " << arg2 << endl;
	return 0;
}</code></pre>
    <p>В данном примере задается функция swap, у нее два аргумента: «a» и «b», которые представляют собой ссылки. Эта
        функция
        меняет значения переменных а и b между собой. Далее идет функция main, в которой заданы два аргумента: arg1 = 10
        и
        arg2 = 5. Эти аргументы выводятся на экран, затем вызывается функция swap, и ей передаются два аргумента arg1 и
        arg2.
        Внутри функции swap они меняются местами, но так как в функции swap используются ссылки, то это влияет и на
        значение
        этих переменных arg1 и arg2. Т. е. когда мы далее выведем значение аргументов arg1 и arg2, они должны поменяться
        своими значениями. Результат выполнения программы представлен на рисунке 4.12.</p>
    <p class="photo"><img src="./img/4_chapter/4.12.png" alt=""></p>
    <p class="signature">Рисунок 4.12 &#8211; Работа со ссылками</p>
    <p>Как видно на рисунке 4.12, в начале было 10 5, а потом стало 5 10, то есть все верно, значения аргументов
        поменялись.</p>
    <p>Но в отличие от указателей со ссылками нельзя делать следующие операции:</p>
    <ol>
        <li class="with-a-dash">нельзя получить адрес ссылки, используя оператор адреса С++;</li>
        <li class="with-a-dash">нельзя присвоить ссылку указатель;</li>
        <li class="with-a-dash">нельзя выполнять арифметические операции над ссылкой, например, добавлять смещение.</li>
    </ol>
    <p>На видео 9 представлена лекция по указателям и ссылкам, а также по выделению памяти.</p>
    <video controls="controls" poster="./img/video.jpg" src="./video/video_9_l.mp4"></video>
    <p class="signature">Видео 9 &#8211; Указатели и ссылки, выделение памяти</p>

    <h3 id="4.7">4.7 Указатели на функции</h3>
    <p>Как уже было описано выше, в языке С++ можно задавать указатели на отдельные переменные, массивы, структуры, то
        есть
        на обычные данные языка С++. Но в этом языке С++ можно делать указатели и на функции. Для этого необходимо
        использовать следующий синтаксис:</p>
    <pre class="cpp-code"><code class="language-cpp">тип функции (*имя указателя)(спецификация параметров);</code></pre>
    <p>Сначала прописывается тип функции, потом в круглых скобках указывается имя указателя, а дальше список его
        параметров.</p>
    <p>Например, если прописать указатель на функцию следующим образом:</p>
    <pre class="cpp-code"><code class="language-cpp">#include &ltiostream>
using namespace std;
int main(){
	//тип функции (*имя указателя)(спецификация параметров);
	void(*ptr_func)(); // void &#8211; тип функции ptr_func имя указателя () &#8211; спецификация параметров
}</code></pre>
    <p>Получается, (*ptr_func) &#8211; это указатель, который будет указывать на функцию с типом void, не имеющую
        никаких
        параметров.</p>
    <p>В качестве примера можно записать такую функцию foo. Функция foo возвращает тип void и не имеет никаких
        параметров.
        На неё может указывать указатель (*ptr_func). Проинициализировать указатель на функцию можно таким образом:
        сначала
        записывается имя указателя, затем знак =, а далее имя функции foo. Теперь ptr_func указывает на функцию foo.</p>
    <p>Соответственно, чтобы вызвать функцию foo через указатель ptr_func, записывается имя указателя ptr_func и
        ставятся
        круглые скобки в качестве его параметров. Таким образом, вызывается функция foo через указатель ptr_func.</p>
    <pre class="cpp-code"><code class="language-cpp">#include &ltiostream>
using namespace std;
void foo(){
    cout << "foo\n";
}
int main(){
    // тип функции (*имя указателя)(спецификация параметров);
    void(*ptr_func)();
    ptr_func = foo;
    ptr_func(); // вызов функции foo через указатель ptr_func
}</code></pre>
    <p>На рисунке 4.13 приведен пример работы программы.</p>
    <p class="photo"><img src="./img/4_chapter/4.13.png" alt=""></p>
    <p class="signature">Рисунок 4.13 &#8211; Результат создания указателей на функции</p>
    <p>Как видно на рисунке 4.13, действительно, на экран вывелось «foo», значит, функция foo выполнилась.</p>
    <p>Следует обратить внимание, что указатель ptr_func может указывать на любую функцию типа void, у которой нет
        аргументов, при этом имя функции не имеет никакого значения. Главное, чтобы соблюдалась сигнатура функции, т. е.
        функция возвращала такой же тип, что и указатель, и имела такую же спецификацию параметров. Например, если
        задать
        другую функцию с такой же сигнатурой, т. е. она будет иметь тип void и не иметь входных аргументов, то указатель
        ptr_func можно инициализировать и на эту функцию. Рассмотрим пример программы, в которой вместо foo напишем,
        например, print. Вызывая указатель ptr_func(), мы будем вызывать функцию print.</p>
    <pre class="cpp-code"><code class="language-cpp">#include &ltiostream>
using namespace std;
void foo(){
    cout << "foo\n";
}
void print(){
    cout << "print\n";
}
int main(){
    //тип функции (*имя указателя)(спецификация параметров);
    void(*ptr_func)();
    ptr_func = print; // присваиваем указателю функцию print
    ptr_func();//вызов функции print через указатель ptr_func
}</code></pre>
    <p>Далее приведен результат выполнения программы (рисунок 4.14).</p>
    <p class="photo"><img src="./img/4_chapter/4.14.png" alt=""></p>
    <p class="signature">Рисунок 4.14 &#8211; Результат создания указателей на функции</p>
    <p>Как видно на рисунке 4.14, на экран вывелось print, значит, вызвалась функция print.</p>
    <p>Результат работы данной программы показал, что мы получаем очень интересный эффект. Используя один и тот же вызов
        указателя ptr_func, можно вызывать через него совершенно разные функции, соответственно, с такими сигнатурами
        &#8211; void
        и без параметров. В программировании это называется полиморфизмом, т. е. когда мы единым образом можем вызывать
        совершенно разные функции.</p>
    <p>Изменим сигнатуру функции print, добавим ей параметр «а», этот параметр будем выводить на экран.</p>
    <pre class="cpp-code"><code class="language-cpp">void print(int a){
	cout << "print: " << a << endl;
}</code></pre>
    <p>При запуске данного кода среда разработки будет оповещать об ошибке, т. к. сигнатура функции print не совпадает с
        сигнатурой указателя ptr_func. Соответственно для вызова такой функции нужно в сигнатуру указателя прописать тип
        int и при вызове функции через указатель ptr_func нужно прописать какой-либо аргумент, например, число 5.</p>
    <pre class="cpp-code"><code class="language-cpp">#include &ltiostream>
using namespace std;
void foo(){
    cout << "foo\n";
}
void print(int a){
    //прописываем параметр a
    cout << "print: " << a;
}
int main(){
    //тип функции (*имя указателя)(спецификация параметров);
    void(*ptr_func)(int);//прописываем тип int в скобки параметров
    ptr_func = print;
    ptr_func(5);// записываем аргумент 5
}</code></pre>
    <p>Далее представлен результат выполнения программы рисунок 4.15.</p>
    <p class="photo"><img src="./img/4_chapter/4.15.png" alt=""></p>
    <p class="signature">Рисунок 4.15 &#8211; Результат создания указателей на функции с аргументом</p>
    <p>Действительно, функция print вывела число 5. Таким образом, через указатель запустилась функция print, которая
        имеет
        один аргумент.</p>
    <p>По аналогии можно прописать несколько аргументов, тогда сигнатуру указателя ptr_func тоже нужно изменить и
        передать
        еще какой-либо параметр:</p>
    <pre class="cpp-code"><code class="language-cpp">#include &ltiostream>
using namespace std;
void foo(){
    cout << "foo\n";
}
void print(int a, int b){
    //добавляем второй параметр b
    cout << "print: " << a;
}
int main(){
    //тип функции (*имя указателя)(спецификация параметров);
    void(*ptr_func)(int, int);//второй раз прописываем тип int
    ptr_func = print;
    ptr_func(5, 6);// добавляем второй аргумент
}</code></pre>
    <p>Таким образом, через указатели можно вызывать совершенно разные функции.</p>
    <p>На видео 10 представлена лекция по указателям на функции.</p>
    <video controls="controls" poster="./img/video.jpg" src="./video/video_10_l.mp4"></video>
    <p class="signature">Видео 10 &#8211; Указатели на функции</p>
    <h3 id="4.8">4.8 Контрольные вопросы для закрепления изученного материала</h3>
    <ol>
        <li class="with-a-bracket">Для чего предназначены указатели?</li>
        <li class="with-a-bracket">Как можно использовать указатели разных типов?</li>
        <li class="with-a-bracket">Как осуществляется выделение памяти для работы с указателями?</li>
        <li class="with-a-bracket">Опишите, как могут работать указатели со структурами?</li>
        <li class="with-a-bracket">Как создаются динамические массивы?</li>
    </ol>
</script>

<script id="page4.9" type="text/html">
    <TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0>
        <TR>
            <TD width="50%"><a name="3"></a>
                <HR>
                <div align=justify><h1>Тренировочные упражнения</h1></div>
  <form>
   <ol> 
   	<li class="without-parentheses"> Запишите, что будет выведено на экран в результате выполнения программного кода?
   	 <pre class="cpp-code"><code class="language-cpp">
#include &ltiostream>
using namespace std;
int main(){
	setlocale(LC_ALL, "Russian");
	int a = 3; // инициируется переменная «a»
	int* p;
	p = &a;
	*p = 121; // меняется значение переменной «a»
	cout << a << endl; //вывод значения переменной на экран
	return 0;
}
</code></pre>  
              <p>Ответ: <input type="text" id="glav4_1" size="3"></p>
 <input type="button" value="Ответить" class="proverit_glav_4_1"></input>
              <input type="reset" value ="Очистить"></input>
              <br><br>
                 <div id="resultat_4_1"></div>
                  </form>
              </li><br><br>
<form>

<li class="without-parentheses"> Заполните пропуски в коде таким образом, чтобы вызвать функцию <em>foo</em>, через указатель <em>ptr_func</em>.
	 <pre class="cpp-code"><code class="language-cpp">
#include &ltiostream>
using namespace std;
void foo(){
    cout << "foo\n";
}
int main(){
    // тип функции 
    void( <input type="text" id="glav4_2_1" size="3">)();
    ptr_func =  <input type="text" id="glav4_2_2" size="3">;
    ptr_func(); // вызов функции foo через указатель ptr_func
}
}
</code></pre>  
 <input type="button" value="Ответить" class="proverit_glav_4_2"></input>
              <input type="reset" value ="Очистить"></input>
              <br><br>
                 <div id="resultat_4_2"></div>
 	 </form>  </li>
      </ol>
 </HR></TD></TR></TABLE>
</script> 


<script id="page4.10" type="text/html">
    <table BORDER=0 CELLPADDING=0 CELLSPACING=0>
        <tr>
            <td width="50%"><a name="3"></a>
                <HR>
                <div align=justify><h1 align="center">Тестирование по четвертой главе</h1></div>
                <form name=test>
                    <ol>
                        <li>
                            <h4><input type=text name=T1 style="height: 15px; width:15px;" value=''> Укажите
                                зарезервированное ключевое слово для
                                высвобождения выделенной памяти:</h4>
                            <input type=radio name=Q1> delete;<br>
                            <input type=radio name=Q1> clear;<br>
                            <input type=radio name=Q1> remove;<br>
                            <input type=radio name=Q1> utilize;<br>
                            <input type=radio name=Q1> free.<br>
                            <br>
                        </li>
                        <li>
                            <h4><input type=text name=T2 style="height: 15px; width:15px;" value=''> Укажите правильное
                                объявление указателя в С++:</h4>
                            <input type=radio name=Q2> ptr x;<br>
                            <input type=radio name=Q2> int x;<br>
                            <input type=radio name=Q2> int&x;<br>
                            <input type=radio name=Q2> int !x;<br>
                            <input type=radio name=Q2> int *x.<br>
                            <br>
                        </li>
                        <li>
                            <h4><input type=text name=T3 style="height: 15px; width:15px;" value=''> Укажите
                                зарезервированное ключевое слово для
                                динамического выделения памяти:</h4>
                            <input type=radio name=Q3> value;<br>
                            <input type=radio name=Q3> new;<br>
                            <input type=radio name=Q3> create;<br>
                            <input type=radio name=Q3> creation;<br>
                            <input type=radio name=Q3> malloc.<br>
                            <br>
                        </li>
                        <li>
                            <h4><input type=text name=T4 style="height: 15px; width:15px;" value=''> Какой из видов
                                указателей описан в следующем коде?
                            </h4>
                            <pre class="cpp-code"><code class="language-cpp">void(*ptr_func)();
ptr_func = foo;
ptr_func();</code></pre>
                            <input type=radio name=Q4> указатель на строки;<br>
                            <input type=radio name=Q4> указатель на функцию;<br>
                            <input type=radio name=Q4> указатель на массив;<br>
                            <input type=radio name=Q4> указатель на переменную;<br>
                            <input type=radio name=Q4> указатель на структуру.<br>
                            <br>
                        </li>
                        <li>
                            <h4><input type=text name=T5 style="height: 15px; width:15px;" value=''> Какой из видов
                                указателей описан в следующем коде?
                            </h4>
                            <pre class="cpp-code"><code class="language-cpp">typedef struct{
// объявление структуры
    char a;
    int b;
}
VAR;
VAR v = { '#', 5 };   // присвоение значений структуре
VAR* p = &#38;v;        // указателю p присваивается адрес структуры
cout << (*p).a << " " << (*p).b << endl;</code></pre>
                            <input type=radio name=Q5> указатель на строки;<br>
                            <input type=radio name=Q5> указатель на функцию;<br>
                            <input type=radio name=Q5> указатель на массив;<br>
                            <input type=radio name=Q5> указатель на переменную;<br>
                            <input type=radio name=Q5> указатель на структуру.<br>
                            <br>
                        </li>
                        <li>
                            <h4><input type=text name=T6 style="height: 15px; width:15px;" value=''> В языке С++
                                указатель
                                &mdash; это:</h4>
                            <input type=radio name=Q6> специальный значок, показывающий, что это динамическая
                            переменная;<br>
                            <input type=radio name=Q6> символическое представление адреса ячейки памяти;<br>
                            <input type=radio name=Q6> символ, указывающий на что-либо;<br>
                            <input type=radio name=Q6> метка;<br>
                            <input type=radio name=Q6> нет правильного ответа.<br>
                            <br>
                        </li>
                        <li>
                            <h4><input type=text name=T7 style="height: 15px; width:15px;" value=''> Пример: val = *ptr;
                                операция косвенной адресации * производит:</h4>
                            <input type=radio name=Q7> получение адреса;<br>
                            <input type=radio name=Q7> перенаправление адреса переменной val к переменной ptr;<br>
                            <input type=radio name=Q7> определение значения, на которое указывает ptr;<br>
                            <input type=radio name=Q7> определение значения, на которое указывает val;<br>
                            <input type=radio name=Q7> нет правильного варианта.<br>
                            <br>
                        </li>
                        <li>
                            <h4><input type=text name=T8 style="height: 15px; width:15px;" value=''> В чём отличие
                                ссылки &
                                от указателя *?</h4>
                            <input type=radio name=Q8> указатель можно перемещать по массиву, используя операции
                            инкремента
                            и декремента;<br>
                            <input type=radio name=Q8> для ссылок нужно использовать операцию разыменования, чтобы
                            получить
                            содержимое объекта, на который указывает ссылка;<br>
                            <input type=radio name=Q8> отличий между ссылками и указателями нет;<br>
                            <input type=radio name=Q8> все варианты верны;<br>
                            <input type=radio name=Q8> нет правильного ответа.<br>
                            <br>
                        </li>
                        <li>
                            <h4><input type=text name=T9 style="height: 15px; width:15px;" value=''> Выберите вариант
                                ответа, где представлен указатель на объект типа T:</h4>
                            <input type=radio name=Q9> T& r;<br>
                            <input type=radio name=Q9> T* p;<br>
                            <input type=radio name=Q9> T a[n];<br>
                            <input type=radio name=Q9> все варианты верны;<br>
                            <input type=radio name=Q9> нет правильного ответа.<br>
                            <br>
                        </li>
                        <li>
                            <h4><input type=text name=T10 style="height: 15px; width:15px;" value=''> Выберите вариант
                                ответа, где представлена ссылка на объект типа T:</h4>
                            <input type=radio name=Q10> T& r;<br>
                            <input type=radio name=Q10> T* p;<br>
                            <input type=radio name=Q10> T a[n];<br>
                            <input type=radio name=Q10> все варианты верны;<br>
                            <input type=radio name=Q10> нет правильного ответа.<br>
                            <br>
                        </li>
                    </ol>
                    <div align="center">
                        <div>
                            <input type=button value="Показать результат" onClick="test1('MTUyMjUyMzEyMQ', 10)">
                        </div>
                        <div>
                            <textarea style="margin-top:6px" rows=5 cols="100%" name=s1></textarea>
                        </div>
                        <div>
                            <input type=reset value="Очистить выбранные пункты">
                        </div>
                        <br>
                        <Div align=center>
                            <a href="#3">В начало страницы</a>
                        </div>
                        <br>
                    </div>
                </form>
            </TD>
        </TR>
    </TABLE>
</script>

<!-- /page5 -->
<script id="page5" type="text/html">
    <h2 id="5">5 Пользовательские функции в языке C++</h2>
    <h3 id="5.1">5.1 Объявление и определение функций</h3>
    <p>До сих пор использовались только существующие функции, например, строковые функции strlen(), sprinrf(), atoi(),
        strcpy() и многие другие. Вместе с тем существующих функций языка С++ недостаточно, и при программировании
        различных
        задач возникает необходимость создания своих собственных. В связи с этим необходимо понимать, в каких случаях их
        целесообразно создавать в программе. Зачастую это делается, чтобы много раз не писать один и тот же текст
        программы.
        Например, в программах при работе со строками часто приходится копировать одну строку в другую. Следовательно,
        такую
        операцию лучше всего определить в виде функции и использовать ее по мере необходимости. Например, для этого и
        придумана функция strcpy. Но на все случаи жизни функции не придумаешь. Поэтому в программе можно объявить свою
        функцию, используя следующий синтаксис:</p>
    <pre class="cpp-code"><code
            class="language-cpp">&ltтип> &ltимя функции> ([список аргументов]) {&ltтело функции>}</code></pre>
    <p>где тип &#8211; тип данных, который будет возвращать функция,</p>
    <p>имя функции &#8211; служит для ее вызова в программе, оно придумывается программистом подобно именам
        переменных,</p>
    <p>список аргументов &#8211; необходим для передачи функции каких-либо данных при ее вызове,</p>
    <p>тело функции &#8211; набор операторов, которые выполняются при ее вызове.</p>
    <p>Таким образом, функция представляет собой именованную последовательность описаний и операторов, выполняющая
        какое-либо законченное действие <a href="source.html#metka1">[1]</a>.</p>
    <p>Как видно из синтаксиса, объявление функции (<a href="glossary.html#m9">Прототип</a>, заголовок, сигнатура) задает ее имя, тип возвращаемого
        значения и список передаваемых параметров. Определение функции содержит, кроме объявления, тело функции,
        представляющее собой последовательность операторов и описаний в фигурных скобках. Аргументы функций &#8211; один
        из
        основных способов обмена информацией между частями программы.</p>
    <p>Функция начинает выполняться в момент вызова. Любая функция должна быть объявлена и определена. Объявление
        функции
        должно находиться в тексте раньше ее вызова для того, чтобы компилятор мог осуществить проверку правильности
        вызова
        <a href="source.html#metka6">[6]</a>.</p>
    <p>Для вызова функции в простейшем случае нужно указать ее имя, за которым в круглых скобках через запятую
        перечисляются
        имена передаваемых аргументов. Вызов функции может находиться в любом месте программы, где по синтаксису
        допустимо
        выражение того типа, который формирует функция. Если тип возвращаемого функцией значения не void, она может
        входить
        в состав выражений или, в частном случае, располагаться в правой части оператора присваивания [13].</p>
    <p>Функция может возвращать значение &#8211; результат своей работы или выполнять некоторое другое действие, не
        связанное с возвратом результата. Например, функция clrscr() осуществляет очистку экрана, но не возвращает
        никакого
        значения. Если функция возвращает значение, то в ее заголовке перед именем функции должен быть указан тип
        возвращаемого значения:</p>
    <pre class="cpp-code"><code class="language-cpp">double mid(double x,double y)</code></pre>
    <p>В теле функции, возвращающей значение, обязан присутствовать оператор return (от англ. &#8211; возврат),
        содержащий
        результат работы функции &#8211; ее значение:</p>
    <pre class="cpp-code"><code class="language-cpp">double mid(double x, double y){
	return (x + y) / 2;
}</code></pre>
    <p>Если функция не возвращает значение, то в ее заголовке перед именем функции должен быть указан тип void. В этом
        случае в теле функции может встретиться оператор return без параметра. Но оператор return может и отсутствовать
        &#8211; выход из функции произойдет при достижении последней фигурной скобки.</p>
    <pre class="cpp-code"><code class="language-cpp">void print_v(int* a, int n){
    int j;
    printf("\n");
    for (j = 0; j < n; j++)
        printf("%8d", a[j]);
    printf("\n");
}</code></pre>
    <p>Далее приведен пример простой функции, возвращающей сумму двух целых величин:</p>
    <pre class="cpp-code"><code class="language-cpp">#include &ltiostream>
using namespace std;
int sum(int a, int b); // объявление функции
int main(){
	int a = 2, b = 3, c, d;
	c = sum(a, b); // вызов функции
	cin >> d;
	cout << sum(c, d); // вызов функции
	return 0;
}
int sum(int a, int b){ // определение функции (тело)
	return (a + b);
}</code></pre>
    <p>Далее представлен еще один пример использования функции, которая вычисляет периметр прямоугольника:</p>
    <pre class="cpp-code"><code class="language-cpp">#include &ltiostream>
using namespace std;
// объявление функции &#8211;  имя функции, два вещественных аргумента
float perimeter(float a, float b){
	// тело функции
	float res = 2 * (a + b);  // создание временной переменной res,
	// которой присваивается значение периметра прямоугольника
	return res;
    // возвращение результата-периметр прямоугольника
}
int main(){
	// основная функция, в которой указано два варианта вызова функции
	setlocale(LC_ALL, "rus");
	int w = 5;
	float h = 3.4;
	float p1 = perimeter(w, h);
	// первый вариант вызова функции, через переменные w, h
	float p2 = perimeter(5, 4);
	// второй вариант вызова функции, через конкретные значения 5 и 4
	cout << p1 << " " << p2 << endl;
	return 0;
}</code></pre>
    <p>Результат выполнения данного программного кода представлен на рисунке 5.1.</p>
    <p class="photo"><img src="./img/5_chapter/5.1.png" alt=""></p>
    <p class="signature">Рисунок 5.1 &#8211; Результат работы функции по вычислению периметра прямоугольника</p>
    <p>На экране были выведены значения двух прямоугольников. Следует обратить внимание, что, когда происходит вызов
        функции
        через переменные w и h, переменная w присваивается переменной а. То есть копируется значение 5, которое она
        содержит, в переменную а, и, соответственно, в переменную b копируется значение 3.5, которое содержится в
        переменной h.
        А далее уже используется значение переменных, вычисляется периметр. Таким образом, происходит передача данных
        этой
        функции.</p>
    <p>Также следует обратить внимание, что перед каждым аргументов стоит тип float a, float b. И нужно перед каждый
        аргументом прописывать тип.</p>
    <p>Следует отметить, что функция может возвращать тип void. Тип void означает, что функция не будет возвращать
        никакого
        значения. Если перед именем функции не указан ни один из стандартных типов и отсутствует спецификатор void, то
        считается, что функция возвращает значение типа int.</p>
    <p>В следующем примере реализуется функция типа void для работы с массивами:</p>
    <pre class="cpp-code"><code class="language-cpp">#include &ltiostream>
using namespace std;
void show_ar(int a[], int  N){  // задан массив а, размерность массива N
 // тип void означает, что функция не будет возвращать ни одного значения
    for (int i = 0; i < N; ++i)
        cout << a[i] << " ";
    // отсутствует оператор return, функция ничего не возвращает
}
int main(){
    setlocale(LC_ALL, "RUS");
    int b[] = { 4, 3, 2, -5, 6, 0 };	// объявление массива
    int N = sizeof(b) / sizeof(int);   // вычисление числа элементов массива
    show_ar(b, N);             // вызов функции с двумя элементами
    return 0;
}</code></pre>
    <p>Результат выполнения данного программного кода представлен на рисунке 5.2.</p>
    <p class="photo"><img src="./img/5_chapter/5.2.png" alt=""></p>
    <p class="signature">Рисунок 5.2 &#8211; Работа с типами void в функциях</p>
    <p>Как видно на рисунке 5.2, все элементы массива выведены на экран, программа работает корректно.</p>
    <h3 id="5.2">5.2 Параметры функции</h3>
    <p>Механизм параметров является основным способом обмена информацией между вызываемой и вызывающей функциями.
        Параметры,
        перечисленные в заголовке описания функции, называются формальными, а записанные в операторе вызова функции
        &#8211;
        фактическими.</p>
    <p>При вызове функции в первую очередь вычисляются выражения, стоящие на месте фактических параметров; затем в <a href="glossary.html#m11">стеке</a>
        выделяется память под формальные параметры функции в соответствии с их типом, и каждому из них присваивается
        значение соответствующего фактического параметра.</p>
    <h3 id="5.2.1">5.2.1 Параметры-значения</h3>
    <p>Формальный параметр в заголовке функции называют параметром-значением, если перед его именем указан только тип.
        Например, функция mid, вычисляющая среднее арифметическое двух величин, получает в качестве фактических
        аргументов
        два числовых значения определенного типа:</p>
    <pre class="cpp-code"><code class="language-cpp">double mid(double x, double y){
	return (x + y) / 2;
}</code></pre>
    <p>В качестве фактических аргументов, соответствующих параметрам-значениям, могут быть заданы любые числовые
        выражения
        (формулы):</p>
    <pre class="cpp-code"><code class="language-cpp">w1 = mid(x*cos(fi)+y*sin(fi), x*sin(fi)-y*cos(fi));</code></pre>
    <p>Значения этих выражений вычисляются и записываются в стек, откуда их извлекает функция mid и помещает переданные
        значения в свои локальные переменные x и y (формальные параметры-значения можно рассматривать как локальные
        переменные функции). При необходимости значение вычисленного выражения автоматически приводится к типу
        формального
        параметра. После работы функции возвращаемый результат возвращается в специально выделенном регистре.</p>
    <h3 id="5.2.2">5.2.2 Параметры по умолчанию</h3>
    <p><a href="glossary.html#m1">Аргументы по умолчанию</a> &#8211; это такие аргументы, которым сразу присваивается некоторое значение, когда
        объявляется
        функция. И если при вызове функций эти аргументы не буду переопределены, то все они останутся при своих
        значениях.</p>
    <p>Например, задана функция:</p>
    <pre class="cpp-code"><code class="language-cpp">double mid1(double x = 0.5, double y = 0.5){
	return (x + y) / 2;
}</code></pre>
    <p>К такой функции можно обратиться с одним (первым) аргументом или вообще без аргументов:</p>
    <pre class="cpp-code"><code class="language-cpp">z = mid1(0.75);	//результат равен 0.625=(0.75+0.5)/2
p = mid1();	//результат равен 0.5=(0.5+0.5)/2</code></pre>
    <p>Функция с параметрами по умолчанию работает правильно в двух случаях. Во-первых, если ее описание находится выше
        вызывающей функции и в заголовке функции содержится информация о параметрах по умолчанию. Во-вторых, если ее
        описание находится ниже и в заголовке функции отсутствуют сведения о параметрах по умолчанию, но они содержатся
        в
        прототипе. Одновременное упоминание значений по умолчанию и в заголовке функции, и в прототипе приводит к
        сообщению
        об ошибке. Ниже приводится один из вариантов правильного оформления такой программы:</p>
    <pre class="cpp-code"><code class="language-cpp">#include &ltiostream>
#include &ltconio.h>
using namespace std;
double mid(double x = 1, double y = 1);
void main(){
	double x = 0.4, y = 0.2, z;
	z = mid(x, y); cout << "z = " << z << endl;
	z = mid(x);   cout << "z = " << z << endl;
	z = mid();    cout << "z = " << z << endl;
	_getch();
}
double mid(double x, double y){
	return (x + y) / 2;
}</code></pre>
    <p>Далее представлен еще один пример использования параметров по умолчанию для вывода значений аргументов:</p>
    <pre class="cpp-code"><code class="language-cpp">#include &ltiostream>
using namespace std;
void show_args(short a = 10, float b = 20, int c = 30){
	cout << a << " " << b << " " << c << endl;
}
int main(){
	setlocale(LC_ALL, "rus");
	show_args();  // нет переопределения значений аргументов
	show_args(1);  // переопределение значений аргументов
	show_args(1, 2);
	show_args(1, 2, 3);
	return 0;
}</code></pre>
    <p>Работа данной программы представлена на рисунке 5.3.</p>
    <p class="photo"><img src="./img/5_chapter/5.3.png" alt=""></p>
    <p class="signature">Рисунок 5.3 &#8211; Результат использования параметров по умолчанию</p>
    <p>Как видно на рисунке 5.3, в первой строке выведено значение аргументов по умолчанию, а в остальных строках
        &#8211;
        измененные
        значения.</p>
    <p>Следует обратить внимание, что при использовании значений аргумента по умолчанию они должны находиться в списке
        определений последними.</p>
    <pre class="cpp-code"><code class="language-cpp">void my_func(int a, int b = 1, int c = 1); // правильное объявление
void my_func(int a, int b, int c = 1); // правильное объявление
void my_func(int a = 1, int b, int c = 1);// неправильно объявление
void my_func(int a, int b = 1, int c); // неправильно объявление</code></pre>
    <h3 id="5.2.3">5.2.3 Параметры-указатели</h3>
    <p>Формальный параметр в заголовке функции называют явным параметром-указателем, если перед его именем находится
        символ
        *. Например, функция swap1, осуществляющая перестановку местами значений двух переменных, должна получить в
        качестве
        параметров адреса этих переменных, т. е. указатели на них.</p>
    <pre class="cpp-code"><code class="language-cpp">void swap1(int* x, int* y){
	//явные параметры-указатели
	int tmp = *x;
	*x = *y;  *y = tmp;
}</code></pre>
    <p>Кроме явных параметров-указателей, в объявлении функции можно использовать и косвенные параметры-указатели,
        описанные
        с помощью механизма подстановок.</p>
    <pre class="cpp-code"><code class="language-cpp">#define pint int*
void swap1(pint x, pint y){
	//косвенные параметры указатели
	int tmp = *x;
	*x = *y;  *y = tmp;
}</code></pre>
    <h3 id="5.2.4">5.2.4 Параметры-ссылки</h3>
    <p>Формальный параметр в заголовке функции называют явным параметром-ссылкой, если перед его именем находится символ
        &.
        Например, функция swap2, осуществляющая перестановку местами значений двух переменных, должна получить в
        качестве
        параметров ссылки на эти переменные, т. е. их адреса:</p>
    <pre class="cpp-code"><code class="language-cpp">void swap2(int& x, int& y){
	//явные параметры-ссылки
	int tmp = x;
	x = y;  y = tmp;
}</code></pre>
    <p>Параметры-ссылки могут быть объявлены в заголовках функций и с помощью косвенных типов, предварительно описанных
        в
        конструкциях #define или typedef:</p>
    <pre class="cpp-code"><code class="language-cpp">#define rint int&
//или   typedef int& rint;
void swap2(rint x, rint y)</code></pre>
    <p>Точно так же, как и параметр-указатель, параметр-ссылка является адресом. Поэтому вызванная функция по ссылке
        может
        извлечь и при необходимости изменить нужное значение. В отличие от указателя доступ по ссылке не требует
        добавления
        к имени переменной какого-либо символа.</p>
    <h3 id="5.2.5">5.2.5 Передача массивов в качестве параметров</h3>
    <p>Одним из наиболее распространенных способов использования указателей является передача в качестве адреса имени
        массива. При использовании в качестве параметра массива в функцию передается указатель на его первый элемент,
        иными
        словами массив всегда передается по адресу.</p>
    <p>Например, для суммирования компонент вектора можно воспользоваться следующей функцией:</p>
    <pre class="cpp-code"><code class="language-cpp">int sum_v(int* a, int n){
	int j, s = 0;
	for (j = 0; j < n; j++)
		s += a[j];
	return s;
}</code></pre>
    <p>Обращение к такой функции может выглядеть следующим образом:</p>
    <pre class="cpp-code"><code class="language-cpp">int q[20];
k1 = sum_v(q, 20); //суммирование всех компонент вектора
k2 = sum_v(q, 10);  //суммирование первых 10 компонент вектора
k3 = sum_v(&q[5], 3); //суммирование q[5]+q[6]+q[7]
k4 = sum_v(q + 5, 3); //суммирование q[5]+q[6]+q[7]</code></pre>
    <p>Имя массива одновременно является и указателем на его первый элемент (т.е. q и &q[0] &#8211; это одно и то
        же).</p>
    <p>При этом информация о количестве элементов массива теряется, и следует передавать его размерность через отдельный
        параметр:</p>
    <pre class="cpp-code"><code class="language-cpp">#include &ltiostream>
using namespace std;
int sum(const int* mas, const int n);
int const n = 10;
int main(){
	setlocale(LC_ALL, "rus");
	int marks[n] = { 3, 4, 5, 4, 4 };
	cout << "Сумма элементов массива: " << sum(marks, n);
	return 0;
}
int sum(const int* mas, const int n){
	// варианты: int sum(int mas[], int n)
	// или int sum(int mas[n], int n)
	// (величина n должна быть константой)
	int s = 0;
	for (int i = 0; i < n; i++) s += mas[i];
	return s;
}</code></pre>
    <p>При передаче многомерных массивов все размерности, если они неизвестны на этапе компиляции, должны передаваться
        в
        качестве параметров. Внутри функции массив интерпретируется как одномерный, а его индекс пересчитывается в
        программе. В приведенном ниже примере с помощью функции подсчитывается сумма элементов двух двумерных
        массивов.</p>
    <pre class="cpp-code"><code class="language-cpp">#include &ltiostream>
using namespace std;
int sum(int** a, const int nstr, const int nstb);
int main(){
    int nstr, nstb;
    cin >> nstr >> nstb;
    int** a, i, j;
    // Формирование матрицы a
    a = new int* [nstr];
    for (i = 0; i < nstr; i++)
        a[i] = new int[nstb];
    for (i = 0; i < nstr; i++)
        for (j = 0; j < nstb; j++)cin >> a[i][j];
    cout << sum(a, nstr, nstb);
    return 0;
}
int sum(int** a, const int nstr, const int nstb){
    int i, j, s = 0;
    for (i = 0; i < nstr; i++)
        for (j = 0; j < nstb; j++)s += a[i][j];
    return s;
}</code></pre>
    <p>В этом случае память выделяется в два этапа: сначала под столбец указателей на строки матрицы, а затем в цикле
        под
        каждую строку. Освобождение памяти должно выполняться в обратном порядке.</p>
    <h3 id="5.3">5.3 Функции с переменным количеством аргументов</h3>
    <p>Постоянная работа с функциями типа printf или scanf вызывает у программистов зависть &#8211; это же функции с
        переменным
        количеством аргументов. А как написать свою функцию, обрабатывающую столько параметров, сколько будет задано в
        обращении, и, естественно, допускающую задание разного количества аргументов.</p>
    <p>Если мы собираемся сообщать функции количество передаваемых ей аргументов, то заголовок функции можно оформить
        следующим образом:</p>
    <pre class="cpp-code"><code class="language-cpp">double mid_var(int n, ...)</code></pre>
    <p>Три точки в конце списка предупреждают компилятор о том, что он не должен контролировать количество и типы
        следующих
        аргументов. Все заботы о доступе к списку параметров переменной длины берет на себя вызываемая функция.
        Предположим
        далее, что все аргументы передаются в функцию mid_var как значения, т. е. к моменту передачи управления функции
        они
        находятся в стеке. Добраться до них можно следующим образом: заведем указатель типа int и занесем в него адрес
        формального параметра n (система знает, где находится стек, и адрес n ей доступен):</p>
    <pre class="cpp-code"><code class="language-cpp">int *ip=&amp;n;</code></pre>
    <p>Продвинем указатель ip на 1, т. е. переместимся на адрес начала следующего параметра, и занесем его в новый
        указатель
        dp уже типа double:</p>
    <pre class="cpp-code"><code class="language-cpp">ip++;	//переход на адрес первого слагаемого
double *dp=(double *)ip; 	// преобразование типа указателя
</code></pre>
    <p>Теперь адрес начала списка слагаемых у нас есть, количество слагаемых мы тоже знаем, поэтому все остальное
        &#8211;
        дело
        техники. Окончательный вид функции таков:</p>
    <pre class="cpp-code"><code class="language-cpp">double mid_var(int n, ...){
    int* ip = &n + 1;
    double* dp = (double*)ip;
    double s = 0.;
    for (int j = 0; j < n; j++)
        s += dp[j];
    //или s += *(dp+j); или s += *(dp++);
    return s / n;
}</code></pre>
    <p>Теперь попытаемся построить аналогичную функцию, которая суммирует свои аргументы до тех пор, пока не встречает
        нулевое слагаемое. Она устроена еще проще:</p>
    <pre class="cpp-code"><code class="language-cpp">double mid_var(double a1, ...){
    double* dp = &amp;a1;
    double s = 0;
    int c = 0;
    while (*dp != 0){
        s += *(dp++); c++;
    }
    return s / c;
}</code></pre>
    <p>Аналогичные функции можно построить, когда список передаваемых параметров состоит из переменного количества
        однотипных указателей. Только здесь придется использовать не просто указатели типа *dp, а «двойные» указатели
        типа
        **dp. И доставать значения нужных данных придется также через двойные указатели s += (**dp);.</p>
    <h3 id="5.4">5.4 Локальные, глобальные переменные</h3>
    <p>Следует отметить, что все величины, описанные внутри функции, а также ее параметры, являются локальными. Областью
        их
        действия является функция. При вызове функции, как и при входе в любой блок, выделяется память под локальные
        переменные. При выходе из функции соответствующий участок освобождается, поэтому значения локальных переменных
        между
        вызовами одной и той же функции не сохраняются.</p>
    <p>К числу локальных переменных следует отнести и формальные параметры функции. Всем им оперативная память
        выделяется в
        момент вызова функции и возвращается системе после завершения работы функции. Если объявление локальной
        переменной
        совмещается с ее инициализацией, то инициализация происходит при каждом вызове функции <a href="source.html#metka13">[14]</a>.</p>
    <p>Переменные, объявленные за пределами всех функций, относятся к разряду глобальных. Для всех функций,
        расположенных в
        этом же программном файле, глобальные переменные общедоступны. Для «чужих» функций, находящихся в других
        программных
        файлах, такие глобальные переменные могут оказаться доступными при соблюдении двух условий:</p>
    <ol>
        <li class="with-a-dash">глобальная переменная объявлена без спецификатора static;</li>
        <li class="with-a-dash">в другом программном файле или в теле «чужой» функции эта переменная упомянута со
            спецификатором extern.
        </li>
    </ol>
    <p>Глобальная переменная, объявленная со спецификатором static, доступна только для функций данного программного
        файла.</p>
        <p>На видео 11 представлена лекция по областям видимости переменных.</p>
    <video controls="controls" poster="./img/video.jpg" src="./video/video_11_l.mp4"></video>
    <p class="signature">Видео 11 &#8211; Области видимости переменных</p>
    <h3 id="5.5">5.5 Прототипы функций</h3>
    <p>Далее рассмотрим работу с прототипом функции. Прототип &#8211; это запись функции без тела функции. Тело функции
        записывается уже после ее вызова, например, после функции main.</p>
    <p>Далее представлен пример использования прототипов для функций perimetr, modul:</p>
    <pre class="cpp-code"><code class="language-cpp">#include &ltiostream>
#include &ltstdio.h>
using namespace std;
float perimetr(float, float); // описание прототипов функций
void modul(short);     // перед функцией main
int main(){
	setlocale(LC_ALL, "rus");
	modul(-3);
	cout << perimetr(2, 3) << endl;
	return 0;
}
void modul(short x){
	// тело функции modul, записана реализация функции, после функции main
	if (x < 0) x = -x;
	cout << x < endl;
}
float perimetr(float a, float b){
	// тело функции perimetr
	float res = 2 * (a + b);
	return res;
}</code></pre>
    <p>Результат работы данной программы представлен на рисунке 5.4.</p>
    <p class="photo"><img src="./img/5_chapter/5.4.png" alt=""></p>
    <p class="signature">Рисунок 5.4 &#8211; Работа с прототипами функций</p>
    <p>Как видно на рисунке 5.4, программа вычислила модуль числа и периметр прямоугольника со сторонами 2 и 3. Следует
        отметить, что в прототипах необязательно записывать имена аргументов, достаточно лишь указание их тип:</p>
    <pre class="cpp-code"><code class="language-cpp">float perimetr(float, float);</code></pre>
    <p>Использование прототипов имеет две причины. Во-первых, когда программа достаточно большая, удобно в одном месте
        записать список функций, а в другом месте их реализацию. Так программисту будет удобнее в них ориентироваться и
        вносить правки.</p>
    <p>И второй момент &#8211; это подключение библиотек. Например, когда подключается библиотека #include
        &ltstdio.h>, то в этом файле stdio.h прописан только прототип функции, а их реализация находится в другом файле,
        который имеет расширение lib. Благодаря тому, что в начале программы подключается прототип, например, функция
        sprintf там определена, функцию sprintf можно использовать в функции main. А когда программа компилируется, то
        компилятор берет реализацию функции sprintf из библиотечного файла и подключает к проекту. Таким образом,
        благодаря прототипам происходит подключение библиотек.</p>
    <h3 id="5.6">5.6 Перегрузка функций</h3>
    <p>Следующий важный момент при работе с функциями &#8211; это их перегрузка. Перегрузка позволяет создавать
        несколько
        функций
        с одним и тем же именем, но с разными входными типами аргументов.</p>
    <p>Например, в следующем коде программы используется вычисление модуля числа для целочисленных переменных и точно
        такая
        же функция с таким же именем, но для вещественных чисел, a уже внутри функции main:</p>
    <pre class="cpp-code"><code class="language-cpp">#include &ltiostream>
using namespace std;
int modul(int x){
    if (x < 0) x = -x;
    return x;
}
double modul(double x){
    if (x < 0) x = -x;
    return x;
}
int main(){
    setlocale(LC_ALL, "rus");
    // вызов функций в зависимости от входного типа аргументов, целочисленная функция
    int a1 = modul(-3);
    // вызов функций в зависимости от входного типа аргументов, вещественная функция
    int a2 = modul(-3.5);
    double a3 = modul(-3);
    double a4 = modul(-3.5);
    cout << a1 << " " << a2 << " " << a3 << " " << a4 << " " << endl;
    return 0;
}</code></pre>
    <p>Следует отметить, что если использовать одну функцию для обработки и целочисленных и вещественных данных, то
        обработка вещественных данных требует больше машинного времени. А один из критериев создания программ
        заключается в
        том, чтобы программа работала как можно быстрее, поэтому лучше использовать перегрузку функций.</p>
    <h3 id="5.7">5.7 Рекурсия</h3>
    <p>Определения функций не могут быть вложенными, т. е. нельзя внутри тела одной функции определить тело другой.
        Разумеется, можно вызвать одну функцию из другой. В том числе функция может вызвать сама себя.</p>
    <p>Рассмотрим функцию вычисления факториала целого числа. Ее можно реализовать двумя способами. Первый способ
        использует
        итерацию:</p>
    <pre class="cpp-code"><code class="language-cpp">int fact(int n){
    int result = 1;
    for (int i = 1; i <= n; i++)
        result = result * i;
    return result;
}</code></pre>
    <p>Второй способ вычисления факториала целого числа:</p>
    <pre class="cpp-code"><code class="language-cpp">int fact(int n){
    if (n == 0 || n == 1) // факториал 1 равен 1
        return 1;
    else  // факториал числа n равен факториалу n-1, умноженному на n
        return n * fact(n - 1);
}</code></pre>
    <p>Функция fact вызывает сама себя с модифицированными аргументами. Такой способ вычислений называется рекурсией.
        Рекурсия &#8211; это очень мощный метод вычислений. Значительная часть математических функций определяется в
        рекурсивных
        терминах. В программировании алгоритмы обработки сложных структур данных также часто бывают рекурсивными.</p>
    <p>Пример рекурсивной функции (вызывающей саму себя):</p>
    <pre class="cpp-code"><code class="language-cpp">#include &ltiostream>
using namespace std;
void up_and_down(int n)
	// объявление рекурсивной функции{
	cout << "Уровень вниз " << n << endl;
	if (n < 4) up_and_down(n + 1);  // внутри тела функции вызов этой же функции
	cout << "Уровень вверх " << n << endl;
}
int main(){
	setlocale(LC_ALL, "rus");
	up_and_down(1);
	return 0;
}</code></pre>
    <p>Результат работы данного программного кода представлен на рисунке 5.5</p>
    <p class="photo"><img src="./img/5_chapter/5.5.png" alt=""></p>
    <p class="signature">Рисунок 5.5 &#8211; Работа с рекурсивными функциями</p>
    <p>В данном примере сначала была вызвана функция main (), затем вызывались следующие функции, пока не будет
        выполнено
        условие выхода из цикла.</p>
    <p class="photo"><img src="./img/5_chapter/5.6.png" alt=""></p>
    <p class="signature">Рисунок 5.6 &#8211; Стек вызова функций</p>
    <h3 id="5.8">5.8 Практические примеры работы с функциями</h3>
    <p>Далее представлены пример работы с функциями для более прочного усвоения материала.</p>
    <p><strong>Пример 1.</strong> Создать функцию вычисления объема прямоугольного параллелепипеда со сторонами a, b и
        c,
        которые передаются
        функции в качестве аргументов. Результат работы функции сохранить в переменной и вывести значение на экран. Код
        для
        реализации этого задания представлен ниже:</p>
    <pre class="cpp-code"><code class="language-cpp">#include &ltiostream>
using namespace std;
double V(double a, double b, double c){
	// дана функция с вещественными аргументами и возвращаемым типом double
	return a * b * c; // внутри функции вычисляется произведение,
    // и возвращается произведение этой функции
}
int main(){
	setlocale(LC_ALL, “rus”);
	double v = V(3, 4, 5); // вызываем эту функцию,
	//функция вызывается по ее имени, а затем в () значение аргументов а, b, c
	printf(“V = % 1f\n”, v); // то значение, которое вернула функция,
	//мы сохранили в переменой v и далее вывели ее на экран с помощью этой функции
	return 0;
}</code></pre>
    <p>Результат выполнения данного программного кода представлен на рисунке 5.7.</p>
    <p class="photo"><img src="./img/5_chapter/5.7.png" alt=""></p>
    <p class="signature">Рисунок 5.7 &#8211; Результат выполнения вычисления объёма прямоугольника</p>
    <p><strong>Пример 2.</strong> Дан двумерный массив размерностью 10х10, заполненный пробелами. Нужно написать функцию
        случайной
        расстановки в этом массиве 10 мин (символ *) так, чтобы соседние мины не соприкасались между собой. Результат
        вывести на экран. Реализация данного примера приведена в следующем коде:</p>
    <pre class="cpp-code"><code class="language-cpp">#include &ltiostream>
using namespace std;
const int N = 10;
const int M = 11;
char P[N][N];
bool isEmpty(int x, int y){
	//у заданной функции два аргумента, возвращаемое значение bool
	for (int i = -1; i <= 1; ++i){ //далее идут два цикла,
	//которые перебирают все клетки вокруг точки с координатами x и y
		for (int j = -1; j <= 1; ++j){
			int xx = i + x; //формируем новые координаты,
			//в которых мы проверяем, есть мины или нет
			int yy = j + y;
			if (xx < 0 || xx > N - 1 || yy < 0 || yy > N - 1) continue;
			//далее мы также должны проверить, не выходят ли координаты xx и yy
			//за пределы нашего поля, то есть за пределы 0 и n-1,
			//а если хотя бы одна из координат выходит, то мы пропускаем следующую операцию,
			//и цикл продолжается, если все-таки эти координаты принадлежат нашему полю,
			//то мы проверяем, есть ли там мина(*), если есть хотя бы одна *, то мы возвращаем false
			if (P[xx][yy] == 255)
				return false;
		}
		return true;
	}
}
void setMines(){
	//функция, которая в поле 10 на 10 расставляет мины
	int n = 0; //внутри функции идет счетчик расставленных мин
	do{
	//далее цикл do...while, который идет до тех пор, пока мы не расставим все 10 мин
		int x = rand() % M; //внутри цикла мы генерируем координаты, случайные параметры x и y,
		//то есть клетка, в которую мы будем ставить мину
		int y = rand() % M;
		if (!isEmpty(x, y)) continue; //далее вызывается функция, которая проверяет,
		// а есть ли вокруг точки с координатами x, y какие-либо мины.
		//Если окажется, что вокруг есть хотя бы одна мина, то сработает оператор continue,
		//и две следующие точки работать не будут
		P[x][y] = 42;
		n++;
	} while (n < M); // константа M равна 10, число мин, которые мы должны расставить
}
int main(){
	for (int i = 0; i < N; ++i) //делаем цикл, где делаем пробелы в нашем поле Р
		for (int j = 0; j < N; ++j)
			P[i][j] = 255;
	setMines();
	for (int i = 0; i < N; ++i){
	//выводится наше сгенерированное поле в консоли
		for (int j = 0; j < N; ++j)
			printf(" % c ", P[i][j]);
		putchar('\n');
		return 0;
	}
}</code></pre>
    <p>Результат выполнения данного программного кода представлен на рисунке 5.8.</p>
    <p class="photo"><img src="./img/5_chapter/5.8.png" alt=""></p>
    <p class="signature">Рисунок 5.8 &#8211; Результат функции для расстановки мин</p>
    <p><strong>Пример 3.</strong> С помощью рекурсивной функции вычислить факториал числа n, используя рекуррентное
        выражение:</p>
    <p class="photo"><img src="./img/5_chapter/(5.1).png" alt="">(5.1)</p>
    <p>Результат вычисления сохранить в переменной и вывести на экран.</p>
    <p>Решение данного примера представлено в следующем коде:</p>
    <pre class="cpp-code"><code class="language-cpp">#include &ltiostream>
using namespace std;
int fact(int n){
	//задаем рекуррентную функцию fact, у которой один входной аргумент,
	//то есть то число, факториал которого нужно вычесть
	if (0 == n) return 1; //делается проверка, а именно равна ли n нулю,
	//и если n равна нулю, то мы возвращаем один, и на этом функция завершатся,
	//а если n больше нуля, то мы вызываем функцию fact
	return fact(n - 1) * n;
}
int main(){
	setlocale(LC_ALL, "rus");
	int n; //вводим это целое значение n
	printf("Введите целое число:");
	scanf_s("%d", &n);
	n = (n < 0) ? -n : n; // так как число должно быть целым и положительным,
	//то мы здесь проверяем и делаем его положительным
	int res = fact(n); //вызываем непосредственно эту рекурсивную функцию fact
	printf("n! = %d\n", res); // выводим результат на экран
	return 0;
}</code></pre>
    <p>Результат выполнения данного программного кода представлен на рисунке 5.9.</p>
    <p class="photo"><img src="./img/5_chapter/5.9.png" alt=""></p>
    <p class="signature">Рисунок 5.9 &#8211; Пример реализации функции</p>
    <p><strong>Пример 4.</strong> С помощью рекурсивной функции возвести число x в целую положительную степень n,
        используя
        рекуррентное выражение:</p>
    <p class="photo"><img src="./img/5_chapter/(5.2).png" alt="">(5.2)</p>
    <p>Результат вычисления сохранить в переменной и вывести на экран.</p>
    <p>Далее представлено решение данного примера:</p>
    <pre class="cpp-code"><code class="language-cpp">#include &ltiostream>
using namespace std;
double power(double a, int n){
	//рекурсивная функция power c двумя аргументами
	if (0 == n) return 1; //проверка, если n равна нулю, то получаем единицу
	if (1 == n % 2) //проверка, если n – нечетная,
		//то мы вызываем функцию power со значением степени n-1 и умноженную на a,
		//в результате мы получим а в степени n, если n четная, то мы возводим а в квадрат
		//и степень делим сразу пополам
		return power(a, n - 1) * a;
	else
		return power(a * a, n / 2);
}
int main(){
	setlocale(LC_ALL, "rus");
	double x; //вводим число
	int n; //и степень, в которую мы будем его возводить
	printf("Введите число х и его степень: ");
		scanf_s("%lf %d", &x, &n);
	n = (n < 0) ? -n : n; //делаем степень всегда положительной
	double res = power(x, n); // вызываем нашу рекурсивную функцию power с аргументами x и n
	printf("x ^ n = % 1f\n", res);
	return 0;
}</code></pre>
    <p>Результат выполнения данного программного кода представлен на рисунке 5.10.</p>
    <p class="photo"><img src="./img/5_chapter/5.10.png" alt=""></p>
    <p class="signature">Рисунок 5.10 &#8211; Пример реализация функции</p>
    <p>
        <stong>Пример 5.</stong>
        С помощью рекурсивной функции вычислить число Фибоначчи для заданного натурального n>1, используя
        рекуррентное выражение:
    </p>
    <p class="photo"><img src="./img/5_chapter/(5.3).png" alt="">(5.3)</p>
    <p>Результат вычисления сохранить в переменной и вывести на экран.</p>
    <p>Далее представлено решение данного примера:</p>
    <pre class="cpp-code"><code class="language-cpp">#include &ltiostream>
using namespace std;
int fib(int n){
	//задаем рекурсивную функцию fib и ее один входной аргумент
	if (n < 2) return n; //если n меньше двух, то мы просто возвращаем n
	return fib(n - 1) + fib(n - 2); //иначе его рассчитываем таким образом
}
int main(){
	setlocale(LC_ALL, "rus");
	int n; //вводим это n с клавиатуры, делаем его положительным
	printf("Введите натуральное число: ");
	scanf_s("%d", &n);
	n - (n < 0) ? -n : n;
	int res = fib(n); //вычисляем непосредственно это число Фибоначчи
	printf("fib = %d\n", res); //выводим его на экран
	return 0;
}</code></pre>
    <p>Результат выполнения данного программного кода представлен на рисунке 5.11.</p>
    <p class="photo"><img src="./img/5_chapter/5.11.png" alt=""></p>
    <p class="signature">Рисунок 5.11 &#8211; Результат выполнения данной функции</p>
    <p><strong>Пример 6.</strong> Написать перегрузку функций для вычисления площади круга с целочисленным и
        вещественным
        радиусами. Вызвать
        функцию с разными типами аргументов и вывести результат на экран.</p>
    <p>Далее представлено решение данного примера:</p>
    <pre class="cpp-code"><code class="language-cpp">#include &ltiostream>
using namespace std;
#define PI 3.1415
double sqCircle(double R){
	return PI * R * R;
}
double sqcircle(int R){
	return PI * R * R;
}
int main(){
	setlocale(LC_ALL, "rus");
	double S1 = sqCircle(5.6);
	double S2 = sqCircle(5);
	printf("S1 = %.2f, S2 = %.2f\n", S1, S2);
}</code></pre>
    <p>Результат выполнения данного программного кода представлен на рисунке 5.12.</p>
    <p class="photo"><img src="./img/5_chapter/5.12.png" alt=""></p>
    <p class="signature">Рисунок 5.12 &#8211; Результат работы функции</p>
    <p><strong>Пример 7.</strong> Задать функцию для отображения и выбора пункта такого меню:</p>
    <ol>
        <li class="with-a-bracket">добавление сотрудника в БД;</li>
        <li class="with-a-bracket">удаление сотрудника из БД;</li>
        <li class="with-a-bracket">поиск сотрудника;</li>
        <li class="with-a-bracket">выход из программы.</li>
    </ol>
    <p>Функция должна возвращать результат действия пользователя. Вызвать функцию и продемонстрировать ее работу.</p>
    <p>Далее представлено решение данного примера:</p>
    <pre class="cpp-code"><code class="language-cpp">#include &ltiostream>
using namespace std;
int showMenu(){
	// функция, которая будет отображать наше меню или просить пользователя ввести тот или иной пункт
	int  item = -1; //изначально переменная равна -1, что означает, что ни один из пунктов не выбран
	printf("1. Добавление сотрудника в БД\n 2. Удаление сотрудника из БД \n\
    3. Поиск сотрудника \n 4. Выход из программы\n\n");
	//отображает меню на экране
	scanf_s("%d", &item); //функция просит пользователя ввести тот или иной пункт
	return item;
}
int main(){
	setlocale(LC_ALL, "rus");
	int n = showMenu(); //вызываем эту функцию, сохраняем результат в переменной n
	printf("Выбран % d - й пункт меню\n", n); // с помощью этой функции отображаем ее на экране
		return 0;
}</code></pre>
    <p>Результат выполнения данного программного кода представлен на рисунке 5.13.</p>
    <p class="photo"><img src="./img/5_chapter/5.13.png" alt=""></p>
    <p class="signature">Рисунок 5.13 &#8211; Пример реализации функции</p>
    <p><strong>Пример 8.</strong> Написать функцию, которая бы вычисляла или площадь прямоугольника, или его периметр в
        зависимости от
        значения некоторого аргумента, заданного по умолчанию у этой функции. Функция должна принимать ширину и длину
        прямоугольника в качестве входных параметров и возвращать вычисленный результат.</p>
    <p>Далее представлено решение данного примера:</p>
    <pre class="cpp-code"><code class="language-cpp">#include &ltiostream>
using namespace std;
#define SQ 1 //задаем две константы
#define PER 2
double sq_per(double width, double height, short type = SQ){
	// у этой функции два аргумента, а  последним записан аргумент по умолчанию,
	//который строго должен находиться в конце
	if (type == SQ) return width * height; //внутри самой функции мы проверяем значение type,
	//если равен SQ – вычисляем площадь, а если PER - периметр
	if (type == PER) return 2 * (width + height);
	return 0;
}
int main(){
	setlocale(LC_ALL, "rus");
	double res1 = sq_per(2, 3); //делаем вызов без третьего элемента, т.е. будем вычислять площадь
	double res2 = sq_per(2, 3, PER); //будем вычислять периметр
	printf("res1 = %lf\nres2 = %lf\n", res1, res2); //выводим полученные значения
	return 0;
}</code></pre>
    <p>Результат выполнения данного программного кода представлен на рисунке 5.14.</p>
    <p class="photo"><img src="./img/5_chapter/5.14.png" alt=""></p>
    <p class="signature">Рисунок 5.14 &#8211; Пример реализации функции</p>
    <p><strong>Пример 9.</strong> Записать функцию, которая с вероятность р отображала бы в консоли строчку «произошло
        случайное событие». Вызвать эту функцию 100 раз.</p>
    <p>Далее представлено решение данного примера:</p>
    <pre class="cpp-code"><code class="language-cpp">#include &ltiostream>
using namespace std;
void probably(double p){
	//у данной функции в качестве аргумента идет та самая вероятность, с которой мы будем работать
	double a = rand(); //генерируем некоторое случайное число в диапазоне от 0 до RAND_MAX
	a /= RAND_MAX; //делим сгенерированное число на константу, в результате получаем,
	//что а находится в диапазоне от 0 до 1 и будет вещественным
	if (a < p) puts("Произошло случайное событие");
}  // сравниваем: а меньше, чем эта вероятность р, если это так, то мы отображаем «произошло случайное событие»
int main(){
	setlocale(LC_ALL, "rus");
	for (int i = 0; i < 100; ++i)  //вызываем эту функцию 100 раз
		probably(0.3); //с параметром значений вероятности 0.3
	return 0;
}</code></pre>
    <p>Результат выполнения данного программного кода представлен на рисунке 5.15.</p>
    <p class="photo"><img src="./img/5_chapter/5.15.png" alt=""></p>
    <p class="signature">Рисунок 5.15 &#8211; Пример реализации функции</p>
    <p><strong>Пример 10.</strong> Дан двумерный массив размерностью 3х3, который содержит символы 'х' и 'о' латинского
        алфавита. Написать
        функцию проверки выигрышной ситуации при игре в крестики-нолики или одним, или другим игроком. Вызвать эту
        функцию и
        проверить ее работоспособность.</p>
    <p>Далее представлено решение данного примера:</p>
    <pre class="cpp-code"><code class="language-cpp">#include &ltiostream>
using namespace std;
#define N 3 //задаем константу, равную 3
char P[N][N] = { {'x', 'o', 'o'}, {'o', 'x', 'o'}, {'x', 'x', 'o'} };
//определяем нашу главную переменную, в которой будут храниться крестики и нолики
short isWin(){
	//формируем функцию, которая будет возвращать некоторое число,
	//если выведет 1, то победил игрок, играющий крестиком, а если 2, то играющий ноликом
	bool all_x1 = true, all_x2 = true; //далее начинаем проверять, кто у нас выиграет
	bool all_o1 = true, all_o2 = true;
	for (int i = 0; i < N; ++i){
		// в этом цикле проверяем выигрышные ситуации по вертикали и по горизонтали
		bool all_x_h = true, all_x_v = true;
		bool all_o_h = true, all_o_v = true;
		for (int j = 0; j < N; ++j){
			//внутри данного цикла пробегаем соответствующую i-ую строку или столбец
			all_x_h = all_x_h && (P[i][j] == 'x');
			//если хотя бы один раз конструкция (P[i][j] == 'x') не сработает, вся конструкция станет ложной
			all_o_h = all_o_h && (P[i][j]) == 'o');
			all_x_h = all_x_v && (P[i][j] == 'x');
			all_o_h = all_o_v && (P[i][j]) == 'o');
		}
		if (all_x_h || all_x_v) return 1; //можем проверить, является ли выигрышная ситуация для крестика:
		//если да, то возвращаем 1, аналогично и для нолика
		if (all_o_h || all_o_v) return 2;
		all_x1 = all_x1 && (P[i][i] == 'x'); //если предыдущие условия не сработали,
		//то программа переходит сюда и уже проверяет выигрышные ситуации по диагонали
		all_o1 = all_01 && (P[i][i] == 'o');
		all_x2 = all_x2 && (P[N - i - 1][i] == 'x'); //проверка для обратной диагонали
		all_o2 = all_02 && (P[N - i - 1][i] == 'o');
	}
	if (all_x1 || all_x2) return 1;
	if (all_o1 || all_o2) return 2;
	return 0;
}
int main(){
	setlocale(LC_ALL, "rus");
	printf("Значение isWin = % d\n", isWin());
	return 0;
}</code></pre>
    <p>Результат выполнения данного программного кода представлен на рисунке 5.16.</p>
    <p class="photo"><img src="./img/5_chapter/5.16.png" alt=""></p>
    <p class="signature">Рисунок 5.16 &#8211; Пример реализации функции</p>
    <p>На видео 12 представлена подробная лекция по функциям прототипы, перегрузка и рекурсии.</p>
    <video controls="controls" poster="./img/video.jpg" src="./video/video_12_l.mp4"></video>
    <p class="signature">Видео 12 &#8211; Функции: прототипы, перегрузка, рекурсия</p>
    <h3 id="5.9">5.9 Контрольные вопросы для закрепления изученного материала</h3>
    <ol>
        <li class="with-a-bracket">Что представляет собой функция?</li>
        <li class="with-a-bracket">С какой целью используются прототипы?</li>
        <li class="with-a-bracket">С какой целью в типе функции используется void?</li>
        <li class="with-a-bracket">Как осуществляется обращение к функции?</li>
        <li class="with-a-bracket">В чем заключается отличие формальных параметров функции от фактических?</li>
    </ol>
</script>

<script id="page5.10" type="text/html">
    <TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0>
        <TR>
            <TD width="50%"><a name="3"></a>
                <HR>
                <div align=justify><h1>Тренировочные упражнения</h1></div>
  <form>
   <ol> 
   	<li class="without-parentheses"> Заполните пропуски синтаксиса для объявления функций в языке программирования С++
   	 <pre class="cpp-code"><code class="language-cpp">
<тип> <<input type="text" id="glav5_1_1" size="3">функции> ([список <input type="text" id="glav5_1_2" size="7">]) {<тело <input type="text" id="glav5_1_3" size="7">>}
</code></pre>  
              <input type="button" value="Ответить" class="proverit_glav_5_1"></input>
              <input type="reset" value ="Очистить"></input>
              <br><br>
                 <div id="resultat_5_1"></div>
                  </form>
              </li><br><br>
<form>

<li class="without-parentheses"> Заполнить пропуски в коде, чтобы программа вычисляла или площадь прямоугольника, или его периметр в зависимости значения некоторого аргумента, заданного по умолчанию 
	 <pre class="cpp-code"><code class="language-cpp">
#include &ltiostream>
using namespace std;
#define SQ 1 //задаем две константы
#define PER 2
double sq_per(double width, double <input type="text" id="glav5_2_1" size="3">, short type = SQ){
	// у этой функции два аргумента, а  последним записан аргумент по умолчанию,
	//который строго должен находиться в конце
	if (type == SQ) return <input type="text" id="glav5_2_2" size="3">* height; //внутри самой функции мы проверяем значение type,
	//если равен SQ – вычисляем площадь, а если PER - периметр
	if (type == PER) return 2 * (width + height);
	return 0;
}
int main(){
	setlocale(LC_ALL, "rus");
	double res1 = <input type="text" id="glav5_2_3" size="3">(6, 9); //делаем вызов без третьего элемента, т.е. будем вычислять площадь
	double <input type="text" id="glav5_2_4" size="3"> = sq_per(6, 9, PER); //будем вычислять периметр
	printf("res1 = %lf\nres2 = %lf\n", <input type="text" id="glav5_2_5" size="3">, res2); //выводим полученные значения
	return 0;
}
</code></pre>  
  <input type="button" value="Ответить" class="proverit_glav_5_2"></input>
              <input type="reset" value ="Очистить"></input>
              <br><br>
                 <div id="resultat_5_2"></div>
 	 </form>  </li>
      </ol>
 </HR></TD></TR></TABLE>
</script> 

<script id="page5.11" type="text/html">
    <TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0>
        <TR>
            <TD width="50%"><a name="3"></a>
                <HR>
                <div align=justify><h1 align="center">Тестирование по пятой главе</h1></div>
                <form name=test>
                    <ol>
                        <li>
                            <h4><input type=text name=T1 style="height: 15px; width:15px;" value=''> Отметьте допустимое
                                имя
                                функции:</h4>
                            <input type=radio name=Q1> _ThisFunction_12_x_;<br>
                            <input type=radio name=Q1> ax%u7;<br>
                            <input type=radio name=Q1> fffffffAAAAAA;<br>
                            <input type=radio name=Q1> 3_pi;<br>
                            <input type=radio name=Q1> thisname_is_too?long_forafunction.<br>
                            <br>
                        </li>
                        <li>
                            <h4><input type=text name=T2 style="height: 15px; width:15px;" value=''> Если в функции на
                                языке
                                С++ отсутствует оператор
                                return, то такая функция:</h4>
                            <input type=radio name=Q2> не будет возвращать значения;<br>
                            <input type=radio name=Q2> будет возвращать значение 1;<br>
                            <input type=radio name=Q2> будет возвращать значение 0;<br>
                            <input type=radio name=Q2> будет возвращать значение 10;<br>
                            <input type=radio name=Q2> нет верного ответа.<br>
                            <br>
                        </li>
                        <li>
                            <h4><input type=text name=T3 style="height: 15px; width:15px;" value=''> Прототипом функции
                                называется:</h4>
                            <input type=radio name=Q3> словесное описание действий функции;<br>
                            <input type=radio name=Q3> перечень переменных, объявленных в функции;<br>
                            <input type=radio name=Q3> заголовок функции без ее тела, оканчивающийся символом ‘;’;<br>
                            <input type=radio name=Q3> вложенная функция;<br>
                            <input type=radio name=Q3> нет верного ответа.<br>
                            <br>
                        </li>
                        <li>
                            <h4><input type=text name=T4 style="height: 15px; width:15px;" value=''> В языке С++:</h4>
                            <input type=radio name=Q4> имеется понятие «вложенной» функции;<br>
                            <input type=radio name=Q4> отсутствует понятие «вложенной» функции;<br>
                            <input type=radio name=Q4> можно описывать вложенные функции при установке соответствующих
                            директив компилятора;<br>
                            <input type=radio name=Q4> нельзя описывать вложенные функции при установке соответствующих
                            директив компилятора;<br>
                            <input type=radio name=Q4> нет верного ответа.<br>
                            <br>
                        </li>
                        <li>
                            <h4><input type=text name=T5 style="height: 15px; width:15px;" value=''> Перегруженные
                                функции
                                применяются тогда, когда:</h4>
                            <input type=radio name=Q5> необходимо смоделировать вложенность функций;<br>
                            <input type=radio name=Q5> функция должна выполнять различные действия в зависимости от типа
                            и
                            количества ее параметров;<br>
                            <input type=radio name=Q5> нужно объявить глобальную функцию;<br>
                            <input type=radio name=Q5> работают с рекурсией;<br>
                            <input type=radio name=Q5> нет верного ответа.<br>
                            <br>
                        </li>
                        <li>
                            <h4><input type=text name=T6 style="height: 15px; width:15px;" value=''> Список параметров
                                функции описан как "void". Что можно сказать о параметрах этой функции?</h4>
                            <input type=radio name=Q6> аргумент может быть только константой;<br>
                            <input type=radio name=Q6> у функции нет параметров;<br>
                            <input type=radio name=Q6> аргумент может быть только переменной;<br>
                            <input type=radio name=Q6> аргумент может быть выражением любого типа;<br>
                            <input type=radio name=Q6> нет верного ответа.<br>
                            <br>
                        </li>
                        <li>
                            <h4><input type=text name=T7 style="height: 15px; width:15px;" value=''> Выберите ложное
                                утверждение:</h4>
                            <input type=radio name=Q7> локальные переменные существуют только во время выполнения
                            функции;<br>
                            <input type=radio name=Q7> для параметров, передаваемых по значению, в стеке создается их
                            копия;<br>
                            <input type=radio name=Q7> функция может возвращать значение стандартного типа;<br>
                            <input type=radio name=Q7> компилятор инициализирует нулями локальные переменные;<br>
                            <input type=radio name=Q7> нет правильных утверждений.<br>
                            <br>
                        </li>
                        <li>
                            <h4><input type=text name=T8 style="height: 15px; width:15px;" value=''> Что здесь является
                                именем функции?</h4>
                            <pre class="cpp-code"><code
                                    class="language-cpp">void showMenu(string category){}</code></pre>
                            <input type=radio name=Q8> void;<br>
                            <input type=radio name=Q8> showMenu;<br>
                            <input type=radio name=Q8> string;<br>
                            <input type=radio name=Q8> category;<br>
                            <input type=radio name=Q8> нет правильного ответа.<br>
                            <br>
                        </li>
                        <li>
                            <h4><input type=text name=T9 style="height: 15px; width:15px;" value=''> Какое минимальное
                                количество функций необходимо для программы, написанной на языке C++?</h4>
                            <input type=radio name=Q9> 1;<br>
                            <input type=radio name=Q9> 2;<br>
                            <input type=radio name=Q9> 3;<br>
                            <input type=radio name=Q9> 0;<br>
                            <input type=radio name=Q9> нет правильного ответа.<br>
                            <br>
                        </li>
                        <li>
                            <h4><input type=text name=T10 style="height: 15px; width:15px;" value=''> Величины,
                                описанные
                                внутри функции, а также ее параметры, являются:</h4>
                            <input type=radio name=Q10> глобальные;<br>
                            <input type=radio name=Q10> локальные;<br>
                            <input type=radio name=Q10> статические величины;<br>
                            <input type=radio name=Q10> нет правильного ответа;<br>
                            <input type=radio name=Q10> переменные области класса.<br>
                            <br>
                        </li>
                    </ol>
                    <div align="center">
                        <div>
                            <input type=button value="Показать результат" onClick="test1('MTMzMTIyNDIxMg', 10)">
                        </div>
                        <div>
                            <textarea style="margin-top:6px" rows=5 cols="100%" name=s1></textarea>
                        </div>
                        <div>
                            <input type=reset value="Очистить выбранные пункты">
                        </div>
                        <br>
                        <Div align=center>
                            <a href="#3">В начало страницы</a>
                        </div>
                        <br>
                    </div>
                </form>
            </TD>
        </TR>
    </TABLE>
</script>

<!-- /page6 -->
<script id="page6" type="text/html">
    <h2 id="6">6 Работа с типами и структурами данных</h2>
    <p>В реальных задачах информация, которую требуется обрабатывать, может иметь достаточно сложную структуру. Для ее
        адекватного представления используются типы данных, построенные на основе простых типов данных, массивов и
        указателей. <a href="glossary.html#m12">Язык С++</a> позволяет программисту определять свои типы данных и правила работы с ними. Исторически для
        таких типов сложилось наименование типы данных, определяемые пользователем, хотя правильнее было бы назвать их
        типами,
        определяемыми программистом.</p>
    <h3 id="6.1">6.1 Структуры в языке С++</h3>
    <p>Структура &#8211; это объединенное в единое целое множество поименованных элементов данных разных типов.
        Компонентами
        структуры могут быть переменные любых типов, массивы, другие структуры, и все должны иметь различные имена.
        Другими
        словами, структуры позволяют представить все разнородные данные как единое целое, т. е. объединить все в единую
        переменную <a href="source.html#metka6">[6]</a>.</p>
    <p>Формат определения структурного типа имеет вид:</p>
    <pre class="cpp-code"><code class="language-cpp">struct [имя структуры] { определения элементов };</code></pre>
    <p>struct &#8211; спецификатор структурного типа;</p>
    <p>имя структуры &#8211; любой идентификатор;</p>
    <p>определения элементов &#8211; совокупность одного или более описаний объектов.</p>
    <p>Данную запись можно представить как:</p>
    <pre class="cpp-code"><code class="language-cpp">struct [имя_типа]{
	тип_1 элемент_1;
	тип_2 элемент_2;
	тип_n элемент_n;
}
[список_описателей];</code></pre>
    <p>Далее представлен пример описания структуры «Товар», который имеет различные элементы:</p>
    <pre class="cpp-code"><code class="language-cpp">struct tovar{
	char name[15];  /* Наименование */
	int price;	 /* Оптовая цена */
	float percent;	 /* Наценка в % */
	int vol;	/* Объем партии */
	char date[10] /* Дата поставки */
};</code></pre>
    <p>Такая запись называется описанием структуры, а переменные, стоящие внутри нее, называются переменными. После
        определения структуры принято ставить точку с запятой, хотя некоторые компиляторы С++ этого не требуют<a href="source.html#metka7">[7]</a>.</p>
    <p>Определения элементов (компонентов) структурного типа подобны определениям данных соответствующего типа. Если
        структурный тип определен и известно его имя, то формат определения конкретных структур имеет вид:</p>
    <pre class="cpp-code"><code class="language-cpp">struct имя структурного типа список структур;</code></pre>
    <p>Далее представлены примеры конкретных товаров, которые будут иметь соответствующие поля, описывающие их
        характеристики:</p>
    <p>Например,
    <pre class="cpp-code"><code class="language-cpp">struct tovar milk, cola, coffee;</code></pre></p>
    <p>Для присвоения значения элементов структур используется два способа. Первый подходит для ситуации, когда
        необходимо
        присвоить значения сразу всем элементам. Далее представлен пример присвоения значения товарам пиджак и чай,
        которые
        получают значения, советующие элементам, заданным в структуре struct.</p>
    <pre class="cpp-code"><code class="language-cpp">struct tovar coat = { “пиджак черный”, 4000, 7.5, 220, “12.11.99” };
tovar tea = { “чай зеленый”, 2500, 6, 100, “25.02.00” };</code></pre>
    <p>Далее рассмотрен еще один пример для работы с данными о студентах. Описана структура Student, которая включает
        фамилию, имя, отчество студента, курс:</p>
    <pre class="cpp-code"><code class="language-cpp">struct students{
	char fam[15];   /* Фамилия */
	char name[10];  /* Имя */
	int kurs;      /* Курс */
}
struct date{
	int day;
	int mes;
	int god;
}</code></pre>
    <p>Ниже описано присвоение значений данной структуре конкретными данными, для Игнатьева Олега, студента первого
        курса:</p>
    <pre class="cpp-code"><code class="language-cpp">students student_1 = { "Игнатьев", "Олег", 1 } ;</code></pre>
    <p>Второй вариант присвоения данных элементам структур заключается в использовании уточненных имен.<a href="glossary.html#m12">Уточненное имя</a> 
        &#8211; это
        выражение с двумя операндами операцией доступа к элементам структуры ('точка') между ними [13].</p>
    <pre class="cpp-code"><code class="language-cpp">имя структуры.имя элемента;</code></pre>
    <p>Например, чтобы присвоить значение фамилии для студента, следует написать:</p>
    <pre class="cpp-code"><code class="language-cpp">students.fam = "Иванов"; </code></pre>
    <p>Доступ к элементам структуры может осуществляться также с помощью указателя, ссылающегося на структуру. При этом
        используется операция «стрелка» (->), имеющая наивысший приоритет. Формат применения данной операции:</p>
    <pre class="cpp-code"><code class="language-cpp">указатель на структуру -> имя элемента</code></pre>
    <p>Например, для структуры рабочий:</p>
    <pre class="cpp-code"><code class="language-cpp">struct Worker{
	// описание нового типа Worker
	char fio[30];
	int date, code;
	double salary;
}</code></pre>
    <p>следует использовать следующую запись:</p>
    <pre class="cpp-code"><code class="language-cpp">worker.fio = "Страусенко";
ps->salary = 0.12;</code></pre>
    <p>Поля разных структур могут иметь одинаковые имена, поскольку у них разная область видимости. Более того, можно
        объявлять в одной области видимости структуру и другой объект с одинаковыми именами.</p>
    <p>Далее представлен пример работы еще с одной структурой &#8211; «Книга»:</p>
    <pre class="cpp-code"><code class="language-cpp">struct tag_book{
char title[100];  //название книги
char author[50]; //автор
short year;      //год издания
short pages;     //число страниц
float price;    //цена
}</code></pre>
    <p>Такое описание структуры представляет собой тип данных, и для этого типа данных можно задать переменную следующим
        образом:</p>
    <ol>
        <li class="with-a-dash">struct tag_book book; //тип данных, а далее имя переменной;</li>
        <li class="with-a-dash">tag_book book; //имя структуры, а далее имя переменной.</li>
    </ol>
    <p>Используя переменную, можно в элементы структуры записывать значения следующим образом:</p>
    <ol>
        <li class="with-a-dash">book.year = 2000; //сначала ставится имя переменной (book), далее идет имя элемента
            структуры, с которым мы будем работать, в результате такая запись будет представлять собой целочисленную
            переменную с типом short;
        </li>
        <li class="with-a-dash">strcpy (book.title, "Евгений Онегин"); //присваиваем строке title значение Евгений
            Онегин.
            Используем команду копирование строки, затем указываем, в какую строку будем копировать. Запись book.title =
            "Евгений Онегин"; недопустима, т. к. это массив, а массиву присваивать строку таким образом нельзя;
        </li>
        <li class="with-a-dash">strcpy (book.author, "Пушкин А.С.");</li>
        <li class="with-a-dash">book.pages = 80;</li>
        <li class="with-a-dash">book.price = 320.45.</li>
    </ol>
    <p>Что касается хранения структур в памяти компьютера, то в машинных кодах понятие структуры отсутствует, и
        переменная
        book будет представляться в памяти компьютера следующим образом:</p>
    <p class="photo"><img src="./img/6_chapter/6.1.png" alt=""></p>
    <p class="signature">Рисунок 6.1 &#8211; Хранение структуры в памяти компьютера</p>
    <p>Все элементы структуры будут располагаться друг за другом, т. е. сначала задана строка title, состоящая из 100
        байт,
        далее 50 ячеек, которые отвечают за автора книги, потом 2 байта, которые отвечают за год издания, затем 2 байта,
        которые хранят число страниц, и 4 байта, отвечающие за цену книги. Таким образом располагаются переменные внутри
        структуры. Когда создается переменная book, то в памяти компьютера выделяется такая область памяти и по порядку
        записываются переменные, т. е. когда мы обращаемся к той или иной переменной, то мы работаем с такими ячейками
        памяти.</p>
    <p>Далее представлен пример программы, в которой реализуется ввод и вывод информации по определенной книге:</p>
    <pre class="cpp-code"><code class="language-cpp">#include &ltiostream>
using namespace std;
struct tag_book{
    //структура хранит все те денные, о которых мы говорили
    char title[100];
    char author[50];
    short year;
    short pages;
    float price;
}
int main(){
    setlocale(LC_ALL, “rus”);
struct tag_book book;
    strcpy_s(book.title, "Евгений Онегин"); //запись информации в структуру
    strcpy_s(book.author, "Пушкин А.С.");
    book.year = 2001;
    book.pages = 81;
    book.price = 145.51;
    cout << book.title << endl << book.author << endl << book.year << endl
        << book.pages << endl << book.price << endl; //вывод этой информации
    return 0;
}</code></pre>
    <p>Результат выполнения данного программного кода представлен на рисунке 6.2.</p>
    <p class="photo"><img src="./img/6_chapter/6.2.png" alt=""></p>
    <p class="signature">Рисунок 6.2 &#8211; Результат добавления книг</p>
    <p>Теперь представим, что необходимо хранить информацию не по одной книге, а по сто. Сделать это можно через массив
        структур. Массивы структур определяются так же, как и массивы других типов данных. Для приведённых ранее
        структурных
        типов можно определить:</p>
    <pre class="cpp-code"><code class="language-cpp">struct tovar	list [100];
struct students group [25];</code></pre>
    <p>Что касается работы со структурой tag_book, то в данном случае это можно сделать следующим образом:</p>
    <pre class="cpp-code"><code class="language-cpp">struct tag_book lib[100]; // т. е. задается не переменная, а массив из 100 книг</code></pre>
    <p>Данный массив схематично можно представить следующим образом:</p>
    <p class="tables"><img src="./img/6_chapter/1.6table.png" alt=""></p>
    <p>Запись информации происходит таким образом:</p>
    <p>Обращаемся к первой структуре lib[0].pages=122;</p>
    <p>Пример программы, работающей с массивом структуры книги:</p>
    <pre class="cpp-code"><code class="language-cpp">#include *ltiostream>
using namespace std;
#define N 4
struct tag_book{
    //структура, хранящая информацию по книге
    char title[100];
    char author[50];
    short year;
    short pages;
    float price; };
int main(){
    setlocale(LC_ALL, "rus"}});
    sruct tag_book lib[N];
    strcpy_s(lib[0].title, "Евгений Онегин"); //запись информации по 1-ой книге
    strcpy_s(lib[0].author, "Пушкин А.С.");
    lib[0].year = 2001;
    lib[0].pages = 81;
    lib[0].price = 145.51;
    strcpy_s(lib[1].title, "Война и мир"); //запись информации по 2-ой книге
    strcpy_s(lib[1].author, "Толстой Л.Н.");
    lib[1].year = 2011;
    lib[1].pages = 654;
    lib[1].price = 1025.11;
    lib[2] = lib[0]; //копируем в 3-ю книгу информацию из 1-ой
    lib[3] = lib[1]; // копируем в 4-ю книгу информацию из 2-ой
    for (int i = 0; i < N; ++i)
        cout << lib[i].title << endl << lib[i].author << endl << lib[1].year << endl
        << lib[i].pages << endl << lib[i].price << endl << endl; //вывод этой информации
    return 0;
}</code></pre>
    <p class="photo"><img src="./img/6_chapter/6.3.png" alt=""></p>
    <p class="signature">Рисунок 6.3 &#8211; Реализация работы с массивами</p>
    <p>В данном примере значения переменным задавались с помощью уточненных имен с использованием точечной записи.
        Однако в
        данном примере можно также при создании переменной на структуру сразу проинициализировать ее элементы.</p>
    <pre class="cpp-code"><code
            class="language-cpp">struct tag_book book = {"Евгений Онегин", "Пушкин А.С.", 1995};</code></pre>
    <p>или</p>
    <pre class="cpp-code"><code class="language-cpp">struct tag_book book = { .year = 1995, .author = "Пушкин А.С.", .title = "Евгений Онегин" };</code></pre>
    <p>В некоторых случаях есть смысл создавать структуры, которые содержат в себе другие вложенные структуры. Если
        элементом структуры является другая структура, то доступ к ее элементам выполняется через две операции
        выбора:</p>
    <pre class="cpp-code"><code class="language-cpp">struct A {int a; double x;};
struct B {A a; double x;} 
x[0].a.a = 1;
x[1].х = 0.1;</code></pre>
    <p>Ниже представлен пример создания простого банка данных о сотрудниках некоторого предприятия. В данном случае
        целесообразно ввести две структуры: одна будет содержать фамилии и имена, а вторая будет включать в себе первую,
        с
        добавлением полей о профессии и возрасте.</p>
    <pre class="cpp-code"><code class="language-cpp">#include &ltiostream>
using namespace std;
#define N 4
struct tag_fio{
	char lastname[100];
	char firstname[100];
}
struct tag_people{
	struct tag_fio fio; //вложенная структура
	char job[100];
	short old;
}
int main(){
	setlocale(LC_ALL, "rus");
	tag_people p[N];
	strcpy_s(p[0].fio.firstname, "Владимир");
	strcpy_s(p[0].fio.lastname, "Осипов");
	strcpy_s(p[0].job, "Сантехник");
	p[0].old = 29;
	p[1] = p[0]; //копируем во второй элемент массива первый элемент
	for (int i = 0; i < 2; ++i)
		cout << p[i].fio.firstname << endl << p[i].fio.lastname << endl << p[i].job << endl
		<< p[i].old << endl << endl;
	return 0;
}</code></pre>
    <p class="photo"><img src="./img/6_chapter/6.4.png" alt=""></p>
    <p class="signature">Рисунок 6.4 &#8211; Реализация работы вложенных структур</p>
    <p>Далее представлен еще один пример работы со структурами, в котором добавлена работа с базовыми операторами языка
        С++. Задан массив из 5 элементов следующей структуры: фамилия, возраст, адрес (улица, номер дома, номер
        квартиры), должность. Вывести на экран список молодежи не старше 20 лет с указанием места работы, затем отдельно
        вывести список работников с фамилией Иванов с указанием адреса:</p>
    <pre class="cpp-code"><code class="language-cpp">#include &ltiostream>
#include &ltstring>
using namespace std;
struct adress{
	char street[20];
	int house;
	int flat;
}
typedef struct{
	char fam[15];
	int old;
	struct adress adr;
	char work[15];
} man;
int main(){
	setlocale(LC_ALL, "rus");
	man list[5] = { "Иванов", 24 ,"Мира", 12, 33, "вахтёр",
	"Петров",18,"Ленина",44,1,"менеджер",
"Сидоров",45,"Мазая",65,32,"директор",
"Анохина",19,"Фрунзе",13,46,"бухгалтер",
"Усова",30,"Фучика",33,22,"кассир" };
	puts("\n\t\t СПИСОК СОТРУДНИКОВ \n");
	for (int i = 0; i < 5; i++)
		printf("\n % 10s % 5d % 10s % 5d % 5d % 10s",
			list[i].fam, list[i].old, list[i].adr.street, list[i].adr.house, list[i].adr.flat, list[i].work);
	puts("\n\n\t МОЛОДЁЖЬ ");
	int k = 0;
	for (int i = 0; i < 5; i++)
		if (list[i].old <= 20){
			k++;
			printf("\n % 10s % 5d % 10s", list[i].fam, list[i].old, list[i].work);
		}
	if (k == 0)
		puts("\n ДАННЫЕ НЕ НАЙДЕНЫ \n");
	puts("\n\n\t СПИСОК ИВАНОВЫХ");
	k = 0;
	for (int i = 0; i < 5; i++)
		if (strcmp(list[i].fam, "Иванов") == 0){
			k++;
			printf(" % 10s % 10s % 5d % 5d", list[i].fam, list[i].adr.street, list[i].adr.house, list[i].adr.flat);
		}
	if (k == 0) puts("\n ДАННЫХ НЕ НАЙДЕНО \n");
	printf("\n\n\n");
}</code></pre>
    <p>Результат выполнения данного программного кода представлен на рисунке 6.5.</p>
    <p class="photo"><img src="./img/6_chapter/6.5.png" alt=""></p>
    <p class="signature">Рисунок 6.5 &#8211; Результат работы программы с использованием структур данных</p>
     <p>На видео 13 представлена подробная лекция по структурам данных.</p>
    <video controls="controls" poster="./img/video.jpg" src="./video/video_13_l.mp4"></video>
    <p class="signature">Видео 13 &#8211; Структуры данных</p>
    <h3 id="6.2">6.2 Объединения, перечисления, оператор typedef</h3>
    <h3 id="6.2.1">6.2.1 Объединения Union</h3>
    <p><a href="glossary.html#m8">Объединение (union)</a> представляет собой частный случай структуры, все поля которой располагаются по одному и тому
        же
        адресу. Формат описания такой же, как у структуры, только вместо ключевого слова struct используется слово
        union.</p>
    <p>Объединение позволяет размещать в одном месте памяти данные, доступ к которым реализуется через переменные разных
        типов. Использование объединений значительно экономит память, выделяемую под объекты.</p>
    <p>Синтаксис задания объединений следующий:</p>
    <pre class="cpp-code"><code class="language-cpp">union [имя объединения]{
    [переменные];
}</code></pre>
    <p>Принципиальное отличие объединения от структур в том, что объединение хранит все эти переменные в одних и тех же
        ячейках памяти.</p>
    <p>При создании переменной типа объединение память под все элементы объединения выделяется, исходя из размера
        наибольшего его элемента. В каждый отдельный момент времени объединение используется для доступа только к одному
        элементу данных, входящих в объединение.</p>
    <p>Далее представлен пример задания объединения:</p>
    <pre class="cpp-code"><code class="language-cpp">union tag_var{
	int vi;
	double vd;
	char vd;
}</code></pre>
    <p>Компилятор MS Visual Studio выделит 8 байтов под данное объединение.</p>
    <p class="photo"><img src="./img/6_chapter/6.6.png" alt=""></p>
    <p class="signature">Рисунок 6.6 &#8211; Хранение данных обьединений</p>
    <p>В следующем примере компилятор MS Visual Studio выделит 4 байта под объединение:</p>
    <pre class="cpp-code"><code class="language-cpp">union unionA{
    char ch1;
    float f1;
} a1;</code></pre>
    <p>Таблица 6.1 &#8211; Структура элементов объединения</p>
    <p class="tables"><img src="./img/6_chapter/table6.1.png" alt=""></p>
    <p>Инициализировать объединение при его объявлении можно только заданием значения первого элемента объединения.</p>
    <p>Например:</p>
    <pre class="cpp-code"><code class="language-cpp">union unionA{
    char ch1;
    float f1;
}
a1 = { 'M' };</code></pre>
    <p>Доступ к элементам объединения аналогично доступу к элементам структур выполняется с помощью операторов . и
        ->.</p>
    <p>Например:</p>
    <pre class="cpp-code"><code class="language-cpp">union TypeNum{
	int    i;
	long  l;
	float  f;
}
union TypeNum vNum = { 1 };
// Инициализация первого элемента объединения i = 1
cout << vNum.i;
vNum.f = 4.13;
cout << vNum.f;</code></pre>
    <p>Длина объединения равна наибольшей из длин его полей. В каждый момент времени в переменной типа объединение
        хранится
        только одно значение, и ответственность за его правильное использование лежит на программисте.</p>
    <p>Далее представлен пример программы, которая работает с объединением:</p>
    <pre class="cpp-code"><code class="language-cpp">#include &ltiostream>
using namespace std;  //начинаем задавать объединение
union tag_value{
	int vi;
	double vd;
	char vc;
}
struct tag_var{
	//структура, содержащая наши объединения
	union tag_value value;
	short type_var; // 0 – переменная vi, 1 – переменная vd, 2 – переменная vc
}
int main(){
	setlocale(LC_ALL, "rus");
	struct tag_var var[3]; //создаем массив из структур
	var[0].type_var = 0;
	var[0].value.vi = 10;
	var[1].type_var = 1;
	var[1].value.vd = 2.3;
	var[2].type_var = 2;
	var[2].value.vc = 'd';
	for (int i = 0; i < 3; i++){
		switch (var[i].type_var){
		case 0:  cout << "1  :" << var[i].value.vi << endl; break;
		case 1:  cout << "2 :" << var[i].value.vd << endl; break;
		case 2:cout << "3 : " << var[i].value.vc << endl; break;
		default: cout << "Значение переменной не определено\n";
		}
	}
	return 0;
}</code></pre>
    <p>Результат выполнения данного программного кода представлен на рисунке 6.7.</p>
    <p class="photo"><img src="./img/6_chapter/6.7.png" alt=""></p>
    <p class="signature">Рисунок 6.7 &#8211; Результат работы программы с использованием объединений</p>
    <p>На объединения налагаются некоторые ограничения:</p>
    <ol>
        <li class="with-a-dash">объединение может инициализироваться значением его первого элемента;</li>
        <li class="with-a-dash">объединение не может содержать битовые поля;</li>
        <li class="with-a-dash">объединение не может содержать виртуальные методы, конструкторы, <a href="glossary.html#m5">деструкторы</a> и операцию
            присваивания;
        </li>
        <li class="with-a-dash">объединение не может входить в иерархию <a href="glossary.html#m6">классов</a>.</li>
    </ol>



    <h3 id="6.2.2">6.2.2 Перечисляемые типы Enum</h3>
    <p>При написании программ часто возникает потребность определить несколько именованных <a href="glossary.html#m7">констант</a>, для которых
        требуется,
        чтобы все они имели различные значения (при этом конкретные значения могут быть неважны). Для этого удобно
        воспользоваться перечисляемым типом данных, все возможные значения которого задаются списком целочисленных
        констант.</p>
    <p>Перечисления представляют собой список идентификаторов, введенных пользователем:</p>
    <pre class="cpp-code"><code class="language-cpp">enum name_list {name1, name2, ...};</code></pre>
    <p>За каждым таким именем по умолчанию закрепляются целочисленные константы:</p>
    <pre class="cpp-code"><code class="language-cpp">имени name1 соответствует константа 0;
имени name2 соответствует константа 1;</code></pre>
    <p>Имя типа задается в том случае, если в программе требуется определять переменные этого типа. Компилятор
        обеспечивает,
        чтобы эти переменные принимали значения только из списка констант.</p>
    <p>Далее рассмотрен пример использования перечислений:</p>
    <pre class="cpp-code"><code
            class="language-cpp">enum {two = 2, three, four, ten = 10, eleven, fifty = ten + 40};</code></pre>
    <p>В данном случае <a href="glossary.html#m7">константам</a> three и four присваиваются значения 3 и 4, константе eleven &#8211; 11. Имена
        перечисляемых
        констант должны быть уникальными, а значения могут совпадать.</p>
    <p>Преимущество применения перечисления перед описанием именованных констант и директивой #define состоит в том, что
        связанные константы нагляднее; кроме того, компилятор при инициализации констант может выполнять проверку типов.
        При
        выполнении арифметических операций перечисления преобразуются в целые. Поскольку перечисления являются типами,
        определяемыми пользователем, для них можно вводить собственные операции.</p>
    <p>Для инициализации значений нумератора не с 0, а с другого целочисленного значения следует присвоить это значение
        первому элементу списка значений перечислимого типа.</p>
    <p>Например:</p>
    <pre class="cpp-code"><code class="language-cpp">// Создание перечисления
enum eDay{sn, mn, ts, wd, th, fr, st} day1;
// переменная day1 будет принимать
// значения в диапазоне от 0 до 6
day1=st;
// day1 - переменная перечисляемого типа
int i1=sn;
// i1 будет равно 0
day1= eDay(0);
// eDay(0) равно значению sn
enum(color1=255);
// Объявление перечисления, определяющего
// именованную целую константу color1
int icolor = color1;
enum eDay2{sn=1, mn, ts, wd, th, fr, st} day2;
// переменная day2 будет принимать
// значения в диапазоне от 1 до 7</code></pre>
    <p>Для перечисляемого типа существует понятие диапазона значений, определяемого как диапазон целочисленных значений,
        которые может принимать переменная данного перечисляемого типа.</p>
    <p>Далее приведен пример программы с использованием перечислений:</p>
    <pre class="cpp-code"><code class="language-cpp">#include &ltiostream>
using namespace std;  //начинаем задавать объединение
union tag_value{
	int vi;
	double vd;
	char vc;
}
enum tag_type { VT_NONE, VT_INT, VT_FLOAT, VT_CHAR };
struct tag_var{
	union tag_value value;
	tag_type type_var;
}
int main(){
	setlocale(LC_ALL, "rus");
	struct tag_var var[3];
	var[0].type_var = VT_INT;
	var[0].value.vi = 10;
	var[1].type_var = VT_FLOAT;
	var[1].value.vd = 2.3;
	var[2].type_var = VT_CHAR;
	var[2].value.vc = 'd';
	for (int i = 0; i < 3; i++){
		switch (var[i].type_var){
		case VT_INT:  cout << "1 :" << var[i].value.vi << endl; break;
		case VT_FLOAT:  cout << "2 :" << var[i].value.vd << endl; break;
		case VT_CHAR:cout << "3 : " << var[i].value.vc << endl; break;
		default: cout << "Значение переменной не определено\n";
		}
	}
	return 0;
}</code></pre>
    <p class="photo"><img src="./img/6_chapter/6.8.png" alt=""></p>
    <p class="signature">Рисунок 6.8 &#8211; Результат работы программы с использованием перечислений</p>
    <p>Если будут объявлены два перечисления, то код программы будет выглядеть следующим образом:</p>
    <pre class="cpp-code"><code class="language-cpp">enum color {red, green, blue} clr;
enum color_type {clr_red, clr_green, clr_blue} type;
то red=clr_red и тд.</code></pre>
    <p>Из этого следует, что if(clr==red) такая проверка и if(clr==clr_red) такая проверка будут давать один и тот же
        результат.</p>
    <p>Следующий оператор выдаст сообщение об ошибке, потому что значение red и clr_red имеют одно значение, а оператор
        switch не допускает такой ситуации.</p>
    <pre class="cpp-code"><code class="language-cpp">switch (clr){
case red:printf("KpacHbIM IBET\n");break;
case green:printf("3eneHbIM LIBET\n");break;
case clr_red:printf("KpacHbIé OTTEHOK\n");break;
}</code></pre>
    <p>Для того чтобы такой ситуации не возникало, при задании перечисляемого типа допускается следующие варианты:</p>
    <pre class="cpp-code"><code class="language-cpp">enum color type {clr red 10, clr green, clr blue};
 enum color_type {clr_red = 10, clr_green = 20, clr blue = 30};
 enum color_type {clr_red, clr_green = 20, clr blue};</code></pre>
    <h3 id="6.2.3">6.2.3 Типы, определяемые пользователем Typedef</h3>
    <p>Помимо явного объявления типа, в C++ предусмотрены дополнительные средства описания имён типов. Таким средством
        является typedef-объявление.</p>
    <p>С помощью typedef в программу можно ввести новые имена, которые затем можно использовать для обозначения
        производных
        и основных типов.</p>
    <p>Другими словами, для того чтобы сделать программу более ясной, можно задать типу новое имя с помощью ключевого
        слова
        typedef:</p>
    <pre class="cpp-code"><code class="language-cpp">typedef тип новое_имя [размерность];</code></pre>
    <p>В данном случае квадратные скобки являются элементом синтаксиса. Размерность может отсутствовать.</p>
    <p>С помощью typedef в программу можно ввести новые имена, которые затем можно использовать для обозначения
        производных
        и основных типов.</p>
    <p>Далее рассмотрены примеры работы c typedef-объявлением:</p>
    <pre class="cpp-code"><code class="language-cpp">typedef unsigned int UINT;
typedef char Msg[100];
typedef struct{
	char fio[30];
	int date, code;
	double salary;
}
Worker;</code></pre>
    <p>Введенное имя можно использовать так же, как и имена стандартных типов:</p>
    <pre class="cpp-code"><code class="language-cpp">UINT i, j;    // две переменных типа unsigned int
Msg str[10];   // массив из 10 строк по 100 символов
Worker stuff[100];   // массив из 100 структур</code></pre>
    <p>В следующем примере вместо использования unsigned char мы написали более короткое слово BYTE следующим
        образом:</p>
    <pre class="cpp-code"><code class="language-cpp">typedef unsigned char BYTE;</code></pre>
    <p>А переменную можно задать так:</p>
    <pre class="cpp-code"><code class="language-cpp">BYTE ch;</code></pre>
    <p>Также с помощью оператора typedef можно повысить степень переносимости программного кода с одной платформы на
        другую,
        например:</p>
    <pre class="cpp-code"><code class="language-cpp">size_t sizeof (&ltтип или переменная>);</code></pre>
    <p>Помимо этого, оператор typedef довольно часто используется при задании названия типа у структур и объединений,
        например:</p>
    <pre class="cpp-code"><code class="language-cpp">typedef struct{
	union tag_value value;
	tag_type type_var;
} VAR;</code></pre>
    <p>При использовании спецификатора typedef следует учитывать, что он подчиняется следующим правилам:</p>
    <ol>
        <li class="without-parentheses">спецификатор typedef может переопределять имя как имя типа, даже если это имя
            само
            уже было ранее введено typedef спецификатором:
        </li>
        <pre class="cpp-code"><code class="language-cpp">typedef int I;
typedef I I;</code></pre>
        <li class="without-parentheses">спецификатор typedef не может переопределять имя типа, объявленное в одной и той
            же
            области действия и замещающее имя другого типа:
        </li>
        <pre class="cpp-code"><code class="language-cpp">typedef int I;
typedef float I; // Ошибка: повторное описание</code></pre>
        <li class="without-parentheses">на имена, введённые в программу с помощью спецификатора typedef,
            распространяются
            правила области действия, за исключением разрешения на многократное использование имени.
        </li>
    </ol>
    <p>На видео 14 представлена лекция по объединениям, перечислениям и typedef.</p>
    <video controls="controls" poster="./img/video.jpg" src="./video/video_14_l.mp4"></video>
    <p class="signature">Видео 14 &#8211; Объединения, перечисления и typedef</p>
    <h3 id="6.3">6.3 Контрольные вопросы для закрепления материала</h3>
    <ol>
        <li class="with-a-bracket">Как называются элементы структуры?</li>
        <li class="with-a-bracket">Как инициализируется структуры?</li>
        <li class="with-a-bracket">С помощью какой операции выполняется доступ к полям структур?</li>
        <li class="with-a-bracket">Что представляет частный случай структуры?</li>
        <li class="with-a-bracket">Когда применяют объединение?</li>
    </ol>
</script>

<script id="page6.4" type="text/html">
    <TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0>
        <TR>
            <TD width="50%"><a name="3"></a>
                <HR>
                <div align=justify><h1>Тренировочные упражнения</h1></div>
  <form>
   <ol> 
   	<li class="without-parentheses"> Заполните пропуски формата определения структурного типа
   	 <pre class="cpp-code"><code class="language-cpp">
struct [ <input type="text" id="glav6_1_1" size="2"> структуры ] { определения <input type="text" id="glav6_1_2" size="6"> };
</code></pre>  

 <input type="button" value="Ответить" class="proverit_glav_6_1"></input>
              <input type="reset" value ="Очистить"></input>
              <br><br>
                 <div id="resultat_6_1"></div>
                  </form>
              </li><br><br>
<form>              
<li class="without-parentheses"> Дополните код таким образом, чтобы было выведено содержимое структуры <em>«Книга»</em>. 
<pre class="cpp-code"><code class="language-cpp">
#include &ltiostream>
using namespace std;
struct tag_book{
    char title[100];
    char author[50];
    short year;
    short pages;
    float price;
}
int main(){
    setlocale(LC_ALL, “rus”);
    tag_book book;
    strcpy_s(book.<input type="text" id="glav6_2_1" size="4">, "Евгений Онегин"); //запись информации в структуру
    strcpy_s(book.author, "Пушкин А.С.");
    book.<input type="text" id="glav6_2_2" size="4"> = 2001;
    <input type="text" id="glav6_2_3" size="4">.pages = 81;
    <input type="text" id="glav6_2_4" size="9">= 145.51;
    cout << book.title << endl << book.author << endl << book.year << endl
        << book.pages << endl << book.price << endl; //вывод этой информации
    return 0;
	</code></pre>
	<p class="photo"><img src="./img/6_chapter/6.9.png" alt=""></p> 

 <input type="button" value="Ответить" class="proverit_glav_6_2"></input>
              <input type="reset" value ="Очистить"></input>
              <br><br>
                 <div id="resultat_6_2"></div>
</form>
</li>
     	     </ol>
 </HR></TD></TR></TABLE>
</script> 

<script id="page6.5" type="text/html">
    <TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0>
        <TR>
            <TD width="50%"><a name="3"></a>
                <HR>
                <div align=justify><h1 align="center">Тестирование по шестой главе</h1></div>
                <form name=test>
                    <ol>
                        <li>
                            <h4><input type=text name=T1 style="height: 15px; width:15px;" value=''> Укажите правильное
                                обращение к полям структуры: structcoord{int x; int z;}data;:</h4>
                            <input type=radio name=Q1> data.x; data.z;<br>
                            <input type=radio name=Q1> coord.x; coord.z;<br>
                            <input type=radio name=Q1> coord.x; data.z;<br>
                            <input type=radio name=Q1> data.y;<br>
                            <input type=radio name=Q1> data x; cord x.<br>
                            <br>
                        </li>
                        <li>
                            <h4><input type=text name=T2 style="height: 15px; width:15px;" value=''> Дано:
                                <pre class="cpp-code"><code
                                        class="language-cpp">struct coord{int x; int z[];};</code></pre>
                                Что означает следующая ниже запись?
                                <pre class="cpp-code"><code class="language-cpp">structcoorddata[100];</code></pre>
                            </h4>
                            <input type=radio name=Q2> объявляется массив, каждый элемент которого &mdash; структура
                            типа
                            coord;<br>
                            <input type=radio name=Q2> объявляется структура data, каждый элемент которой &mdash;
                            массив;<br>
                            <input type=radio name=Q2> нет правильного ответа;<br>
                            <input type=radio name=Q2> обозначают адрес переменной fcp в памяти;<br>
                            <input type=radio name=Q2> нет верного ответа.<br>
                            <br>
                        </li>
                        <li>
                            <h4><input type=text name=T3 style="height: 15px; width:15px;" value=''> Какие ограничения
                                налагаются на объединения?</h4>
                            <input type=radio name=Q3> объединение не может содержать битовые поля;<br>
                            <input type=radio name=Q3> объединение не может входить в иерархию классов;<br>
                            <input type=radio name=Q3> объединение может инициализироваться только значением его первого
                            элемента;<br>
                            <input type=radio name=Q3> объединение не может содержать виртуальные методы, конструкторы,
                            <a href="glossary.html#m5">деструкторы</a> и операцию присваивания;<br>
                            <input type=radio name=Q3> все перечисленное.<br>
                            <br>
                        </li>
                        <li>
                            <h4><input type=text name=T4 style="height: 15px; width:15px;" value=''> С помощью какого
                                ключевого слова можно задать имя типу?</h4>
                            <input type=radio name=Q4> struct;<br>
                            <input type=radio name=Q4> enum;<br>
                            <input type=radio name=Q4> union;<br>
                            <input type=radio name=Q4> typedef;<br>
                            <input type=radio name=Q4> нет правильного ответа.<br>
                            <br>
                        </li>
                        <li>
                            <h4><input type=text name=T5 style="height: 15px; width:15px;" value=''> Элементы структур
                                располагаются в памяти компьютера:</h4>
                            <input type=radio name=Q5> последовательно, один за другим;<br>
                            <input type=radio name=Q5> начинаясь с одного адреса памяти, перекрывая друг друга;<br>
                            <input type=radio name=Q5> только на жестком диске;<br>
                            <input type=radio name=Q5> только в оперативной памяти;<br>
                            <input type=radio name=Q5> нет правильного ответа.<br>
                            <br>
                        </li>
                        <li>
                            <h4><input type=text name=T6 style="height: 15px; width:15px;" value=''> Битовые поля могут
                                использоваться в union?</h4>
                            <input type=radio name=Q6> нет;<br>
                            <input type=radio name=Q6> да;<br>
                            <input type=radio name=Q6> нет верного ответа;<br>
                            <input type=radio name=Q6> нет, только в typedef;<br>
                            <input type=radio name=Q6> нет, только в enum.<br>
                            <br>
                        </li>
                        <li>
                            <h4><input type=text name=T7 style="height: 15px; width:15px;" value=''> В каком из
                                следующих
                                вариантов ответов выполнен корректный доступ к переменной структуры, причём структура
                                объявлена через указатель?</h4>
                            <input type=radio name=Q7> b->var;<br>
                            <input type=radio name=Q7> b>var;<br>
                            <input type=radio name=Q7> b.var;<br>
                            <input type=radio name=Q7> b-var;<br>
                            <input type=radio name=Q7> нет верного ответа.<br>
                            <br>
                        </li>
                        <li>
                            <h4><input type=text name=T8 style="height: 15px; width:15px;" value=''> Какое объявление
                                переменной типа структуры foo является правильным?</h4>
                            <input type=radio name=Q8> int foo;<br>
                            <input type=radio name=Q8> foo;<br>
                            <input type=radio name=Q8> char foo;<br>
                            <input type=radio name=Q8> foo var;<br>
                            <input type=radio name=Q8> struct foo.<br>
                            <br>
                        </li>
                        <li>
                            <h4><input type=text name=T9 style="height: 15px; width:15px;" value=''> Выберите правильное
                                определение структуры в С++:</h4>
                            <input type=radio name=Q9> struct a_struct int a;<br>
                            <input type=radio name=Q9> struct {int a;};<br>
                            <input type=radio name=Q9> structure a;<br>
                            <input type=radio name=Q9> struct a_struct {int a;};<br>
                            <input type=radio name=Q9> struct a_struct {}.<br>
                            <br>
                        </li>
                        <li>
                            <h4><input type=text name=T10 style="height: 15px; width:15px;" value=''> Как организовать
                                запись в файл?</h4>
                            <input type=radio name=Q10> a_file.out("запись");<br>
                            <input type=radio name=Q10> a_file<< "запись";<br>
                            <input type=radio name=Q10> a_file.printf("запись");<br>
                            <input type=radio name=Q10> file(a):=(“запись”);<br>
                            <input type=radio name=Q10> a_file="запись".<br>
                            <br>
                        </li>
                    </ol>
                    <div align="center">
                        <div>
                            <input type=button value="Показать результат" onClick="test1('MTE1NDEyMTQ0Mg', 10)">
                        </div>
                        <div>
                            <textarea style="margin-top:6px" rows=5 cols="100%" name=s1></textarea>
                        </div>
                        <div>
                            <input type=reset value="Очистить выбранные пункты">
                        </div>
                        <br>
                        <Div align=center>
                            <a href="#3">В начало страницы</a>
                        </div>
                        <br>
                    </div>
                </form>
            </TD>
        </TR>
    </TABLE>
</script>

<!-- /page7 -->
<script id="page7" type="text/html">
    <h2 id="7">7 Динамические структуры данных</h2>
    <p>Любая программа предназначена для обработки данных, от способа организации которых зависят алгоритмы работы.
        Поэтому
        выбор структур данных должен предшествовать созданию алгоритмов. Память под данные выделяется либо на этапе
        компиляции (в этом случае необходимый объем должен быть известен до начала выполнения программы, то есть задан в
        виде константы), либо во время выполнения программы с помощью операции new или функции malloc (необходимый объем
        должен быть известен до распределения памяти). В обоих случаях выделяется непрерывный участок памяти. Если до
        начала работы с данными невозможно определить, сколько памяти потребуется для их хранения, память выделяется по
        мере
        необходимости отдельными блоками, связанными друг с другом с помощью указателей. Такой способ организации данных
        называется динамическими структурами данных.</p>
    <p>Из динамических структур в программах чаще всего используются линейные списки, стеки и очереди. Они различаются
        способами связи отдельных элементов и допустимыми операциями. Динамическая структура может занимать несмежные
        участки оперативной памяти. Динамические структуры широко применяют и для более эффективной работы с данными,
        размер которых известен, особенно для решения задач сортировки, поскольку упорядочивание динамических структур
        не
        требует перестановки элементов, а сводится к изменению указателей на эти элементы. Элемент любой динамической
        структуры данных представляет собой структуру (struct), содержащую по крайней мере два поля: для хранения данных
        и
        для указателя. Полей данных и указателей может быть несколько. Поля данных могут быть любого типа: основного,
        составного или типа указатель.</p>
    <h3 id="7.1">7.1 Линейные списки</h3>
    <p>Самый простой способ связать множество элементов &#8211; сделать так, чтобы каждый элемент содержал ссылку на
        следующий.
        Такой список называется однонаправленным (односвязным). Если добавить в каждый элемент вторую ссылку на
        предыдущий элемент &#8211; получится двунаправленный, если последний элемент связать указателем с первым &#8211;
        получится
        кольцевой список.</p>
    <p>Каждый элемент списка содержит ключ, идентифицирующий этот элемент. Ключ обычно бывает либо целым числом, либо
        строкой и является частью поля данных. В качестве ключа в процессе работы со списком могут выступать разные
        части
        поля данных. Например, если создается линейный список из записей, содержащих фамилию, год рождения, стаж работы
        и
        пол, любая часть записи может выступать в качестве ключа: при упорядочивании списка по алфавиту ключом будет
        фамилия, а при поиске, к примеру, ветеранов труда ключом будет стаж. Ключи разных элементов списка могут
        совпадать.</p>
    <p>Над списками можно выполнять следующие операции:</p>
    <ol>
        <li class="with-a-dash">начальное формирование списка (создание первого элемента);</li>
        <li class="with-a-dash">добавление элемента в конец списка;</li>
        <li class="with-a-dash">чтение элемента с заданным ключом;</li>
        <li class="with-a-dash">вставка элемента в заданное место списка (до или после элемента с заданным ключом);</li>
        <li class="with-a-dash">удаление элемента с заданным ключом;</li>
        <li class="with-a-dash">упорядочивание списка по ключу.</li>
    </ol>
    <h3 id="7.1.1">7.1.1 Линейные односвязные списки</h3>
    <h3 id="7.1.1.1">7.1.1.1 Создание линейного односвязного списка</h3>
    <p>Линейный список &#8211; это динамическая структура данных, каждый элемент которой посредством указателя
        связывается
        со следующим элементом.</p>
    <p>Из определения следует, что каждый элемент списка содержит поле данных (Data), которое может иметь сложную
        структуру,
        и
        поле ссылки на следующий элемент (next). Поле ссылки последнего элемента должно содержать пустой указатель
        (NULL).
        Т. к. ссылка всего одна (только на следующий элемент), то такой список является односвязным. Когда говорят о
        линейном списке, то, как правило, подразумевают именно односвязный список.</p>
    <p>Например, необходимо сформировать список, содержащий целые числа 3, 5, 1, 9. Для решения этой задачи при работе с
        динамическими структурами необходимо выполнить следующий порядок действий:</p>
    <ol>
        <li>а) Прежде всего необходимо определить две структуры:</li>
        <li class="with-a-dash">структура, содержащая характеристики данных, то есть все те поля с данными, которые
            необходимы для решения поставленной задачи (в нашем случае имеется всего одно поле целого типа). Назовём эту
            структуру Data;
        </li>
        <li class="with-a-dash">структура, содержащая поле типа Data и поле – адрес последующего элемента next. Вторую
            структуру назовём List.
        </li>
    </ol>
    <p>Тексты этих структур необходимо расположить в начале программы (до main() и других функций). Вот возможная
        реализация структур:</p>
    <pre class="cpp-code"><code class="language-cpp">struct Data{
	int a;
}
struct List{
	Data d;
	List* next;
}</code></pre>
    <p>Такой подход позволит в дальнейшем изменять в широких пределах структуру с собственными данными, никак не
        затрагивая при этом основную структуру List.</p>
    <p>Итак, в данном примере был описан структурный тип, с помощью которого создан односвязный список. Графически
        создаваемый список можно изобразить так, как это показано на рисунке 7.1.</p>
    <p class="photo"><img src="./img/7_chapter/7.1.png" alt=""></p>
    <p class="signature">Рисунок 7.1 &#8211; Линейный односвязный список</p>
    <ol>
        <li>б) В программе (обычно в функции main()) следует определить указатель на начало будущего списка:</li>
        <pre class="cpp-code"><code class="language-cpp">List *u = NULL;</code></pre>
    </ol>
    <p>Пока список пуст, и указатель явно задан равным константе NULL.</p>
    <ol>
        <li>в) Выполняем первоначальное заполнение списка.</li>
    </ol>
    <p>Создадим первый элемент:</p>
    <pre class="cpp-code"><code class="language-cpp">u = new List;  // Выделяем память под элемент списка
u->d.a = 3;    // Заполняем поля с данными
               // (здесь это всего одно поле)
u->next = NULL;// Указатель на следующий элемент пуст
</code></pre>
    <p>После включения первого элемента список можно изобразить так:</p>
    <p class="photo"><img src="./img/7_chapter/7.2.png" alt=""></p>
    <p class="signature">Рисунок 7.2 &#8211; Список после включения первого элемента</p>
    <p>Продолжим формирование списка, добавляя новые элементы в его конец. Для удобства заведём вспомогательную
        переменную-указатель, которая будет хранить адрес последнего элемента списка:</p>
    <pre class="cpp-code"><code class="language-cpp">List *x;
x = u; // Сейчас последний элемент списка совпадает с его началом
</code></pre>
    <p class="photo"><img src="./img/7_chapter/7.3.png" alt=""></p>
    <p class="signature">Рисунок 7.3 &#8211; Новый список</p>
    <p>Таким образом, к области памяти можно обратиться через два указателя.</p>
    <p>Выделяем место в памяти для следующего элемента списка и перенаправляем указатель x на выделенную область
        памяти:</p>
    <pre class="cpp-code"><code class="language-cpp">x->next = new List;
x = x->next;</code></pre>
    <p>Затем определяем значение этого элемента списка:</p>
    <pre class="cpp-code"><code class="language-cpp">x->d.a = 5;
x->next = NULL;</code></pre>
    <p>Получилась такая схема:</p>
    <p class="photo"><img src="./img/7_chapter/7.4.png" alt=""></p>
    <p class="signature">Рисунок 7.4 &#8211; Полученный линейный список</p>
    <p>Этот процесс продолжаем до тех пор, пока не будет сформирован весь список.</p>
    <h3 id="7.1.1.2">7.1.1.2 Работа с линейными односвязными списками</h3>
    <p>Сформировав начальный список, можно выполнять с ним различные действия. Рекомендуется каждую операцию со списком
        оформлять в виде отдельной функции. Такой подход заметно упрощает разработку программы и возможную её дальнейшую
        модификацию. Формирование начального списка также лучше записать в виде функции. С линейными односвязными
        списками можно выполнять следующие действия:</p>
    <ol>
        <li>1) Просмотр списка осуществляется последовательно, начиная с его начала. Указатель последовательно ссылается
            на первый, второй и т.д. элементы списка до тех пор, пока весь список не будет пройден. Приведём пример
            реализации просмотра, например, для вывода списка на экран монитора:
        </li>
    </ol>
    <pre class="cpp-code"><code class="language-cpp">void Print(List* u){
    List* p = u;
    cout << "Spisok:" << endl;
    while (p){
        cout << p->d.a << endl;
        p = p->next;
    }
}</code></pre>
    <p>Обратиться к функции можно так:</p>
    <pre class="cpp-code"><code class="language-cpp">Print(u);</code></pre>
    <p>Здесь и далее в примерах u &#8211; это указатель на начало списка.</p>
    <ol>
        <li>2) Поиск первого вхождения в список элемента, соответствующего заданным требованиям:</li>
    </ol>
    <pre class="cpp-code"><code class="language-cpp">List* Find(List* u, Data& x){
    List* p = u;
    while (p){
        if (p->d.a == x.a) // условие для поиска
            return p;
        p = p->next;
    }
    return 0;
}</code></pre>
    <p>Возможный вызов функции:</p>
    <pre class="cpp-code"><code class="language-cpp">List * v = Find(u, x);</code></pre>
    <p>где <strong>x</strong> &#8211; объект типа <strong>Data</strong>.</p>
    <ol>
        <li>3) Добавление нового элемента в начало списка:</li>
    </ol>
    <pre class="cpp-code"><code class="language-cpp">void Add_Beg(List** u, Data& x){
	List* t = new List;
	t->d.a = x.a;
	t->next = *u;
	*u = t;
}</code></pre>
    <p>Возможный вызов функции:</p>
    <pre class="cpp-code"><code class="language-cpp">Add_Beg(&u, x);</code></pre>
    <p>где <strong>x</strong> &#8211; объект типа <strong>Data</strong>.</p>
    <ol>
        <li>4) Вставка нового элемента в произвольное место списка по какому-нибудь принципу, например, вставка в
            отсортированный по возрастанию список:
        </li>
    </ol>
    <pre class="cpp-code"><code class="language-cpp">void Insert(List** u, Data& x){
    // вставка в список одного элемента перед элементом,
   // меньшим или равным данному x
    List* p = new List;
    p->d.a = x.a;
    if (*u == 0){ // исходный список пуст – вставка в начало
        p->next = 0;
        *u = p;
        return;
    }
    List* t = *u;
    if (t->d.a >= p->d.a){
        // исходный список не пуст –
        // вставка в начало
        p->next = t;
        *u = p;
        return;
    }
    List* t1 = t->next;
    while (t1){
        if (t->d.a < p->d.a && p->d.a <= t1->d.a){
            // вставка в середину
            t->next = p;
            p->next = t1;
            return;
        }
        t = t1;
        t1 = t1->next;
    }
    t->next = p; // добавляем в конец списка
    p->next = 0;
}</code></pre>
    <p>Возможный вызов функции:</p>
    <pre class="cpp-code"><code class="language-cpp">Insert(&u, x)</code></pre>
    <p>где <strong>x</strong> &#8211; объект типа <strong>Data</strong>.</p>
    <p>Эта функция позволяет сразу формировать упорядоченный список.</p>
    <ol>
        <li>5) Удаление элемента из линейного списка:</li>
    </ol>
    <pre class="cpp-code"><code class="language-cpp">void Delete(List** u, Data& x){
    if (*u == 0){
        // исходный список пуст – удалять нечего!
        return;
    }
    List* t = *u;
    if (t->d.a == x.a){
        // исходный список не пуст –
        // удаляется начало
        *u = t->next;
        delete t;
        return;
    }
    List* t1 = t->next;
    while (t1){
        if (t1->d.a == x.a){
            // исходный список не пуст –
            //удаляется не первый элемент
            t->next = t1->next;
            delete t1;
            return;
        }
        t = t1;
        t1 = t1->next;
    }
}</code></pre>
    <p>Возможный вызов функции:</p>
    <pre class="cpp-code"><code class="language-cpp">Delete(&u, x);</code></pre>
    <p>где <strong>x</strong> &#8211; объект типа <strong>Data</strong>.</p>
    <ol>
        <li>6) Удаление (очистка) всего списка:</li>
    </ol>
    <p>Когда данные, хранящиеся в списке, становятся ненужными, можно очистить весь список, т. е. освободить память,
        которую
        занимали все элементы списка. Выполнять эту операцию желательно сразу после того, как список стал не нужен.
        Реализация этой операции может быть такой:</p>
    <pre class="cpp-code"><code class="language-cpp">void Clear(List** u){
    // удаление (очистка) всего списка
    if (*u == 0) return;
    List* p = *u;
    List* t;
    while (p){
        t = p;
        p = p->next;
        delete t;
    }
    *u = 0;
}</code></pre>
    <p>Возможный вызов функции:</p>
    <pre class="cpp-code"><code class="language-cpp">Clear(&u);</code></pre>
    <h3 id="7.1.2">7.1.2 Двухсвязные линейные списки</h3>
    <h3 id="7.1.2.1">7.1.2.1 Создание двухсвязного линейного списка</h3>
    <p>В двухсвязном списке каждый элемент имеет поля с данными и два указателя: один указатель хранит адрес
        предшествующего
        элемента списка, второй &#8211; адрес последующего элемента. Вполне естественно для работы с двухсвязным списком
        использовать два указателя, хранящие адреса начала и конца такого списка.</p>
    <p>Схематичная структура связного списка представлена на рисунке 7.5. Как видно на рисунке, здесь в каждом объекте
        связного списка имеется два указателя:</p>
    <ol>
        <li class="with-a-bracket">указатель *next указывает на следующий объект списка, то есть содержит адрес
            следующего объекта;
        </li>
        <li class="with-a-bracket">указатель *prev содержит адрес предыдущего объекта в списке.</li>
    </ol>
    <p class="photo"><img src="./img/7_chapter/7.5.png" alt=""></p>
    <p class="signature">Рисунок 7.5 &#8211; Схематичная реализация связного списка</p>
    <p>Таким образом настраиваются связи, благодаря которым можно двигаться как от начала в конец списка, так и с конца
        в
        начало. Причем указатель *next последнего объекта равен нулю, и указатель *prev первого объекта тоже равен нулю.
        Благодаря этим значениям мы будем знать, где заканчивается связный список, то есть знать, где находится первый
        объект и где находится последний.</p>
    <p>Кроме того, даны два указателя *head и *tail. Указатель *head всегда указывает на самый первый объект списка, а
        *tail
        &#8211; на последний. С помощью этих указателей можно сразу переходить на первый объект либо на последний.</p>
    <p>В связный список объекты можно добавлять на любую позицию и удалять из любой позиции. Здесь нет никаких
        ограничений,
        как это было у стеков, где объекты добавляются только сверху.</p>
    <p>Связный список относится к наиболее часто используемым структурам динамического хранения данных, потому
        реализован в
        стандартной библиотеке С++. Для его создания необходимо подключить библиотеку:</p>
    <pre class="cpp-code"><code class="language-cpp">#include &ltlist></code></pre>
    <p>Далее внутри функции main() создать этот связный список, например, таким образом:</p>
    <pre class="cpp-code"><code class="language-cpp">list&ltint>myList; //задается связный список с именем myList, который хранит целочисленные типы данных</code></pre>
    <p>Далее описано, как работает такая динамическая структура на примере связного списка, где хранится информация по
        книгам (название, автора и год издания).</p>
    <p>Для хранения этой информации хорошо подходит структура, в которой прописаны все эти элементы:</p>
    <pre class="cpp-code"><code class="language-cpp">typedef struct{
	char title[100];
	char author[50];
	short year;
} BOOK; //BOOK – данные, которые хранятся внутри объектов связного списка</code></pre>
    <p>Сами объекты будут представляться в виде следующей структуры:</p>
    <pre class="cpp-code"><code class="language-cpp">typedef struct tag_obj{
	BOOK b; // структура BOOK
	struct tag_obj* prev, * next; // два указателя
}
OBJ; // объекты связанного списка</code></pre>
    <p>Далее задается два главных указателя:</p>
    <pre class="cpp-code"><code class="language-cpp">OBJ* head = NULL, // указывает на первый объект
*tail = NULL; // указывает на последний объект</code></pre>
    <p>Изначально эти указатели равны нулю, что означает, что связанный список пока пуст, в нем нет еще никаких
        объектов.</p>
    <p>Теперь определим необходимые функции. Первая будет добавлять объект в список. Для этого будем передавать функции
        адрес на тот объект, после которого будет добавляться новый объект. И таким образом будем знать, куда добавлять
        новый объект. Это наглядно отображено на рисунке 7.6.</p>
    <p class="photo"><img src="./img/7_chapter/7.6.png" alt=""></p>
    <p class="signature">Рисунок 7.6 &#8211; Добавление элементов в список</p>
    <p>Сама функция выглядит следующим образом:</p>
    <pre class="cpp-code"><code class="language-cpp">void add_obj(OBJ* obj, BOOK book){}
//новая функция с именем add_obj
// имеет два аргумента</code></pre>
    <p>obj &#8211; указатель на тот объект, после которого добавляется новый объект, и структура book &#8211; данные,
        которые записываются в новый добавляемый объект</p>
    <pre class="cpp-code"><code class="language-cpp">OBJ* ptr = new OBJ; //в первой строчке этой функции создаем новый объект в памяти,
//и на этот объект указывает указатель *ptr
ptr - > b = book; //записываем информацию по книге в этот новый объект
// далее настраиваем указатели *next и *prev, причем указатель *prev должен указывать на предыдущий объект.
//Но на предыдущий объект указывает указатель *obj
ptr - > prev = obj; // указателю *prev приравниваем значению указателя obj,
//чтобы prev указывал на предыдущий объект
ptr - > next = (obj == NULL) ? NULL : obj - > next; //указателю *next присваиваем адреса следующего объекта
// и проверяем, чтобы указатель obj был не равен 0. Иначе это обозначало бы,
//что следующего элемента не существует. Cформированы связи на предыдущий и следующий объект
if (obj != NULL) { // если объект существует,
	obj - > next = ptr; // то obj присваиваем адрес этого объекта
	if (obj - > next != NULL) obj - > next - > prev = ptr; // проверяем, существует ли следующий объект
}
// возвращаем исходное значение глобальных указателей
if (ptr - > prev == NULL) head = ptr; //если у нового созданного объекта указатель равен нулю,
// то этот объект стоит в начале списка, и если это так, то head = ptr
if (ptr - > next == NULL) tail = ptr; //если у нового созданного объекта указатель равен нулю, то tail = ptr</code></pre>
    <p>Следующая функция будет удалять объекты из списка, ее схематичное представление изображено на рисунке 7.7.</p>
    <p class="photo"><img src="./img/7_chapter/7.7.png" alt=""></p>
    <p class="signature">Рисунок 7.7 &#8211; Схематичное представление функции, удаляющей объекты из списка</p>
    <p>Сама функция выглядит следующим образом:</p>
    <pre class="cpp-code"><code class="language-cpp">void del_obj(OBJ* obj){
	//в качестве аргумента мы передаем указатель на тот объект, который удаляем
	if (obj == NULL) return; //проверяется, если этот указатель равен нулю
	//(нет объекта, который нужно удалять), то выполняется оператор return, и функция на этом завершается
	OBJ* prev_obj = obj->prev; // формируем временный указатель на предыдущий объект
	OBJ* next_obj = obj->next; // формируем временный указатель на следующий объект
	cout << “Удален объект : ” << obj->b.title << endl; // выводим строчку, что удален такой-то объект
	delete obj; //удаляем объект, то есть освобождаем память, которую он занимает,
	//перенастраиваем связи с первым и последним объектом
	if (prev_obj != NULL) prev_obj->next = next_obj; //проверяем, что предыдущий объект существует,
    //если это так, то мы берем указатель *next предыдущего объекта
	//и приравниваем его к адресу следующего после удаляемого объекта,
	//в результате чего формируется новая связь
	else head = next_obj;
	if (next_obj != NULL) next_obj->prev = prev_obj; //аналогично
	else tail = prev_obj;
}</code></pre>
    <p>Результат выполнения данного программного кода представлен на рисунке 7.8.</p>
    <p class="photo"><img src="./img/7_chapter/7.8.png" alt=""></p>
    <p class="signature">Рисунок 7.8 &#8211; Пример работы со связным списком</p>
    <h3 id="7.1.2.2">7.1.2.2 Работа с двухсвязными линейными списками</h3>
    <p>Далее представлены возможные варианты работы со связанными списками. Например, имеется связанный список:</p>
    <pre class="cpp-code"><code class="language-cpp">struct Node{
	int d;
	Node* next;
	Node* prev;
};</code></pre>
    <p>На рисунке ниже даётся графическое представление двухсвязного списка.</p>
    <p class="photo"><img src="./img/7_chapter/7.9.png" alt=""></p>
    <p class="signature">Рисунок 7.9 &#8211; Графическое представление двухсвязного списка</p>
    <p>С данным списком можно реализовать различные операции. Далее рассмотрены варианты работы с двухсвязным
        списком:</p>
    <ol>
        <li>1) Как и в случае с односвязным списком, создадим две структуры. Тексты этих структур расположим в начале
            программы (до main() и других функций). Вот возможная реализация структур:
        </li>
    </ol>
    <pre class="cpp-code"><code class="language-cpp">struct Data{
	int a; // данные
};
struct List2{
	Data d;
	List2* prev; // указатель на предшествующий элемент
	List2* next; // указатель на последующий элемент
};</code></pre>
    <ol>
        <li>2) Затем создаём два указателя:</li>
    </ol>
    <pre class="cpp-code"><code class="language-cpp">List2 *Begin = NULL; // Начало списка
List2 *End   = NULL; // Конец списка</code></pre>
    <ol>
        <li>3) Теперь можно формировать какой-то начальный список. Делаем это по аналогии с тем, как делали при работе с
            односвязными списками. Начнём формировать список из трёх чисел 3, 5 и 1:
        </li>
    </ol>
    <pre class="cpp-code"><code class="language-cpp">// Создаём первый элемент
List2 *t = new List2;
t->d.a = 3;
t->prev = NULL;
t->next = NULL;
// Настроим на него оба указателя
Begin = t;
End = t;
// Создаём второй элемент
t->next = new List2;
List2 *p = t;
t = t->next;
t->prev = p;
t->d.a = 5;
t->next = NULL;
End = t;
// Создаём третий элемент
t->next = new List2;
p = t;
t = t->next;
t->prev = p;
t->d.a = 1;
t->next = NULL;
End = t;</code></pre>
    <p>Всё, список из трёх чисел создан. Приведём хотя бы некоторые действия с этим списком:</p>
    <ol>
        <li>а) Обход списка в прямом направлении и его вывод на экран монитора:</li>
    </ol>
    <pre class="cpp-code"><code class="language-cpp">void print_forward(List2* Begin){
    List2* p = Begin;
    cout << "Spisok (forward):" << endl;
    while (p){
        cout << p->d.a << endl;
        p = p->next;
    }
}</code></pre>
    <p>Возможный вызов функции:</p>
    <pre class="cpp-code"><code class="language-cpp">print_forward(Begin);</code></pre>
    <p>Как видим, полученная реализация по сути является копией функции print() для печати односвязного списка.</p>
    <ol>
        <li>б) Обход списка в обратном направлении и его вывод на экран монитора:</li>
    </ol>
    <pre class="cpp-code"><code class="language-cpp">void print_back(List2* End){
    List2* p = End;
    cout << "Spisok (back):" << endl;
    while (p){
        cout << p->d.a << endl;
        p = p->prev;
    }
}</code></pre>
    <p>Возможный вызов функции:</p>
    <pre class="cpp-code"><code class="language-cpp">print_back(End);</code></pre>
    <p>И здесь сходство большое. Важно обратить внимание на оператор, за счет которого выполняется движение назад:</p>
    <pre class="cpp-code"><code class="language-cpp">p = p->prev;</code></pre>
    <p>Далее приведена программа, которая формирует список из пяти чисел, добавляет число в список, удаляет число из
        списка
        и выводит список на экран. Указатель на начало списка обозначен pbeg, на конец списка &#8211; pend,
        вспомогательные
        указатели &#8211; pv и pkey.</p>
    <pre class="cpp-code"><code class="language-cpp">#include &ltiostream>
using namespace std;
struct Node{
	int d;
	Node* next;
	Node* prev;
};
Node* first(int d);
void add(Node** pend, int d);
Node* find(Node* const pbeg, int i);
bool remove(Node** pbeg, Node** pend, int key);
Node* insert(Node* const pbeg, Node** pend, int key, int d);
int main(){
	Node* pbeg = first(1); // Формирование первого элемента списка
	Node* pend = pbeg; // Список заканчивается, едва начавшись
	// Добавление в конец списка четырех элементов 2, 3, 4 и 5:
	for (int i = 2; i < 6; i++)add(&pend, i);
	// Вставка элемента 200 после элемента 2:
	insert(pbeg, &pend, 2, 200);
	// Удаление элемента 5:
	if (!remove(&pbeg, &pend, 5))cout << "не найден";
	Node* pv = pbeg;
	while (pv) { // вывод списка на экран
		cout << pv->d << ' ';
		pv = pv->next;
	}
	return 0;
}
// Формирование первого элемента
Node* first(int d) {
	Node* pv = new Node;
	pv->d = d; pv->next = 0; pv->prev = 0;
	return pv;
}
// Добавление в конец списка
void add(Node** pend, int d){
	Node* pv = new Node;
	pv->d = d; pv->next = 0; pv->prev = *pend;
	(*pend)->next = pv;
	*pend = pv;
}
// Поиск элемента по ключу
Node* find(Node* const pbeg, int d){
	Node* pv = pbeg;
	while (pv){
		if (pv->d == d)break;
		pv = pv->next;
	}
	return pv;
}
// Удаление элемента
bool remove(Node** pbeg, Node** pend, int key){
	if (Node* pkey = find(*pbeg, key)){ // 1
		if (pkey == *pbeg){ // 2
			*pbeg = (*pbeg)->next;
			(*pbeg)->prev = 0;
		}
		else if (pkey == *pend){ // 3
			*pend = (*pend)->prev;
			(*pend)->next = 0;
		}
		else{ // 4
			(pkey->prev)->next = pkey->next;
			(pkey->next)->prev = pkey->prev;
		}
		delete pkey;
		return true; // 5
	}
	return false; // 6
}
// Вставка элемента
Node* insert(Node* const pbeg, Node** pend, int key, int d){
	if (Node* pkey = find(pbeg, key)){
		Node* pv = new Node;
		pv->d = d;
		pv->next = pkey->next; // 1 – установление связи нового узла с последующим
		pv->prev = pkey; // 2 – установление связи нового узла с предыдущим
		pkey->next = pv; // 3 – установление связи предыдущего узла с новым
		if (pkey != *pend) (pv->next)->prev = pv; // 4 – установление связи последующего узла с новым
		// Обновление указателя на конец списка,
		// если узел вставляется в конец:
		else *pend = pv;
		return pv;
	}
	return 0;
}</code></pre>
    <p>Результат работы программы будет следующим: 1 2 200 3 4.</p>
    <p>Для удаления элемента из списка используется функция remove. Ее параметрами являются указатели на начало и конец
        списка и ключ элемента, подлежащего удалению. В строке 1 выделяется память под локальный указатель pkey,
        которому
        присваивается результат выполнения функции нахождения элемента по ключу find. Эта функция возвращает указатель
        на
        элемент в случае успешного поиска и 0, если элемента с таким ключом в списке нет. Если pkey получает не нулевое
        значение, условие в операторе if становится истинным (элемент существует) и управление передается оператору 2,
        если
        нет &#8211; выполняется возврат из функции со значением false (оператор 6).</p>
    <p>Удаление из списка происходит по-разному в зависимости от того, находится элемент в начале списка, в середине или
        в
        конце.</p>
    <p>В операторе 2 проверяется, находится ли удаляемый элемент в начале списка &#8211; в этом случае следует
        скорректировать
        указатель pbeg на начало списка так, чтобы он указывал на следующий элемент в списке, адрес которого находится в
        поле next первого элемента. Новый начальный элемент списка должен иметь в своем поле указателя на предыдущий
        элемент
        значение 0. Если удаляемый элемент находится в конце списка (оператор 3), требуется сместить указатель pend
        конца
        списка на предыдущий элемент, адрес которого можно получить из поля prev последнего элемента. Кроме того, нужно
        обнулить для нового последнего элемента указатель на следующий элемент. Если удаление происходит из середины
        списка, то единственное, что надо сделать, &#8211; обеспечить двустороннюю связь предыдущего и последующего
        элементов.
        После корректировки указателей память из-под элемента освобождается, и функция возвращает значение true.</p>
    <p>Работа функции вставки элемента в список представлена на рисунке 7.10. Номера около стрелок соответствуют номерам
        операторов в комментариях.</p>
    <p class="photo"><img src="./img/7_chapter/7.10.png" alt=""></p>
    <p class="signature">Рисунок 7.10 &#8211; Вставка элемента в список</p>
    <p>Сортировка связанного списка заключается в изменении связей между элементами. Алгоритм состоит в том, что
        исходный
        список просматривается, и каждый элемент вставляется в новый список на место, определяемое значением его
        ключа.</p>
    <h3 id="7.1.3">7.1.3 Кольцевой список</h3>
    <p>Кольцевой список &#8211; это список, у которого последний элемент связан с первым. Кольцевой список можно сделать
        как
        односвязным, так и двухсвязным. Рассмотрим вкратце односвязный кольцевой список:</p>
    <p>Схема кольцевого списка представлена на рисунке ниже (список из чисел 3, 5, 1, 9):</p>
    <p class="photo"><img src="./img/7_chapter/7.11.png" alt=""></p>
    <p class="signature">Рисунок 7.11 &#8211; Схема кольцевого списка</p>
    <p>Используя те же структуры (Data и List), что применяли для односвязного списка, определяем указатель на начало
        будущего списка:</p>
    <pre class="cpp-code"><code class="language-cpp">List *u = NULL;</code></pre>
    <p>и также делаем начальное заполнение списка. Но в конце, после того, как для нашего примера мы занесли число 9 в
        список, требуется «замкнуть» список на начало:</p>
    <pre class="cpp-code"><code class="language-cpp">x->next = u;</code></pre>
    <p>В итоге будет получен кольцевой список.</p>
    <p>Операции для кольцевого списка можно выполнять те же, что и для обычного списка, но здесь будет присутствовать
        одна
        особенность: список замкнут, поэтому проверка того факта, что достигнут конец цикла, выполняется по-другому.
        Покажем
        это на примере распечатки кольцевого цикла:</p>
    <pre class="cpp-code"><code class="language-cpp">void printC(List* u){
    if (u != NULL){
        List* p = u;
        cout << "Kolcevoj Spisok:" << endl;
        cout << p->d.a << endl;
        p = p->next;
        while (p != u){
            cout << p->d.a << endl;
            p = p->next;
        }
    }
    else
        cout << "Spisok pust." << endl;
}</code></pre>
    <p>Возможный вызов функции:</p>
    <pre class="cpp-code"><code class="language-cpp">printC(u);</code></pre>
    <p>Как видно из примера, после печати первого элемента мы печатаем не до конца списка, а до нахождения начала.</p>
    <p>На видео 15 представлена лекция по связным спискам.</p>
    <video controls="controls" poster="./img/video.jpg" src="./video/video_15_l.mp4"></video>
    <p class="signature">Видео 15 &#8211; Связные списки</p>
    <h3 id="7.2">7.2 Использование стеков в С++</h3>
    <p>Стек &#8211; это частный случай однонаправленного списка, добавление элементов в который и выборка из которого
        выполняются
        с одного конца, называемого вершиной стека. При выборке элемент исключается из стека. Говорят, что стек
        реализует
        принцип обслуживания LIFO (последним пришел &#8211; первым ушел). Стек проще всего представить себе как закрытую
        с
        одного
        конца узкую трубу, в которую бросают мячи. Достать первый брошенный мяч можно только после того, как вынуты все
        остальные. Кстати, сегмент стека назван так именно, потому что память под локальные переменные выделяется по
        принципу LIFO. Стеки широко применяются в системном программном обеспечении, компиляторах, в различных
        рекурсивных
        алгоритмах.</p>
    <p>Рассмотрим подробнее структуру стека. Схематично стек можно изобразить следующим образом (рисунок 7.12).</p>
    <p class="photo"><img src="./img/7_chapter/7.12.png" alt=""></p>
    <p class="signature">Рисунок 7.12 &#8211; Схематичное изображение стека</p>
    <p>На рисунке 7.12 большими прямоугольниками отображены отдельные объекты стека, а прямоугольники внутри &#8211; это
        данные.
        Кроме того, в каждом объекте стека есть указатель *next, который содержит адрес следующего объекта стека, а у
        последнего объекта этот указатель всегда равен нулю.</p>
    <p>Для стека используются следующие правила:</p>
    <ol>
        <li class="without-parentheses">новый объект всегда добавляется на верх стека;</li>
        <li class="without-parentheses">удаление выполняется с верхнего объекта стека.</li>
    </ol>
    <p>В стандартной библиотеке языка С++ стек уже реализован. Для того чтобы его использовать в программе, достаточно
        подключить библиотеку #include &ltstack> и далее создать сам стек std::stack&ltint>s;.</p>
    <pre class="cpp-code"><code class="language-cpp">#include &ltstack>
std::stack&ltint>s</code></pre>
    <p>В результате будет создан стек с именем s, который может хранить целочисленные типы данных:</p>
    <p>Далее приведен пример динамической структуры, в которой в качестве данных хранятся имя сотрудника и его
        возраст.</p>
    <pre class="cpp-code"><code class="language-cpp">typedef struct{
	char name[50]; // имя
	short old; // фамилия
} DATA;  // структура будет представлять тип DATA</code></pre>
    <p>Сами объекты стека тоже будут представлять структуру, в которую вложена первая структура и объявлен указатель
        next:</p>
    <pre class="cpp-code"><code class="language-cpp">typedef struct tad_obj{
	DATA d; //первая вложенная структура
	struct tad_obj* next; //тип указателя next, соответствует типу OBJ
} OBJ;</code></pre>
    <p>Необходимые структуры определены. Далее задан глобальный указатель *top, который будет всегда указывать на самый
        верхний объект стека. Присвоим ему значение ноль. Ноль будет означать, что объекта стека не существует, что он
        пустой и в нем нет никаких объектов:</p>
    <pre class="cpp-code"><code class="language-cpp">OBJ* top = NULL;</code></pre>
    <p>Теперь зададим две функции, первая функция будет добавлять объекты в стек, а вторая будет удалять объекты из
        стека.</p>
    <p>Функция помещения в стек по традиции называется push, а выборки &#8211; pop. Указатель для работы со стеком (top)
        всегда
        ссылается на его вершину.</p>
    <p>Первая функция выглядит таким образом. Её название &#8211; push, и она имеет один аргумент (DATA):</p>
    <pre class="cpp-code"><code class="language-cpp">OBJ *push(DATA d)</code></pre>
    <p>Следующая функция будет удалять верхний объект из стека. Её название &#8211; pop.</p>
    <p>Далее показан пример работы этих функций:</p>
    <pre class="cpp-code"><code class="language-cpp">OBJ* push(DATA d){
	OBJ* ptr = new OBJ; //создаем новый объект
	ptr->d = d;//записываем данный во вложенную структуру
	ptr->next = top;//связывает указатели *next и *top
	top = ptr;//перемещает указатель *top на самый верхний объект стека
	return ptr;//возвращает адрес нового объекта
}</code></pre>
    <p class="photo"><img src="./img/7_chapter/7.13.png" alt=""></p>
    <p class="signature">Рисунок 7.13 &#8211; Схематичное описание функции push</p>
    <pre class="cpp-code"><code class="language-cpp">void pop(){
	if (top == NULL) return;//проверка: если указатель равен 0,
	//то ничего делать не нужно, а последующие операторы выполняться не будут
	OBJ* ptr = top->next;//временный указатель, который будет указывать на следующий объект стека
	cout << "Объект" << top->d.name << "удален\n";
	delete top;
	top = ptr;//перемещаем *top на следующий объект
}</code></pre>
    <p class="photo"><img src="./img/7_chapter/7.14.png" alt=""></p>
    <p class="signature">Рисунок 7.14 &#8211; Схематичное описание функции pop</p>
    <p>Теперь определим третью функцию &#8211; show, которая будет отображать объекты нашего стека на экране:</p>
    <pre class="cpp-code"><code class="language-cpp">void show(){
	//задаем функцию
	OBJ* c = top;//создаем временный указатель с, который будет указывать на самый верхний объект стека
	while (c != NULL) { //в качестве его проверки стоит условие, пока этот указатель с не равен 0
		cout << c->d.name << " " << c->d.old << endl;//выводим текущий объект стека на экран
		c = c->next;// перемещает этот указатель с на следующий объект стека
	}
}
int main()
{
	setlocale(LC_ALL, "rus");
	DATA d = { "Иван" , 20 };//задали структуру d и прописали туда конкретные значения
	push(d);//этой функцией создаем первый объект стека и в качестве аргумента передаем ей нашу структуру d
	strcpy_s(d.name, "Николай");
	d.old = 30;
	push(d);//создаем второй объект стека
	strcpy_s(d.name, "Анатолий");
	d.old = 50;
	push(d);//третий объект стека
	show();//отобразим наш стек на экране
	while (top != NULL) pop();//удалим все объекты нашего стека
	return 0;
}</code></pre>
    <p class="photo"><img src="./img/7_chapter/7.15.png" alt=""></p>
    <p class="signature">Рисунок 7.15 &#8211; Пример работы со стеком</p>
    <p>Когда мы работаем в языке С++, то для работы со стеками можно воспользоваться стандартной библиотекой. Реализация
        рассмотренного примера создания стека с использованием стандартной библиотеки С++ представлена ниже:</p>
    <pre class="cpp-code"><code class="language-cpp">#include &ltiostream>
#include &ltstack>
using namespace std;
typedef struct{
    //задали структуру, которая будет хранить ту же самую информацию
	char name[50];
	short old;
} DATA;
int main() {
	setlocale(LC_ALL, "rus");
	stack &ltDATA> s; //создаем стек, в < > скобках задан тот тип данных,
    // который будет храниться в каждом объекте стека, а далее переменная,
    // через которую мы будем работать с этим стеком
	DATA d = { "Иван" , 20 }; //задаем такую структуру и прописывает туда конкретные данные
	s.push(d); // с помощью push создаем первый объект стека
	strcpy_s(d.name, "Николай");
	d.old = 30;
	s.push(d); //второй объект
	strcpy_s(d.name, "Анатолий");
	d.old = 50;
	s.push(d); // третий объект
	cout << "Размер стека : " << s.size() << endl << endl;
	while (!s.empty()) {
		d = s.top();
		cout << "Удаление объекта : " << d.name << " " << d.old << endl;
		s.pop();
	}
	return 0;
}</code></pre>
    <p>Результат выполнения данного программного кода представлен на рисунке 7.16.</p>
    <p class="photo"><img src="./img/7_chapter/7.16.png" alt=""></p>
    <p class="signature">Рисунок 7.16 &#8211; Работа со стеками с помощью стандартной библиотеки C++</p>
    <p>В данном примере в самом начале задана та же структура, которая будет хранить информацию. Далее создается стек.
        Указывается тип данных, в которых будет храниться каждый элемент стека. Затем создается эта структура,
        записываем
        туда конкретные данные. И с помощью функции push создаем первый объект стека:</p>
    <pre class="cpp-code"><code class="language-cpp">s.push(d)</code></pre>
    <p>Далее изменяются данные с помощью strcpy:</p>
    <pre class="cpp-code"><code class="language-cpp">strcpy_s(d.name, "Николай");
d.old = 30;</code></pre>
    <p>Затем задается второй объект с помощью функции push, опять меняется и создается третий объект. Затем выводится
        размер
        стека:</p>
    <pre class="cpp-code"><code class="language-cpp">s.size()</code></pre>
    <p>Он должен быть равен трем элементам. Затем с помощью цикла while удаляются все объекты из стека. В качестве
        параметра
        задается цикл, пока стек не пустой. Для этого берутся данные из самого верхнего объекта стека, отображаются на
        экране, и удаляется верхний объект стека:</p>
    <pre class="cpp-code"><code class="language-cpp">d = s.top();
cout << "Удаление объекта: " << d.name << " " << d.old << endl;
s.pop ();</code></pre>
    <p>То есть на следующей итерации верхний объекта стека будет следующим. И так далее, пока не удалятся все объекты.
        Размер стека равен трем. Было выполнено удаление объектов.</p>
    <p>Далее представлен еще один пример программы, которая формирует стек из пяти целых чисел (1, 2, 3, 4, 5) и выводит
        его
        на экран:</p>
    <pre class="cpp-code"><code class="language-cpp">#include &ltiostream>
using namespace std;
struct Node{
	int d;
	Node* p;
};
Node* first(int d);
void push(Node** top, int d);
int pop(Node** top);
int main(){
	Node* top = first(1);
	for (int i = 2; i < 6; i++)push(&top, i);
	while (top)
		cout << pop(&top) << ' ';
	return 0;
}
// Начальное формирование стека
Node* first(int d){
	Node* pv = new Node;
	pv->d = d;
	pv->p = 0;
	return pv;
}
// Занесение в стек
void push(Node** top, int d){
	Node* pv = new Node;
	pv->d = d;
	pv->p = *top;
	*top = pv;
}
// Выборка из стека
int pop(Node** top){
	int temp = (*top)->d;
	Node* pv = *top;
	*top = (*top)->p;
	delete pv;
	return temp;
}</code></pre>
    <p>Результат работы программы: 5 4 3 2 1.</p>
    <p>На видео 16 представлена лекция по стеку.</p>
    <video controls="controls" poster="./img/video.jpg" src="./video/video_16_l.mp4"></video>
    <p class="signature">Видео 16 &#8211; Стек</p>
    <h3 id="7.3">7.3 Очереди</h3>
    <p><a href="glossary.html#m9">Очередь</a> &#8211; это частный случай однонаправленного списка, добавление элементов в который выполняется в один
        конец,
        а выборка &#8211; из другого конца. Другие операции с очередью не определены. При выборке элемент исключается из
        очереди.</p>
    <p>Очередь реализует принцип обслуживания FIFO (first in &#8211; first out, первым пришел &#8211; первым ушел).
        Очередь
        проще всего
        представить себе, постояв в ней час-другой. В программировании очереди применяются, например, в моделировании,
        диспетчеризации задач операционной системой, буферизованном вводе/выводе.</p>
    <p>Функция помещения в конец очереди называется add, а выборки &#8211; del. Указатель на начало очереди называется
        pbeg,
        указатель на конец &#8211; pend.</p>
    <p>Далее представлен пример программы, которая формирует очередь из пяти целых чисел и выводит его на экран:</p>
    <pre class="cpp-code"><code class="language-cpp">#include &ltiostream>
using namespace std;
struct Node{
	int d;
	Node* p;
};
Node* first(int d);
void add(Node** pend, int d);
int del(Node** pbeg);
int main(){
	Node* pbeg = first(1);
	Node* pend = pbeg;
	for (int i = 2; i < 6; i++)add(&pend, i);
	while (pbeg)
		cout << del(&pbeg) << ' ';
	return 0;
}
// Начальное формирование очереди
Node* first(int d){
	Node* pv = new Node;
	pv->d = d;
	pv->p = 0;
	return pv;
}
// Добавление в конец
void add(Node** pend, int d){
	Node* pv = new Node;
	pv->d = d;
	pv->p = 0;
	(*pend)->p = pv;
	*pend = pv;
}
// Выборка
int del(Node** pbeg){
	int temp = (*pbeg)->d;
	Node* pv = *pbeg;
	*pbeg = (*pbeg)->p;
	delete pv;
	return temp;
}</code></pre>
    <p>Результат работы программы будет слудеющим: 1 2 3 4 5.</p>
    <h3 id="7.4">7.4 Бинарные деревья</h3>
    <p><a href="glossary.html#m1">Бинарное дерево</a> &#8211; это динамическая структура данных, состоящая из узлов, каждый из которых содержит, кроме
        данных,
        не более двух ссылок на различные бинарные деревья. На каждый узел имеется ровно одна ссылка. Начальный узел
        называется корнем дерева. Узел, не имеющий поддеревьев, называется листом. Исходящие узлы называются предками,
        входящие &#8211; потомками. Высота дерева определяется количеством уровней, на которых располагаются его узлы.
        Если
        дерево
        организовано таким образом, что для каждого узла все ключи его левого поддерева меньше ключа этого узла, а все
        ключи
        его правого поддерева больше, оно называется деревом поиска. Одинаковые ключи не допускаются. В дереве поиска
        можно найти элемент по ключу, двигаясь от корня и переходя на левое или правое поддерево в зависимости от
        значения
        ключа в каждом узле.</p>
    <p class="photo"><img src="./img/7_chapter/7.17.png" alt=""></p>
    <p class="signature">Рисунок 7.17 &#8211; Бинарное дерево</p>
    <p>Дерево является рекурсивной структурой данных, поскольку каждое поддерево также является деревом. Действия с
        такими
        структурами изящнее всего описываются с помощью рекурсивных алгоритмов. Например, функцию обхода всех узлов
        дерева в
        общем виде можно описать так:</p>
    <pre class="cpp-code"><code class="language-cpp">function way_around(дерево){
	way_around(левое поддерево)
		посещение корня
		way_around(правое поддерево)
}</code></pre>
    <p>Можно обходить дерево и в другом порядке, например, сначала корень, потом поддеревья, но приведенная функция
        позволяет получить на выходе отсортированную последовательность ключей, поскольку сначала посещаются вершины с
        меньшими ключами, расположенные в левом поддереве. Результат обхода дерева: 1, 6, 8, 10, 20, 21, 25, 30.</p>
    <p>Если в функции обхода первое обращение идет к правому поддереву, результат обхода будет другим: 30, 25, 21, 20,
        10,
        8, 6, 1.</p>
    <p>Таким образом, деревья поиска можно применять для сортировки значений. При обходе дерева узлы не удаляются.</p>
    <p>Для бинарных деревьев определены операции:</p>
    <ol>
        <li class="with-a-dash">включения узла в дерево;</li>
        <li class="with-a-dash">поиска по дереву;</li>
        <li class="with-a-dash">обхода дерева;</li>
        <li class="with-a-dash">удаления узла.</li>
    </ol>
    <p>Для каждого рекурсивного алгоритма можно создать его не рекурсивный эквивалент.</p>
    <p>В приведенной ниже программе реализована не рекурсивная функция поиска по дереву и <a href="glossary.html#m9">рекурсивная функция</a> обхода
        дерева. Первая функция осуществляет поиск элемента с заданным ключом. Если элемент найден, она возвращает
        указатель на него, а если нет &#8211; включает элемент в соответствующее место дерева и возвращает указатель на
        него. Для
        включения элемента необходимо помнить пройденный по дереву путь на один шаг назад и знать, выполняется ли
        включение
        нового элемента в левое или правое поддерево его предка.</p>
    <p>Программа формирует дерево из массива целых чисел и выводит его на экран:</p>
    <pre class="cpp-code"><code class="language-cpp">#include &ltiostream>
using namespace std;
struct Node{
	int d;
	Node* left;
	Node* right;
};
Node* first(int d);
Node* search_insert(Node* root, int d);
void print_tree(Node* root, int l);
int main(){
	int b[] = { 10, 25, 20, 6, 21, 8, 1, 30 };
	Node* root = first(b[0]);
	for (int i = 1; i < 8; i++)search_insert(root, b[i]);
	print_tree(root, 0);
	return 0;
}
// Формирование первого элемента дерева
Node* first(int d) {
	Node* pv = new Node;
	pv->d = d;
	pv->left = 0;
	pv->right = 0;
	return pv;
}
// Поиск с включением
Node* search_insert(Node* root, int d){
	Node* pv = root, * prev;
	bool found = false;
	while (pv && !found){
		prev = pv;
		if (d == pv->d) found = true;
		else if (d < pv->d) pv = pv->left;
		else pv = pv->right;
	}
	if (found) return pv;
	// Создание нового узла:
	Node* pnew = new Node;
	pnew->d = d;
	pnew->left = 0;
	pnew->right = 0;
	if (d < prev->d)
		prev->left = pnew; // Присоединение к левому поддереву предка
	else
		prev->right = pnew; // Присоединение к правому поддереву предка
	return pnew;
}
// Обход дерева
void print_tree(Node* p, int level){
	if (p){
		print_tree(p->left, level + 1); // вывод левого поддерева
		for (int i = 0; i < level; i++)cout << " ";
		cout << p->d << endl; // вывод корня поддерева
		print_tree(p->right, level + 1); // вывод правого поддерева
	}
}</code></pre>
    <p>Результат работы программы представлен на рисунке 7.18.</p>
    <p class="photo"><img src="./img/7_chapter/7.18.png" alt=""></p>
    <p class="signature">Рисунок 7.18 &#8211; Результат работы программы с бинарным деревом</p>
    <p>Текущий указатель для поиска по дереву обозначен pv, указатель на предка pv обозначен prev, переменная pnew
        используется для выделения памяти под включаемый в дерево узел. Рекурсии удалось избежать, сохранив всего одну
        переменную (prev) и повторив при включении операторы, определяющие, к какому поддереву присоединяется новый
        узел.</p>
    <p>Вторым параметром в функцию обхода дерева передается целая переменная, определяющая, на каком уровне находится
        узел.
        Корень находится на уровне 0.</p>
    <p>Дерево печатается по горизонтали так, что корень находится слева. Перед значением узла для имитации структуры
        дерева
        выводится количество пробелов, пропорциональное уровню узла.</p>
    <p>Если закомментировать цикл печати пробелов, отсортированный по возрастанию, массив будет выведен в столбик.
        Заметьте,
        что функция обхода дерева длиной всего в несколько строк может напечатать дерево любого размера &#8211; важно
        только
        следить, чтобы рекурсивные вызовы не переполнили стек.</p>
    <p>Удаление узла из дерева представляет собой не такую простую задачу, поскольку удаляемый узел может быть корневым,
        содержать две, одну или ни одной ссылки на поддеревья. Для узлов, содержащих меньше двух ссылок, удаление
        тривиально.Чтобы сохранить упорядоченность дерева при удалении узла с двумя ссылками, его заменяют на узел с
        самым близким к
        нему ключом. Это может быть самый левый узел его правого поддерева или самый правый узел левого поддерева.</p>
    <p>Далее представлен пример работы еще с одним бинарным деревом. Реализована программа, которая будет обрабатывать
        входную строку, и составлять для неё алфавитно-частотный словарь.</p>
    <p>Для реализации программы объявляется глобальная структура voc, на основе которой будет создаваться бинарное
        дерево.
        Структура содержит поле sim (тип char) для хранения буквы, поле col (типа int), также два указателя на правую и
        левую
        ветвь. Также описаны две внешние функции для работы с бинарным деревом: первая &#8211; для добавления нового
        элемента в
        дерево и подсчета частоты встречаемости, вторая &#8211; для вывода дерева на экран от левого крайнего листа до
        крайнего
        правого. В main функции считывается строка, создается указатель на корень дерева (первая буква в строке), и
        далее
        проход по строке, постепенно добавляя все символы, исключая пробелы. После прохода по строке вызывается функция
        для
        вывода дерева.</p>
    <p>Код программы:</p>
    <pre class="cpp-code"><code class="language-cpp">#include &ltiostream>
#include &ltstring>
using namespace std;
struct voc{
	char sim;
	int col = 0;
	voc* l;    //левая и правая часть дерева
	voc* r;
};
//функция записи элемента в бинарное дерево
void add(voc*& r, char s){
	if (r == NULL){
		r = new voc;     //выделяем память
		r->sim = s;    //помещаем в выделенное место аргумент s
		r->col++;
		r->l = NULL;    //присваиваем указателям на ветви нулевые значения
		r->r = NULL;
		return;
	}
	if (s > r->sim){     //если значение символа больше, чем то, которое
		add(r->r, s);    // находится в листе, то добавляем в левую ветвь
		return;
	}
	if (s < r->sim){
		add(r->l, s);
		return;
	}
	if (s == r->sim){
		r->col++;
		return;
	}
}
void print(voc* r){
	//функция отображение дерева
	if (r != NULL){
		print(r->l);
		cout << r->sim << ' ' << r->col << endl;  //показываем элемент
		print(r->r);
	}
}
int main(){
	string s;
	voc* r = new voc;
	getline(cin, s);
	int i = 0;
	r->sim = s[i];
	r->col++;
	r->l = NULL;
	r->r = NULL;
	i++;
	while (i != s.length()){
		if (s[i] != ' '){
			add(r, s[i]); //добавляем элементы в дерево и считаем их количество
		}
		i++;
	}
	print(r);
	return 0;
}</code></pre>
    <p>Пример реализации программы представлен на рисунках 7.19-7.21.</p>
    <p>Входные данные: Adfse dsfsdf .sadasds efefef.</p>
    <p class="photo"><img src="./img/7_chapter/7.19.png" alt=""></p>
    <p class="signature">Рисунок 7.19 &#8211; Пример реализации программы</p>
    <p>Входные данные: LLLLlllfffrrrgg.fgrgr.</p>
    <p class="photo"><img src="./img/7_chapter/7.20.png" alt=""></p>
    <p class="signature">Рисунок 7.20 &#8211; Пример реализации программы</p>
    <p>Входные данные: Print some phrase.!</p>
    <p class="photo"><img src="./img/7_chapter/7.21.png" alt=""></p>
    <p class="signature">Рисунок 7.21 &#8211; Пример реализации программы</p>
     <p>На видео 17 представлена лекция по бинарным деревьям.</p>
    <video controls="controls" poster="./img/video.jpg" src="./video/video_17_l.mp4"></video>
    <p class="signature">Видео 17 &#8211; Бинарные деревья</p>
    <h3 id="7.5">7.5 Контрольные вопросы для закрепления изученного материала</h3>
    <ol>
        <li class="with-a-bracket">Что такое связные списки?</li>
        <li class="with-a-bracket">Что такое стек?</li>
        <li class="with-a-bracket">Какие операции можно выполнять над списками?</li>
        <li class="with-a-bracket">Какие стандартные функции используются для создания и удаления элементов списка?</li>
        <li class="with-a-bracket">Что такое очередь?</li>
    </ol>
</script>

<script id="page7.6" type="text/html">
    <TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0>
        <TR>
            <TD width="50%"><a name="3"></a>
                <HR>
                <div align=justify><h1>Тренировочные упражнения</h1></div>
  <form>
   <ol> 
   	<li class="without-parentheses"> Напишите возможный вызов функции, указанной в программном коде:
   	 <pre class="cpp-code"><code class="language-cpp">
void Add_Beg(List** u, Data& x){
	List* t = new List;
	t->d.a = x.a;
	t->next = *u;
	*u = t;
}
</code></pre>  
              <p>Ответ: <input type="text" id="glav7_1"></p>
               <input type="button" value="Ответить" class="proverit_glav_7_1"></input>
              <input type="reset" value ="Очистить"></input>
              <br><br>
                 <div id="resultat_7_1"></div>
                  </form>
              </li><br><br>
              <form>
<li class="without-parentheses"> Дополните пропуски в коде, чтобы программа по работе со стеком выдала результат, указанный на рисунке. 
<pre class="cpp-code"><code class="language-cpp">
#include &ltiostream>
#include <<input type="text" id="glav7_1_1" size="5">>
using namespace std;
typedef struct{
	char name[50];
	short old;
} DATA;
int main() {
	setlocale(LC_ALL, "rus");
	stack &ltDATA> s; 
	DATA d = { "Иван" , 20 }; //задаем такую структуру и прописывает туда конкретные данные
	s.push(d); // с помощью push создаем первый объект стека
	strcpy_s(d.name, "Николай");
	<input type="text" id="glav7_1_2" size="5">= 30;
	s.push(d); //второй объект
	<input type="text" id="glav7_1_3" size="4"> (d.name, "Анатолий");
	d.old = 50;
	s.push(<input type="text" id="glav7_1_4" size="1">); // третий объект
	cout << "Размер стека : " << <input type="text" id="glav7_1_5" size="5">() << endl << endl;
	while (!s.empty()) {
		d = s.top();
		cout << "Удаление объекта : " << d.name << " " << d.old << endl;
		s.pop();
	}
	return 0;
}
</code></pre>  
<p class="photo"><img src="./img/7_chapter/7.22.png" alt=""></p>

 <input type="button" value="Ответить" class="proverit_glav_7_2"></input>
              <input type="reset" value ="Очистить"></input>
              <br><br>
                 <div id="resultat_7_2"></div>
</form></li>
     	     </ol>
 </HR></TD></TR></TABLE>
</script> 
<script id="page7.7" type="text/html">
    <TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0>
        <TR>
            <TD width="50%"><a name="3"></a>
                <HR>
                <div align=justify><h1 align="center">Тестирование по седьмой главе</h1></div>
                <form name=test>
                    <ol>
                        <li>
                            <h4><input type=text name=T1 style="height: 15px; width:15px;" value=''> Линейный список, в
                                котором доступен только последний элемент, называется:</h4>
                            <input type=radio name=Q1> стеком;<br>
                            <input type=radio name=Q1> очередью;<br>
                            <input type=radio name=Q1> деком;<br>
                            <input type=radio name=Q1> массивом;<br>
                            <input type=radio name=Q1> кольцом.<br>
                            <br>
                        </li>
                        <li>
                            <h4><input type=text name=T2 style="height: 15px; width:15px;" value=''> Структура данных,
                                работа с элементами которой организована по принципу FILO (первый пришел – последним
                                ушел), это:</h4>
                            <input type=radio name=Q2> стек;<br>
                            <input type=radio name=Q2> дек;<br>
                            <input type=radio name=Q2> очередь;<br>
                            <input type=radio name=Q2> список;<br>
                            <input type=radio name=Q2> нет верного ответа.<br>
                            <br>
                        </li>
                        <li>
                            <h4><input type=text name=T3 style="height: 15px; width:15px;" value=''> На что должны быть
                                объявлены указатели в линейном списке?</h4>
                            <input type=radio name=Q3> head, tail;<br>
                            <input type=radio name=Q3> head body;<br>
                            <input type=radio name=Q3> header footer;<br>
                            <input type=radio name=Q3> left right.<br>
                            <input type=radio name=Q3> нет верного ответа.<br>
                            <br>
                        </li>
                        <li>
                            <h4><input type=text name=T4 style="height: 15px; width:15px;" value=''> Какое правильное
                                объявление списка на C++?</h4>
                            <input type=radio name=Q4> List&lt;string&gt; list =new List&lt;string&gt;();<br>
                            <input type=radio name=Q4>
                            <pre class="cpp-code"><code class="language-cpp">struct Node{
   float data; // Данные.
   Node *Next, *Prev; // Указатели на следующий и предыдущий элементы.
};</code></pre>
                            <input type=radio name=Q4> LinkedList list = List.CreateList();<br>
                            <input type=radio name=Q4> MakeList(*tail, *head);<br>
                            <input type=radio name=Q4> нет верного ответа.<br>
                            <br>
                        </li>
                        <li>
                            <h4><input type=text name=T5 style="height: 15px; width:15px;" value=''> Какая команда
                                используется для добавления элемента в конец связанного списка?</h4>
                            <input type=radio name=Q5> pop_back();<br>
                            <input type=radio name=Q5> pop_down();<br>
                            <input type=radio name=Q5> push_back();<br>
                            <input type=radio name=Q5> push_down();<br>
                            <input type=radio name=Q5> нет верного ответа.<br>
                            <br>
                        </li>
                        <li>
                            <h4><input type=text name=T6 style="height: 15px; width:15px;" value=''> В чем особенность
                                бинарного дерева поиска?</h4>
                            <input type=radio name=Q6> степень исходов вершин равна 2 или 0;<br>
                            <input type=radio name=Q6> значение в любой вершине не меньше, чем значения её потомков;<br>
                            <input type=radio name=Q6> для каждого узла все ключи его левого поддерева меньше ключа
                            этого узла, а все ключи его правого поддерева &mdash; больше;<br>
                            <input type=radio name=Q6> для узлов используются одинаковые ключи;<br>
                            <input type=radio name=Q6> нет верного ответа.<br>
                            <br>
                        </li>
                        <li>
                            <h4><input type=text name=T7 style="height: 15px; width:15px;" value=''> Как объявить вектор
                                элементов целых чисел?</h4>
                            <input type=radio name=Q7> std::vector&lt;int&gt; myVector;<br>
                            <input type=radio name=Q7> std::vector(int) myVector;<br>
                            <input type=radio name=Q7> std::vector integer myVector;<br>
                            <input type=radio name=Q7> int vector myVector;<br>
                            <input type=radio name=Q7> нет верного ответа.<br>
                            <br>
                        </li>
                        <li>
                            <h4><input type=text name=T8 style="height: 15px; width:15px;" value=''> Какое значение
                                будет напечатано?</h4>
                            <pre class="cpp-code"><code class="language-cpp">#include &ltiostream&gt;
const int x = 12;
int main (intargc, char **argv){
    enum dog{
        x = x,
        y
    };
    std::cout << y << std::endl;
    return 0;
}</code></pre>
                            <input type=radio name=Q8> неопределенное;<br>
                            <input type=radio name=Q8> 12;<br>
                            <input type=radio name=Q8> 0;<br>
                            <input type=radio name=Q8> 13;<br>
                            <input type=radio name=Q8> 11.<br>
                            <br>
                        </li>
                        <li>
                            <h4><input type=text name=T9 style="height: 15px; width:15px;" value=''> Обязательными
                                элементами словаря являются:</h4>
                            <input type=radio name=Q9> ключ-функция;<br>
                            <input type=radio name=Q9> ключ-объект;<br>
                            <input type=radio name=Q9> ключ-выражение;<br>
                            <input type=radio name=Q9> ключ-метод;<br>
                            <input type=radio name=Q9> ключ-значение.<br>
                            <br>
                        </li>
                        <li>
                            <h4><input type=text name=T10 style="height: 15px; width:15px;" value=''> Метод для удаления
                                значения из словаря:</h4>
                            <input type=radio name=Q10> insert;<br>
                            <input type=radio name=Q10> count;<br>
                            <input type=radio name=Q10> max;<br>
                            <input type=radio name=Q10> erase;<br>
                            <input type=radio name=Q10> find.<br>
                            <br>
                        </li>
                    </ol>
                    <div align="center">
                        <div>
                            <input type=button value="Показать результат" onClick="test1('MTExMjMzMTQ1NA', 10)">
                        </div>
                        <div>
                            <textarea style="margin-top:6px" rows=5 cols="100%" name=s1></textarea>
                        </div>
                        <div>
                            <input type=reset value="Очистить выбранные пункты">
                        </div>
                        <br>
                        <Div align=center>
                            <a href="#3">В начало страницы</a>
                        </div>
                        <br>
                    </div>
                </form>
            </TD>
        </TR>
    </TABLE>
</script>

<!-- /page8 -->
<script id="page8" type="text/html">
    <h2 id="8">8 Работа с файлами в С++</h2>
    <h3 id="8.1">8.1 Функции записи и чтения из файлов</h3>
    <p>В большинстве своем файлы представляют собой именованные области внешней (дисковой) памяти, с которыми программы
        могут обмениваться информацией. Необходимость в таких обменах, во-первых, возникает, когда объем оперативной
        памяти недостаточен для хранения нужной информации. Во-вторых, программа может воспользоваться данными,
        полученными
        ранее другой программой и предусмотрительно записанными на диск. Наконец, в программах, требующих во время своей
        работы ввод исходных данных достаточно большого объема, целесообразно считывать эти данные из файла &#8211;
        данные в
        файле
        можно подготовить заблаговременно и тщательно выверить.</p>
    <p>Язык С++, как и большинство языков высокого уровня, позволяет работать с файлами, то есть сохранять и считывать
        долгосрочные данные, доступные после выключения компьютера. Обычно файлы располагаются на жестком диске или
        флэшке. В базовом варианте языка С++ для открытия файла на чтение или запись используется функция.</p>
    <pre class="cpp-code"><code class="language-cpp">FILE* fopen(&ltпуть к файлу>,&ltрежим доступа>);</code></pre>
    <p>либо возможна такая запись:</p>
    <pre class="cpp-code"><code
            class="language-cpp">fopen_s(FILE**file, &ltпуть к файлу>, &ltрежим доступа>);</code></pre>
    <p>FILE* &#8211; специальный тип определенной библиотеки stdio.h, если же использовать С++, то вместо нее подключить
        библиотеку iostream.</p>
    <p>Далее приведен пример записи функции для открытия файла на чтение:</p>
    <pre class="cpp-code"><code class="language-cpp">FILE *fp = fopen("my_file.txt", "r");</code></pre>
    <p>То есть сначала задаётся указатель FILE*fp, а затем присваивается значение, которое вернет функция fopen. В
        качестве первого аргумента у нее указан путь к файлу, а в качестве второго аргумента &#8211; режим доступа к
        этому
        файлу.</p>
    <p>Либо возможен второй вариант открытия файла:</p>
    <pre class="cpp-code"><code class="language-cpp">fopen_s(&fp,"my_file.txt", "r");</code></pre>
    <p>Причем если функция fopen по каким-то причинам не смогла открыть этот файл на чтение, то указатель fp будет равен
        нулю, а это означает, что мы можем сделать такую проверку:</p>
    <pre class="cpp-code"><code class="language-cpp">if(fp==0) cout << "не удалось открыть файл" << endl;</code></pre>
    <p>Доступ к файлу бывает двух типов: бинарный и текстовый. По сути, отличие только одно: в тестовом режиме доступа
        игнорируются некоторые управляющие символы, например, символ \r &#8211; это так называемый символ возврата, то
        есть
        при считывании файла этот символ прочитан не будет. В бинарном же режиме доступа выполняется считывание всех
        данных
        без исключения, поэтому если мы хотим извлечь из файла данные к изображению или звуку, где нужно читать все
        данные
        без исключения, то следует использовать бинарный тип доступа.</p>
    <p>Таблица 8.1 &#8211; Режимы доступа открытия файла</p>
    <p class="tables"><img src="./img/8_chapter/table8.1.png" alt=""></p>
    <p>Далее представлено рассмотрение функций, работающих в текстовом режиме доступа. Все функции, которые будут
        рассматриваться, находятся в библиотеке stdio.h, или, если мы программируем в С++, мы можем подключить
        библиотеку iostream. Итак, первые две функции работы с файлами выглядят следующим образом:</p>
    <pre class="cpp-code"><code class="language-cpp">int getc(FILE*fp); &#8211; позволяет считывать текущие символы из файла
int putc(int ch,FILE*fp); &#8211; позволяет записывать символ в файл</code></pre>
    <p>Рассмотрим пример такой программы:</p>
    <pre class="cpp-code"><code class="language-cpp">#include &ltiostream>
using namespace std;
int main(){
	setlocale(LC_ALL, "rus");
	char str[] = "Привет, мир!"; //задали строку, в которой записан текст
	FILE* fp;
	fopen("my_file.txt", "w"); //далее открываем файл на запись
	if (fp != NULL){
		//проверяем, если наш указатель не равен нулю, то есть мы открыли файл на запись успешно без всяких проблем
		for (int i = 0; str[i] != '\0'; ++i)
			putc(str[i], fp); // то начинаем записывать посимвольно строчку в этот файл, используя функцию putc
		fclose(fp); //далее закрываем файл
	}
	fopen("my_file.txt", "r"); // и снова его открываем уже на чтение
	if (fp == NULL){
		// опять проверяем, если указатель равен нулю, то выводим строчку «Не удалось открыть файл»
		cout << "Не удалось открыть файл" << endl;
		return 0; //и завершаем программу
	}
	char buff[100];
	int i = 0;
	while ((buff[i] = getc(fp)) != EOF) i++; //если файл был открыт успешно,
	// то мы используем цикл while для того, чтобы посимвольно массив buff[i] прочитал все файлы,
	// причем считывать будет до тех пор, пока мы не встретим вот такой символ EOF
	buff[i] = '\0'; // после цикла записываем в массив buff символ конца строки
	cout << buff << endl; // и выводим buff как строку на экран
	return 0;
}</code></pre>
    <p>Результат выполнения данного программного кода представлен на рисунке 8.1.</p>
    <p class="photo"><img src="./img/8_chapter/8.1.png" alt=""></p>
    <p class="signature">Рисунок 8.1 &#8211; Пример использования функций putc и fgetc</p>
    <p>Кроме этого, в общем каталоге будет доступен файл my_file.txt (рисунок 8.2). Если его открыть, то он будет
        содержать текст «Привет, мир!» (рисунок 8.3).</p>
    <p class="photo"><img src="./img/8_chapter/8.2.png" alt=""></p>
    <p class="signature">Рисунок 8.2 &#8211; Общий каталог</p>
    <p class="photo"><img src="./img/8_chapter/8.3.png" alt=""></p>
    <p class="signature">Рисунок 8.3 &#8211; Содержание файла</p>
    <p>Следует обратить внимание, что в данном примере после записи информации в файл была использована функция
        fclose(fp);. Зачем нужно закрывать файл. Во-первых, когда закрывается файл, указатель fp отвязывается от файла,
        его уже можно повторно использовать. Во-вторых, когда записываются данные, например, с помощью функции putc, то
        они сначала записываются в выходной буфер памяти компьютера и только при достижении определенного объема,
        например, 512 байт, они физически перемещаются в файл. И чтобы строчка «Привет, мир!» писалась в файл,
        необходимо этот файл закрыть, а если его не закрыть, то эта строчка как была в выходном буфере, так там и
        останется, а сам файл будет пустым.</p>
    <p>Следует отметить, что чтение и запись данных можно реализовать гораздо проще, используя функции fputs и
        fgets.</p>
    <p>Синтаксис:</p>
    <pre class="cpp-code"><code class="language-cpp">int fputs(const char* str, FILE* fp); // запись строки в файл
char* fgets(char* str, int max_size, FILE* fp); // считывание строки из файла</code></pre>
    <p>Далее приведен пример программы с использованием этих функций:</p>
    <pre class="cpp-code"><code class="language-cpp">#include *ltiostream>
using namespace std;
int main(){
	setlocale(LC_ALL, "rus");
	char str[] = "Привет мир!";
	FILE* fp;
	fopen_s(&fp, "my_file.txt", "w");
	if (fp != NULL){
		fputs(str, fp);
		fclose(fp);
	}
	fopen_s(&fp, "my_file.txt", "r");
	if (fp == NULL){
		cout << "Не удалось открыть файл" << endl;
		return 0;
	}
	char buff[100];
	fgets(buff, sizeof(buff), fp);
	cout << buff << endl;
	fclose(fp);
	return 0;
}</code></pre>
    <p>Результат выполнения данного программного кода представлен на рисунке 8.4.</p>
    <p class="photo"><img src="./img/8_chapter/8.4.png" alt=""></p>
    <p class="signature">Рисунок 8.4 &#8211; Использование функций fputs и fgets</p>
    <p>В результате в каталоге будет доступен файл my_file.txt (рисунок 8.5), содержимое которого представлено на
        рисунке
        8.6.</p>
    <p class="photo"><img src="./img/8_chapter/8.5.png" alt=""></p>
    <p class="signature">Рисунок 8.5 &#8211; Общий каталог</p>
    <p class="photo"><img src="./img/8_chapter/8.6.png" alt=""></p>
    <p class="signature">Рисунок 8.6 &#8211; Содержание файла</p>
    <p>Если необходимо записывать и считывать с файла не какие-то отдельные строчки, а данные по определенному шаблону,
        например, считать информацию вот в таком виде:</p>
    <pre class="cpp-code"><code class="language-cpp">Пушкин Онегин 2000;80;192;50;80;78</code></pre>
    <p>Чтобы прочитать из файла такие данные и разместить их по отдельным переменным, то на помощь придут две
        функции:</p>
    <pre class="cpp-code"><code class="language-cpp">int fprint(FILE*fp, const char* format, ...); //запись данных по формату
int fscanf(FILE*fp, const char* format, ...); //чтение данных по формату</code></pre>
    <p>Пример программы, использующей данные функции, приведен ниже:</p>
    <pre class="cpp-code"><code class="language-cpp">#include &ltiostream>
using namespace std;
typedef struct{
	//задаем структуру для хранения информации по книге
	char author[50];
	char title[100];
	short year;
	int pages;
	float price;
	double weight;
} BOOK;
int main(){
	setlocale(LC_ALL, "rus");
	//на эту структуру задаем две переменные, причем book содержит данные
	BOOK b, book = { "Пушкин", "Онегин", 2000, 80, 192.5 , 80.78 };
	FILE* fp;
	fopen_s(&fp, "book.dat", "w"); //открываем файл book.dat
	if (&fp != NULL) {
		fprintf(fp, " % s % s % d; % d; % .2f; % .2f", book.author, book.title,
			book.year, book.pages, book.price, book.weight); // записываем данные
		fclose(fp); //закрываем файл
		if (fp == NULL){
			cout << "Не удалось открыть файл" << endl;
			return 0;
		}
		//читаем данные по этому же самому формату
		fscanf_s(fp, " % s(% s % hd; % d; % f; % 1f", b.author, sizeof(b.author),
			b.title, sizeof(b.title), &b.year, &b.pages, &b.price, &b.weight);
		fclose(fp);
		cout << b.author << endl << b.title << endl << b.year << endl
			<< b.pages << endl << b.price << endl << b.weight << endl;
		return 0;
	}
}</code></pre>
    <p>Результат выполнения данного программного кода представлен на рисунке 8.7.</p>
    <p class="photo"><img src="./img/8_chapter/8.7.png" alt=""></p>
    <p class="signature">Рисунок 8.7 &#8211; Использование функции fprint и fscanf</p>
    <p>В результате в каталоге будет доступен файл book.dat (рисунок 8.8), содержимое которого представлено на рисунке
        8.9.</p>
    <p class="photo"><img src="./img/8_chapter/8.8.png" alt=""></p>
    <p class="signature">Рисунок 8.8 &#8211; Общий каталог</p>
    <p class="photo"><img src="./img/8_chapter/8.9.png" alt=""></p>
    <p class="signature">Рисунок 8.9 &#8211; Содержание файла</p>
    <p>Для проверки доступности открытого файла используется функция file.is_open.</p>
    <p>Далее приведена программа, которая считывает текст из файла и записывает в другой файл слова, начинающиеся с
        гласных букв:</p>
    <pre class="cpp-code"><code class="language-cpp">#include &ltiostream>
#include &ltfstream>
#include &ltstring>
#include &ltstring.h>
using namespace std;
int main(){
	setlocale(LC_ALL, "russian");
	ifstream file;
	file.open("D:\dancin.txt");  //  Открывается файл по указанному пути
	if (file.is_open()){
		//   Проверка открытия
		cout << "Все ОК, Файл открыт!" << endl;
	}
	else{
		cout << "Произошла ошибка, Файл не открыт!" << endl;
		return -1;          //  Программа завершает работу, если файл не был открыт
	}
	string s, buffer;
	getline(file, buffer);    // Вводится текст в строку для считывания
	int n;
	n = buffer.length();       //Длина введенной строки
	buffer += ' ';
	int i, y, l = 1, j;        //Переменные счетчики
	for (i = 0; i <= n; i++){
		if (buffer[i] == ' '){ //По пробелу определяется конец слова
			for (j = l; j < i; j++){
				if (((buffer[j] == 'a') || (buffer[j] == 'o') || (buffer[j] == 'y')
					|| (buffer[j] == 'i') || (buffer[j] == 'e') || (buffer[j] == 'u')
					|| (buffer[j] == 'A') || (buffer[j] == 'O') || (buffer[j] == 'Y')
					|| (buffer[j] == 'I') || (buffer[j] == 'E') || (buffer[j] == 'U'))
					&& (buffer[j - 1] == ' ')){
					//Проверка условия: «Первая буква – гласная»
					for (y = l; y <= i; y++)
						s += buffer[y]; //Запись слова в строку для вывода
				}
			}
			l = i + 1; //Счетчик определения начала слова
		}
	}
	file.close(); //Закрытие считываемого файла
	ofstream out;
	out.open("D:\hello.txt");    //Открытие файла для записи
	if (out.is_open()) {
		//Проверка открытия
		cout << "Все ОК, Файл открыт!" << endl;
	}
	else{
		cout << "Произошла ошибка, Файл не открыт!" << endl;
		return -1;
	}
	cout << s; //Вывод строки в файл
	out.close(); //Закрытие файла
}</code></pre>
    <p>Текст в первом файле произвольный (в данном случае &#8211; строчки из песни). Программа работает с текстами,
        написанными
        английской раскладкой клавиатуры. Второй файл до выполнения программы пустой. В случае повторного выполнения
        программы текст во втором файле перезаписывается. Открытие каждого файла сопровождается проверкой. Если файл не
        был
        открыт, то программа завершает свою работу с кодом -1.</p>
    <p>Программа открывает файл 1 по указанному адресу и полностью считывает строку из файла в buffer. Если файл имеет
        более
        одной строки, необходимо продублировать строку «getline(file, buffer);» Все слова, начинающиеся с гласной буквы,
        записываются в строку для вывода s.</p>
    <p>После выполнения цикла для считывания слов файл 1 закрывается, и открывается файл 2. Далее строка s записывается
        в
        файл 2. Файл 2 закрывается, а программа завершает свою работу. Исходный файл для работы данной программы
        представлен
        на рисунке 8.10.</p>
    <p class="photo"><img src="./img/8_chapter/8.10.png" alt=""></p>
    <p class="signature">Рисунок 8.10 &#8211; Исходный файл</p>
    <p>Результат работы программы представлен на рисунках 8.11, 8.12.</p>
    <p class="photo"><img src="./img/8_chapter/8.11.png" alt=""></p>
    <p class="signature">Рисунок 8.11 &#8211; Результат работы программы</p>
    <p class="photo"><img src="./img/8_chapter/8.12.png" alt=""></p>
    <p class="signature">Рисунок 8.12 &#8211; Проверка открытия файлов</p>
    <p>Таким образом, открывается файл с именем файл.txt, который лежит в корневом каталоге.</p>
    <h3 id="8.2">8.2 Функции работы с позицией курсора</h3>
    <p>Для работы с позицией курсора в языке С++ используются функции fseek() и ftell().</p>
    <p>Функция fseek() устанавливает позицию в потоке данных, заданным аргументом stream.</p>
    <p>Синтаксис:</p>
    <pre class="cpp-code"><code class="language-cpp">int fseek (FILE*stream, long offset, int origin); // устанавливает позицию для записи/считывания
// в файле в качестве первого аргумента идет указатель на файл, далее смещение позиции в файле,
// а затем флаг начального отсчета, относительно которого устанавливается смещение offset.</code></pre>
    <pre class="cpp-code"><code
            class="language-cpp">long ftell (FILE*stream); // возвращает номер текущей позиции</code></pre>
    <p>int origin может принимать следующие значения:</p>
    <ol>
        <li>SEEK_END устанавливает смещение относительно конца файла;</li>
        <li>SEEK_SET начала файла;</li>
        <li>SEEK_CUR текущей позиции.</li>
    </ol>
    <p>Далее представлен пример использования этих функций на примере считывания символов из файла в обратном
        порядке:</p>
    <pre class="cpp-code"><code class="language-cpp">#include &ltiostream>
using namespace std;
typedef struct{
	//задаем структуру для хранения информации по книге
	char author[50];
	char title[100];
	short years;
	int pages;
	float price;
	double weight;
} BOOK;
int main(){
	setlocale(LC_ALL, "rus");
	//на эту структуру задаем две переменные, причем book содержит данные
	BOOK b, book = { "Пушкин", "Онегин", 2000, 80, 192.5 , 80.78 };
	FILE* fp;
	fopen_s(&fp, "book.dat", "w"); //открываем файл book.dat
	if (&fp != NULL){
		fprintf(fp, " % s % s % d; % d; % .2f; % .2f", book.author, book.title,
			book.years, book.pages, book.price, book.weight); // записываем данные
		fclose(fp); //закрываем файл
		if (fp == NULL){
			cout << "Не удалось открыть файл" << endl;
			return 0;
		}
		fscanf_s(fp, " % s(% s % hd; % d; % f; % 1f", b.author, sizeof(b.author),
			b.title, sizeof(b.title), &b.years, &b.pages, &b.price, &b.weight);
		//читаем данные по этому же самому формату
		fclose(fp);
		cout << b.author << endl << b.title << endl << b.years << endl
			<< b.pages << endl << b.price << endl << b.weight << endl;
		return 0;
	}
}</code></pre>
    <p>Результат работы программы представлен на рисунке 8.13.</p>
    <p class="photo"><img src="./img/8_chapter/8.14.png" alt=""></p>
    <p class="signature">Рисунок 8.13 &#8211; Результат работы функций ftell и fseek</p>
    <h3 id="8.3">8.3 Работа с бинарными файлами</h3>
    <p>Для реализации записи и чтения в бинарном режиме доступа используются функции fwrite и fread.</p>
    <p>Синтаксис:</p>
    <pre class="cpp-code"><code class="language-cpp">// функция, которая позволяет записывать данные в бинарном режиме
size_t fwrite(char* buff, size_t size, size_t count, FILE* fp);
// функция, которая читает данные в бинарном режиме
size_t fread(char* buff, size_t size, size_t count, FILE* fp);</code></pre>
    <p>Первый аргумент у этих функций нужен, чтобы записать или прочитать, второй &#8211; размер записываемого элемента
        либо
        максимальная длина считываемого элемента, далее идет число записываемых элементов/считываемых элементов, а
        последний
        &#8211; это указатель на файл, с которым мы работаем.</p>
    <p>Пример особенностей работы этих функций:</p>
    <pre class="cpp-code"><code class="language-cpp">#include &ltiostream>
using namespace std;
int main(){
	setlocale(LC_ALL, "rus");
	FILE* fp;
	fopen("out_b.dat", "wb"); //открываем файл на запись в бинарном режиме доступа
	if (fp == NULL){
		cout << "He удалось открыть файл" << endl;
		return 0;
	}
	//задаем целочисленную переменную и присваиваем ей значение 1000
	int a = 1000;
	//записываем эту целочисленную переменную побайтно в этот файл
	fwrite((char*)&a, sizeof(int), 1, fp);
	fclose(fp);
	int b = 0; //задаем другую целочисленную переменную
	fopen("out b.dat", "rb"); //открываем уже созданный файл на чтение в бинарном режиме
	size_t elements = fread((char*)&b, sizeof(int), 1, fp); //читаем побайтно переменную b
	fclose(fp); //закрываем файл
	//выводим на экран число считанных элементов и значение переменной b
	cout << elements << " " << b << endl;
	return 0;
}</code></pre>
    <p>Результат выполнения данного программного кода представлен на рисунке 8.14.</p>
    <p class="photo"><img src="./img/8_chapter/8.14.png" alt=""></p>
    <p class="signature">Рисунок 8.14 &#8211; Результат работы функций fwrite и fread</p>
    <p>В результате в каталоге будет доступен файл out_b.dat (рисунок 8.15), содержимое которого представлено на рисунке
        8.16.</p>
    <p class="photo"><img src="./img/8_chapter/8.15.png" alt=""></p>
    <p class="signature">Рисунок 8.15 &#8211; Общий каталог</p>
    <p class="photo"><img src="./img/8_chapter/8.16.png" alt=""></p>
    <p class="signature">Рисунок 8.16 &#8211; Содержание файла</p>
    <p>Также с помощью данных функций удобно записывать структуры из файла, например, вот таким образом:</p>
    <pre class="cpp-code"><code class="language-cpp">#include &ltiostream>
#include &ltfstream>
using namespace std;
typedef struct{
	//задали структуру PERSON
	char name[50];
	char lastname[50];
	unsigned char old;
	float weight;
} PERSON;
int main(){
	setlocale(LC_ALL, "rus");
	//задали переменную и сразу проинициализировали данную структуру с конкретными значениями
	PERSON p = { "Иван", "Иванов", 24, 77.6 };
	FILE* fp;
	fopen("out_b.dat", "wb"); //открыли файл out_b.dat на запись в бинарном режиме
	if (fp == NULL)
		cout << "He удалось открыть файл" << endl;
	fwrite((char*)&p, sizeof(PERSON), 1, fp);  //записали всю структуру в этот файл
	fclose(fp);
	PERSON p2; //создаем еще одну переменную
	fopen_s(&fp, "out_b.dat", "rb"); //открываем файл на чтение в бинарном режиме
	//читаем те данные, которые будут записаны
	size_t elements = fread((char*)&p2, sizeof(PERSON), 1, fp);
	fclose(fp);
	//выводим данные на экран
	cout << p2.name << endl << p2.lastname << endl << (int)p2.old << endl << p2.weight << endl;
	return 0;
}</code></pre>
    <p>Результат выполнения данного программного кода представлен на рисунке 8.17.</p>
    <p class="photo"><img src="./img/8_chapter/8.17.png" alt=""></p>
    <p class="signature">Рисунок 8.17 &#8211; Пример работы записи структур данных в файл</p>
    <p>В результате в каталоге будет доступен файл out_b.dat (рисунок 8.18), содержимое которого представлено на рисунке
        8.19.</p>
    <p class="photo"><img src="./img/8_chapter/8.18.png" alt=""></p>
    <p class="signature">Рисунок 8.18 &#8211; Общий каталог</p>
    <p class="photo"><img src="./img/8_chapter/8.19.png" alt=""></p>
    <p class="signature">Рисунок 8.19 &#8211; Содержание файла</p>
    <p>Далее программа усложнена, и реализована запись в файл массив структур:</p>
    <pre class="cpp-code"><code class="language-cpp">#include &ltiostream>
using namespace std;
#define N  3
typedef struct{
	char name[50];
	char lastname[50];
	unsigned char old;
	float weight;
} PERSON;
int main(){
	setlocale(LC_ALL, "rus");
	PERSON p[N] = { {  "Иван" , "Иванов" , 24, 77.6} ,
				   {  "Семен" , "Семенов" , 32, 85.5} ,
				   {  "Борис" , "Борисов" , 40 , 73.5} };
	FILE* fp;
	fopen("out b.dat", "wb"); //открываем файл на запись в бинарном режиме
	if (fp == NULL){
		cout << "Hе удалось открыть файл" << endl;
		return 0;
	}
	fwrite((char*)&p, sizeof(PERSON), N, fp); //записываем N элементов
	fclose(fp); //закрываем файл
	PERSON p2[N]; //задаем еще один массив
	fopen("out b.dat", "rb"); //открываем файл на чтение в бинарном режиме
	int i = 0;
	//данная функция возвращает 0, если конец файла еще не достигнут,
	//  и значения отличные от 0, если мы дошли до конца файла
	while (!feof(fp)){
		fread((char*)&p2[i], sizeof(PERSON), 1, fp); //читаем очередную порцию данных
		if (ferror(fp)){
			cout << "Oшибка считывания \n";
			break;
		}
		i++;
	}
	fclose(fp); //закрываем файл
	for (int i = 0; i < N; ++i)
		cout << p2[i].name << endl << p2[i].lastname << endl
		<< (int)p2[i].old << endl << p2[i].weight << endl;
	return 0;
}</code></pre>
    <p>Результат выполнения данного программного кода представлен на рисунке 8.20.</p>
    <p class="photo"><img src="./img/8_chapter/8.20.png" alt=""></p>
    <p class="signature">Рисунок 8.20 &#8211; Реализация программного кода</p>
    <p>В результате в каталоге будет доступен файл out_b.dat (рисунок 8.21), содержимое которого представлено на рисунке
        8.22.</p>
    <p class="photo"><img src="./img/8_chapter/8.21.png" alt=""></p>
    <p class="signature">Рисунок 8.21 &#8211; Общий каталог</p>
    <p class="photo"><img src="./img/8_chapter/8.22.png" alt=""></p>
    <p class="signature">Рисунок 8.22 &#8211; Содержание файла</p>
    <h3 id="8.4">8.4 Удаление и переименование файлов</h3>
    <p>В языке С++ есть еще две полезные функции работы с файлами:</p>
    <pre class="cpp-code"><code class="language-cpp">int remove (const char *path); // удаление файлов
int rename (const char*oldname, const char*newname); // переименование файлов </code></pre>
    <p>Если эти функции возвращают 0, то операция прошла успешно, а если -1, то произошли какие-то проблемы.</p>
    <p>Далее приведен пример использования данных функций:</p>
    <pre class="cpp-code"><code class="language-cpp">#include &ltiostream>
using namespace std;
int main(){
	setlocale(LC_ALL, "rus");
	if (rename("out / file1.dat", "out / file2.dat") == 0) //переименовываем файл
		cout << "Файл успешно переименован\n";
	else cout << "Ошибка переименования файла\n";
	if (remove("del.file") != 0)
		cout << "Ошибка удаления файла\n";
	else cout << "Файл успешно удален\n";
	return 0;
}</code></pre>
    <p>Результат выполнения данного программного кода представлен на рисунке 8.23.</p>
    <p class="photo"><img src="./img/8_chapter/8.23.png" alt=""></p>
    <p class="signature">Рисунок 8.23 &#8211; Результат работы программы</p>
    <p>В результате в каталоге out будет доступен файл file1.dat (рисунок 8.24), содержимое которого представлено на
        рисунке
        8.25.</p>
    <p class="photo"><img src="./img/8_chapter/8.24.png" alt=""></p>
    <p class="signature">Рисунок 8.24 &#8211; Общий каталог</p>
    <p class="photo"><img src="./img/8_chapter/8.25.png" alt=""></p>
    <p class="signature">Рисунок 8.25 &#8211; Содержание файла</p>
     <p>На видео 18 и 19 более подробно рассматриваются вопросы, связанные с работой файлов.</p>
    <video controls="controls" poster="./img/video.jpg" src="./video/video_18_l.mp4"></video>
    <p class="signature">Видео 18 &#8211; Функции работы с файлами. Часть 1</p>
    <video controls="controls" poster="./img/video.jpg" src="./video/video_19_l.mp4"></video>
    <p class="signature">Видео 19 &#8211; Функции работы с файлами. Часть 2</p>
    <h3 id="8.5">8.5 Контрольные вопросы для закрепления изученного материала</h3>
    <ol>
        <li class="with-a-bracket">Что представляет собой файл?</li>
        <li class="with-a-bracket">Какие возможности для работы с файлами предоставляет С++?</li>
        <li class="with-a-bracket">Перечислите возможные режимы доступа при работе с текстовыми файлами.</li>
        <li class="with-a-bracket">Как организуется чтение файла?</li>
        <li class="with-a-bracket">Как организовать построчное считывание данных из файла?</li>
    </ol>
</script>
<script id="page8.6" type="text/html">
    <TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0>
        <TR>
            <TD width="50%"><a name="3"></a>
                <HR>
                <div align=justify><h1>Тренировочные упражнения</h1></div>
  <form>
   <ol> 
   	<li class="without-parentheses"> Заполните пропуски для описания синтаксиса функции открытия файла в языке программирования С++.
   	 <pre class="cpp-code"><code class="language-cpp">
FILE* <input type="text" id="glav8_1_1" size="1">(<путь к <input type="text" id="glav8_1_2" size="2">>,<<input type="text" id="glav8_1_3"> доступа>);
</code></pre>  
              <input type="button" value="Ответить" class="proverit_glav_8_1"></input>
              <input type="reset" value ="Очистить"></input>
              <br><br>
                 <div id="resultat_8_1"></div>
                  </form>
              </li><br><br>
            
<li class="without-parentheses"> Соотнесите режимы доступа открытия файлов путем перетаскивания мышью правильных вариантов ответов.</li>
 <table class="table_center table_glava8">
        <tr>
            <td>
                <ul class="static_ul static_glava8">
                    <li>r</li>
                    <li>w</li>
                    <li>a</li>
                    <li>rb</li>
                    <li>wb</li>
                    <li>ab</li>
                </ul>
            </td>
            <td>
                <ul class="droppable_ul1 droppable_ul drop_glava8" id="parent1">
                </ul>
                <ul class="droppable_ul2 droppable_ul drop_glava8" id="parent2">
                </ul>
                <ul class="droppable_ul3 droppable_ul drop_glava8" id="parent3">
                </ul>
                <ul class="droppable_ul4 droppable_ul drop_glava8" id="parent4">
                </ul>
                <ul class="droppable_ul5 droppable_ul drop_glava8" id="parent5">
                </ul>
                <ul class="droppable_ul6 droppable_ul drop_glava8" id="parent6">
                </ul>
            </td>
            <td>
                <ul class="draggable_ul drag_glava8">
                    <li class="ufo draggable_li" id="ufo1" draggable="true">Открывает файл на чтение в текстовом режиме доступа</li>
                    <li class="ufo2 draggable_li" id="ufo2" draggable="true">Открывает файл на добавление в бинарном режиме доступа</li>
                    <li class="ufo3 draggable_li" id="ufo3" draggable="true">Открывает файл на запись в текстовом режиме доступа</li>
                    <li class="ufo4 draggable_li" id="ufo4" draggable="true">Открывает файл на запись в бинарном режиме доступа</li>
                    <li class="ufo5 draggable_li" id="ufo5" draggable="true">Открывает файл на добавление записи в текстовом режиме</li>
                    <li class="ufo6 draggable_li" id="ufo6" draggable="true">Открывает файл на чтение в бинарном режиме доступа</li>
                </ul>
            </td>
        </tr>
    </table>
 <input type="button" value="Ответить" onclick="provet()"></input>
 <input type="button" value ="Сбросить" onclick="provet_del()"></input>
 <br><br>
        <div id="resultat_2"></div>
</li><br><br>
  <form>           
<li class="without-parentheses"> Дополните пропуски в коде таким образом, чтобы в результате выполнения программы, в которой реализовано переименование и удаление файла был выведен следующий результат.
<p class="photo"><img src="./img/8_chapter/8.26.png" alt=""></p>
	<pre class="cpp-code"><code class="language-cpp">
using namespace std;
int main(){
	setlocale(LC_ALL, "rus");
	if (<input type="text" id="glav8_3_1" size="3">("out / file1.dat", "out / file2.dat") == 0) 
		cout << "Файл успешно переименован\n";
	else cout << "Ошибка переименования файла\n";
	if (<input type="text" id="glav8_3_2" size="3">("del.file") != 0)
		cout << "Ошибка удаления файла\n";
	else cout << "Файл успешно удален\n";
	return 0;
}
	</code></pre>

               <input type="button" value="Ответить" class="proverit_glav_8_3"></input>
              <input type="reset" value ="Очистить"></input>
              <br><br>
                 <div id="resultat_8_3"></div>
	</form>
</li>

     	     </ol>
 </HR></TD></TR></TABLE>
</script> 
<script id="page8.7" type="text/html">
    <TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0>
        <TR>
            <TD width="50%"><a name="3"></a>
                <HR>
                <div align=justify><h1>Тестирование по восьмой главе</h1></div>
                <form name=test>
                    <ol>
                        <li>
                            <h4><input type=text name=T1 style="height: 15px; width:15px;" value=''> Процедура открытия
                                файла заключается в:</h4>
                            <input type=radio name=Q1> создании переменной типа FILE;<br>
                            <input type=radio name=Q1> блокировке операций с файлом со стороны других приложений;<br>
                            <input type=radio name=Q1> создании переменной типа FILE и связывании ее с конкретным файлом
                            на диске;<br>
                            <input type=radio name=Q1> создании переменной типа fstream;<br>
                            <input type=radio name=Q1> создании переменной типа ofstream.<br>
                            <br>
                        </li>
                        <li>
                            <h4><input type=text name=T2 style="height: 15px; width:15px;" value=''> Процедура открытия
                                файла в языке С++ выполняется функцией:</h4>
                            <input type=radio name=Q2> assign( );<br>
                            <input type=radio name=Q2> fopen( );<br>
                            <input type=radio name=Q2> openfile( );<br>
                            <input type=radio name=Q2> exitfile( );<br>
                            <input type=radio name=Q2> ничего из вышеперечисленного.<br>
                            <br>
                        </li>
                        <li>
                            <h4><input type=text name=T3 style="height: 15px; width:15px;" value=''> Файловым указателем
                                места называется:</h4>
                            <input type=radio name=Q3> переменная типа FILE;<br>
                            <input type=radio name=Q3> переменная, содержащая адрес байта в файле, с которого будет
                            осуществляться операция чтения или записи;<br>
                            <input type=radio name=Q3> переменная, которая будет записана в файл;<br>
                            <input type=radio name=Q3> переменная, которая указывает на место, с которого происходит
                            удаление информации из файла;<br>
                            <input type=radio name=Q3> ничего из вышеперечисленного.<br>
                            <br>
                        </li>
                        <li>
                            <h4><input type=text name=T4 style="height: 15px; width:15px;" value=''> В языке С++
                                программист может сам задавать положение файлового указателя места. Это делается
                                функцией:</h4>
                            <input type=radio name=Q4> setfile( );<br>
                            <input type=radio name=Q4> fpointer( );<br>
                            <input type=radio name=Q4> fseek( );<br>
                            <input type=radio name=Q4> settxt;<br>
                            <input type=radio name=Q4> ничего из вышеперечисленного.<br>
                            <br>
                        </li>
                        <li>
                            <h4><input type=text name=T5 style="height: 15px; width:15px;" value=''> В результате
                                выполнения программы:</h4>
                            <pre class="cpp-code"><code class="language-cpp">FILE *f1;
f1=fopen("data.txt", "rt");</code></pre>
                            <input type=radio name=Q5> файл data.txt будет открыт на чтение и запись в текстовом режиме;<br>
                            <input type=radio name=Q5> файл data.txt будет открыт на чтение в текстовом режиме;<br>
                            <input type=radio name=Q5> файл data.txt будет открыт на чтение в двоичном режиме;<br>
                            <input type=radio name=Q5> файл data.txt будет открыт на чтение и запись в двоичном
                            режиме;<br>
                            <input type=radio name=Q5> ничего из вышеперечисленного.<br>
                            <br>
                        </li>
                        <li>
                            <h4><input type=text name=T6 style="height: 15px; width:15px;" value=''> С помощью функции
                                fopen( ) можно открыть файл:</h4>
                            <input type=radio name=Q6> только на чтение;<br>
                            <input type=radio name=Q6> только на запись;<br>
                            <input type=radio name=Q6> на чтение и на запись;<br>
                            <input type=radio name=Q6> ничего из вышеперечисленного;<br>
                            <input type=radio name=Q6> только на удаление.<br>
                            <br>
                        </li>
                        <li>
                            <h4><input type=text name=T7 style="height: 15px; width:15px;" value=''> С помощью функции
                                fopen( ) можно открыть файл:</h4>
                            <input type=radio name=Q7> только в текстовом режиме;<br>
                            <input type=radio name=Q7> только в двоичном режиме;<br>
                            <input type=radio name=Q7> в двоичном или текстовом режиме;<br>
                            <input type=radio name=Q7> ничего из вышеперечисленного;<br>
                            <input type=radio name=Q7> только на удаление.<br>
                            <br>
                        </li>
                        <li>
                            <h4><input type=text name=T8 style="height: 15px; width:15px;" value=''> Отличие файла,
                                открытого в текстовом режиме, от файла, открытого в двоичном режиме, состоит в том, что:
                            </h4>
                            <input type=radio name=Q8> для файла, открытого в текстовом режиме, становятся доступны
                            специальные функции чтения и записи текста;<br>
                            <input type=radio name=Q8> в файл, открытый в двоичном режиме, нельзя записать текст;<br>
                            <input type=radio name=Q8> файл, открытый в двоичном режиме, может содержать только числа,
                            файл, открытый в текстовом режиме, может содержать только текст;<br>
                            <input type=radio name=Q8> в текстовом режиме нельзя писать бинарные символы;<br>
                            <input type=radio name=Q8> нет отличий.<br>
                            <br>
                        </li>
                        <li>
                            <h4><input type=text name=T9 style="height: 15px; width:15px;" value=''> Если программисту
                                требуется записать в файл одномерный массив из 10 целых чисел, то ему необходимо:</h4>
                            <input type=radio name=Q9> обязательно вызвать функцию fwrite( ) 10 раз для каждого элемента
                            массива;<br>
                            <input type=radio name=Q9> вызвать функцию fwrite( ) 1 раз, записав сразу весь массив;<br>
                            <input type=radio name=Q9> вызвать функцию fwrite( ) 2 раза, записав сначала элементы
                            массива, а затем значение указателя на массив;<br>
                            <input type=radio name=Q9> вызвать функцию fwrite() в цикле;<br>
                            <input type=radio name=Q9> ничего из вышеперечисленного.<br>
                            <br>
                        </li>
                        <li>
                            <h4><input type=text name=T10 style="height: 15px; width:15px;" value=''> Укажите класс,
                                который реализует получение информации о файле в C++:</h4>
                            <input type=radio name=Q10> fileInfo;<br>
                            <input type=radio name=Q10> dataInfo;<br>
                            <input type=radio name=Q10> fileDescription;<br>
                            <input type=radio name=Q10> fileProperties;<br>
                            <input type=radio name=Q10> objInfo.<br>
                            <br>
                        </li>
                    </ol>
                    <div align="center">
                        <div>
                            <input type=button value="Показать результат" onClick="test1('MzIxMzIzMzI0MQ', 10)">
                        </div>
                        <div>
                            <textarea style="margin-top:6px" rows=5 cols="100%" name=s1></textarea>
                        </div>
                        <div>
                            <input type=reset value="Очистить выбранные пункты">
                        </div>
                        <br>
                        <Div align=center>
                            <a href="#3">В начало страницы</a>
                        </div>
                        <br>
                    </div>
                </form>
            </TD>
        </TR>
    </TABLE>
</script>

<!-- /page9 -->
<script id="page9" type="text/html">
    <h2 id="9">9 Визуальное программирование в языке C++</h2>
    <h3 id="9.1">9.1 Технология WinAPI</h3>
    <p>В операционной системе Windows реализована объектно-ориентированная идеология. Базовый объект системы &#8211;
        окно,
        поведение которого определяется методом, называемым функцией окна. Графический образ окна на экране дисплея
        &#8211;
        прямоугольная рабочая область.</p>
    <p>Независимо от своего типа любой объект Windows идентифицируется описателем или <a href="glossary.html#m5">дескриптором</a> (handle). Дескриптор
        &#8211;
        это ссылка на объект. Все взаимоотношения программного кода с объектом осуществляются только через его
        дескриптор
        <a href="source.html#metka18">[18]</a>.</p>
    <p>Интерфейс прикладного программирования (<a href="glossary.html#m12">API</a> &#8211; Application Programming Interface) представляет собой
        совокупность
        32-битных функций (Win32 API), которые предназначены для создания приложений (программ), работающих под
        управлением
        Microsoft Windows. Функции объявлены в заголовочных файлах. Главный из них &#8211; файл windows.h, в котором
        содержатся
        ссылки на другие заголовочные файлы <a href="source.html#metka18">[19]</a>.</p>
    <h3 id="9.1.1">9.1.1 Введение в технологию Win32 API</h3>
    <p>Win32 API &#8211; это набор функций (API &#8211; Application Programming Interface), работающих под управлением
        ОС Windows. Они
        содержатся в библиотеке windows.h.</p>
    <p>С помощью WinAPI можно создавать различные оконные процедуры, <a href="glossary.html#m5">диалоговые окна</a>, программы. Эта библиотека является
        базовой в освоении программирования Windows Forms, <a href="glossary.html#m12">MFC</a> , потому что эти интерфейсы являются надстройками этой
        библиотеки.</p>
    <p>В Win32 единицей работы компьютера является поток &#8211; ход выполнения программы в рамках процесса (в контексте
        процесса). Поток выполняет программный код, принадлежащий процессу. Процесс &#8211; это экземпляр выполняемой
        программы
        (но не ход ее выполнения). Он не является динамическим объектом и включает виртуальное адресное пространство,
        код и
        данные, файлы, синхронизирующие объекты, динамические библиотеки. Каждое приложение создает по меньшей мере один
        первичный поток, но может создать и много потоков.</p>
    <p>Для создания оконных приложений можно воспользоваться возможностями инструментальной среды Microsoft Visual
        Studio.
        MS Visual Studio позволяет создать следующие типы приложений:</p>
    <ol>
        <li class="with-a-dash">консольное приложение Windows. Создает шаблон для консольного приложения;</li>
        <li class="with-a-dash">приложение MFC. Позволяет создать приложение со сложным пользовательским графическим
            интерфейсом в Windows;
        </li>
        <li class="with-a-dash">классическое приложение Windows. Позволяет создать приложение с графическим интерфейсом
            в
            Windows;
        </li>
        <li class="with-a-dash">пустой проект. Позволяет написать программу с нуля. Отсутствуют начальные файлы.</li>
    </ol>
    <p class="photo"><img src="./img/9_chapter/9.1.png" alt=""></p>
    <p class="signature">Рисунок 9.1 &#8211; Создание проекта</p>
    <p>Для создания классического приложения windows необходимо выбрать вкладку Создать &#8211; Проект, в основном меню
        «Файл»
        (рисунок 9.1). Затем в появившемся окне выбрать из вариантов «Классическое приложение Windows» и ввести имя
        файла
        (рисунок 9.2).</p>
    <p class="photo"><img src="./img/9_chapter/9.2.jpg" alt=""></p>
    <p class="signature">Рисунок 9.2 &#8211; Выбор шаблона при создании проекта</p>
    <p>Как видно на рисунке 9.2, в левом меню окна представлена возможность работы с другими языками программирования.
        Интегрированная среда разработки <a href="glossary.html#m12">Microsoft Visual Studio</a> позволяет создавать проекты на таких языках как С#,
        Basic, JavaScript, Python, если установлены соответствующие расширения, а также предоставляет возможность
        создания
        проектов для других платформ, таких как Android, IOS, MacOS, Linux и др.</p>
    <p>Язык С# используется также для создания программ с использованием технологии Windows Forms. Данный интерфейс
        упрощает
        доступ к элементам интерфейса Microsoft Windows за счет создания обёртки для Win32 API <a href="source.html#metka20">[20]</a>.</p>
    <h3 id="9.1.2">9.1.2 Структура оконного приложения</h3>
    <p>Windows накладывает жесткие ограничения на структуру приложения, которое, как правило, содержит минимум две
        принципиально важные функции: главную WinMain() и функцию окна WndPoc().</p>
    <p>Функция WinMain &#8211; первая функция, которая выполняется в программе (ее еще называют «точкой входа» или
        «entry
        point»).
        Она должна быть в каждом приложении. Ее прототип описан в файле winbase.h следующим образом:</p>
    <pre class="cpp-code"><code class="language-cpp">int WINAPI WinMain(
	HINSTANCE hInstance, //дескриптор экземпляра приложения
	HINSTANCE hPrevInstance, //дескриптор предыдущего экземпляра приложения
	LPSTR lpszCmdLine, //указатель на параметры командной строки
	int nCmdShow //константа, характеризующая начальный вид окна
);</code></pre>
    <p>Следует обратить внимание на параметры функции WinMain:</p>
    <ol>
        <li class="with-a-dash">HINSTANCE hInstance &#8211; дескриптор экземпляра приложения. Этот де-скриптор содержит
            адрес
            начала кода программы в ее адресном пространстве. Дескриптор hInstance чаще всего требуется функциям,
            работающим
            с ресурсами программы;
        </li>
        <li class="with-a-dash">HINSTANCE hPrevInstance &#8211; дескриптор предыдущего экземпляра приложения. Этот
            дескриптор
            остался от старых версий Windows &#8211; скорее всего, вам он никогда не пригодится;
        </li>
        <li class="with-a-dash">LPSTR lpCmdLine &#8211; указатель на начало командной строки, введенной при запуске
            программы;
        </li>
        <li class="with-a-dash">int nCmdShow &#8211; это значение содержит желаемый вид окна (например, свернутый или
            развернутый).
        </li>
    </ol>
    <p>Значение, которое возвращается функцией WinMain (тип int), &#8211; код завершения программы. Принято, что, если
        программа
        завершила свое выполнение без ошибок, возвращается 0.</p>
    <p><a href="glossary.html#m9">Оконная функция</a> &#8211; это функция обратного вызова, предназначенная для обработки сообщений, адресованных окну
        того
        оконного класса, в котором содержится ссылка на данную процедуру <a href="source.html#metka18">[18]</a>.</p>
    <p><a href="glossary.html#m12">Функции обратного вызова</a> &#8211; это функции, которые вызывает сама операционная система. Компилятор определяет
        их по
        спецификатору CALLBACK. Оконная функция получает четыре параметра, а ее заголовок имеет стандартный
        синтаксис:</p>
    <pre class="cpp-code"><code class="language-cpp">LRESULT CALLBACK Имя_функции(
HWND hWnd, //дескриптор (хэндл) окно, которому предназначено данное сообщение
UINT uMsg //код пришедшего сообщения
WPARAM wParam //дополнительная информация о сообщении
LPARAM lParam //дополнительная информация о сообщении
);
</code></pre>
    <p>Имя функции может быть произвольным, но для главного окна приложения обычно используется имя WndProc.</p>
    <p>При создании нового окна ему присваивается «Класс окна» (window class). Класс окна задает оконную функцию,
        используемую по умолчанию. Кроме этого, класс окна задают другие параметры окна, такие как стиль, меню окна,
        цвет
        рабочей области и т. д. Разные классы окон могут указывать на одну и ту же функцию обработки сообщений. Для
        создания
        класса его необходимо зарегистрировать.</p>
    <p>За регистрацию отвечает функция RegisterClass. В ее параметре необходимо передать указатель на структуру
        WNDCLASS.
        Обычно для заполнения структуры и вызова RegisterClass создают отдельную функцию.</p>
    <p>Далее представлен простейший пример такой функции:</p>
    <pre class="cpp-code"><code class="language-cpp">ATOM RegMyWindowClass(HINSTANCE hInst, LPSTR lpzClassName){
	WNDCLASS wcWindowClass = { 0 };
	wcWindowClass.lpfnWndProc = (WNDPROC)WndProc; //адрес функции обработки сообщений
	wcWindowClass.style = CS_HREDRAW | CS_VREDRAW;  //стиль окна
	wcWindowClass.hInstance = hInst; //дескриптор экземпляра приложения
	wcWindowClass.lpszClassName = lpzClassName;  //название класса
	wcWindowClass.hCursor = LoadCursor(NULL, IDC_ARROW);  //загрузка курсора
	wcWindowClass.hbrBackground = (HBRUSH)COLOR_APPWORKSPACE;  //загрузка цвета окон
	return RegisterClass(&wcWindowClass); //регистрация класса
}</code></pre>
    <ol>
        <li class="with-a-dash">WNDPROC lpfnWndProc &#8211; адрес функции обработки сообщений;</li>
        <li class="with-a-dash">HINSTANCE hInstance &#8211; уже знакомая переменная, описывающая экзем-пляр;</li>
        <li class="with-a-dash">LPCTSTR lpszClassName &#8211; имя нового класса;</li>
        <li class="with-a-dash">HICON hCursor &#8211; описатель курсора мыши;</li>
        <li class="with-a-dash">HBRUSH hbrBackground &#8211; цвет рабочей области окна.</li>
    </ol>
    <p>Функция RegisterClass возвращает уникальный «описатель класса окна» типа ATOM. Если при регистрации класса
        произошла
        ошибка, это значение будет равно нулю. Чтобы узнать, что произошло, можно вызвать функцию GetLastError().</p>
    <p>Существует также функция RegisterClassEx. Это аналог функции RegisterClass с возможностью присвоения окнам
        маленькой
        иконки. При работе с этой функцией необходимо пользоваться структурой WNDCLASSEX.</p>
    <h3 id="9.1.3">9.1.3 Элементы управления формами</h3>
    <p>Главным элементом программы в среде Windows является окно. Окно может содержать элементы управления: кнопки,
        списки,
        окна редактирования и др. Эти элементы также являются окнами, но обладающими особым свойством: события,
        происходящие
        с этими элементами (и самим окном), приводят к приходу сообщений в процедуру окна.</p>
    <p>Windows предоставляет несколько предопределенных классов управляющих элементов. Программа может создавать
        управляющие
        элементы поштучно при помощи функции CreateWindow или оптом, загружая их вместе с шаблоном диалога из своих
        ресурсов. Управляющие элементы &#8211; это всегда дочерние окна. Управляющие элементы при возникновении
        некоторых событий,
        связанных с реакцией пользователя, посылают своему родительскому окну сообщения-оповещения (notification
        messages)
        WM_COMMAND или WM_NOTIFY.</p>
    <p>Как и любое другое окно, управляющий элемент может быть скрыт или отображен при помощи функции ShowWindow.
        Аналогично
        управляющий элемент может быть блокирован или разблокирован при помощи функции:</p>
    <pre class="cpp-code"><code class="language-cpp">BOOL WINAPI EnableWindow(HWND hw,BOOL bEnable)</code></pre>
    <p>В качестве второго параметра передается флаг TRUE (разблокировать) или FALSE (блокировать). Функция возвращает
        значение TRUE, если перед ее вызовом окно было заблокировано. Узнать текущий статус блокирования окна можно при
        помощи функции:</p>
    <pre class="cpp-code"><code class="language-cpp">BOOL WINAPI IsWindowEnabled(HWND hw) // возвращает значение TRUE, если окно разблокировано</code></pre>
    <p>Для многих управляющих элементов определены специальные сообщения, которые управляют видом или поведением таких
        элементов или позволяют получить параметры их состояния. Как и для любого другого окна, эти сообщения можно
        отправить с помощью функции:</p>
    <pre class="cpp-code"><code
            class="language-cpp">LRESULT WINAPI SendMessage(HWN D hw, UINT msg, WPARAM wp, LPARAM lp)</code></pre>
    <p>Все упомянутые функции работают с дескриптором окна, который для управляющих элементов в случае создания диалога
        по
        шаблону из ресурсов непосредственно неизвестен, но может быть получен по дескриптору диалога и идентификатору
        управляющего элемента вызовом:</p>
    <pre class="cpp-code"><code class="language-cpp">HWND WINAPI GetDlgItem(HWND hDlg, int idDlgItem)</code></pre>
    <p>Для функции отсылки сообщений есть специальный вариант, предназначенный для более удобной работы с управляющими
        элементами:</p>
    <pre class="cpp-code"><code class="language-cpp">LRESULT WINAPI SendDlgItemMessage(
	HWND hwndDlg,	 /* дескриптор родительского диалога */
	int idControl, /* идентификатор управляющего элемента */
	UINT msg,      /* код сообщения */
	WPARAM wp,     /* параметр сообщения */
	LPARAM lp      /* параметр сообщения */
)</code></pre>
    <p>Таблица 9.1 &#8211; Элементы управления окна</p>
    <p class="tables"><img src="./img/9_chapter/table9.1.png" alt=""></p>
    <p>Создание элементов управления окна осуществляется функцией:</p>
    <pre class="cpp-code"><code class="language-cpp">HWND WINAPI CreateWindow(
	_In_opt_ LPCTSTR lpClassName, // имя предопределенного класса
	_In_opt_ LPCTSTR lpWindowName, // текст
	_In_ DWORD dwStyle, // стиль
	_In_ int x, // координата x
	_In_ int y, // координата y
	_In_ int nWidth, // ширина
	_In_ int nHeight, // высота
	_In_opt_ HWND hWndParent, // дескриптор родительского окна
	_In_opt_ HMENU hMenu, // номер пункта меню
	_In_opt_ HINSTANCE hInstance, // дескриптор приложения
	_In_opt_ LPVOID lpParam); // NULL</code></pre>
    <p>Указанная функция возвращает дескриптор элемента управления окна, который может быть впоследствии использован для
        анализа элемента управления, с которым связано обрабатываемое событие. Дескриптор кнопки, например, передается в
        оконную функцию в качестве параметра lparam.</p>
    <p>Таблицу стилей элементов управления окна можно устанавливать в параметре dwStyle, как и для создания
        родительского
        окна. При этом обязательно указывается, что создаваемое окно является дочерним &#8211; WS_CHILD.</p>
    <h3 id="9.1.3.1">9.1.3.1 Статический элемент</h3>
    <p><a href="glossary.html#m10">Статический текст</a> &#8211; текстовое поле, окно или прямоугольник, используемый для надписей, не подлежащих
        редактированию.
        Для установки статического текста используется функция SetWindowText.</p>
    <p>Чтобы поменять текст статика ему можно послать сообщение WM_SETTEXT (wp=0; lp=(LPARAM)(LPCSTR)lpsz &#8211; адрес
        строки)
        или использовать функции:</p>
    <pre class="cpp-code"><code class="language-cpp">BOOL WINAPI SetWindowText(HWND hw, LPCSTR lpsz)
BOOL WINAPI SetDlgItemText(HWND hDlg, int idControl, LPCTSTR lpsz)</code></pre>
    <p>Чтобы сменить иконку или картинку нетекстового статика, надо послать ему сообщение STM_SETIMAGE
        (wp=(WPARAM)fImageType &#8211; тип изображения: IMAGE_BITMAP или IMAGE_ICON; lp=(LPARAM)(HANDLE)hImage &#8211;
        дескриптор иконки
        или картинки). Пример статического элемента представлен на рисунке 9.3.</p>
    <p class="photo"><img src="./img/9_chapter/9.3.png" alt=""></p>
    <p class="signature">Рисунок 9.3 &#8211; Пример статического элемента</p>
    <h3 id="9.1.3.2">9.1.3.2 Кнопка </h3>
    <p><a href="glossary.html#m7">Кнопка</a> &#8211; это небольшое прямоугольное дочернее окно, обычно имеющее два состояния: нажато/отпущено или
        включено/выключено. Когда пользователь меняет состояние этого элемента щелчком мыши, кнопки управления обычно
        изменяют свой вид. К этому классу относятся кнопки-«давилки» (push buttons), кнопки-«галочки» (check boxes),
        «радио»-кнопки (radio buttons) и специальный тип групповых рамочек (group boxes). Кнопки управления могут
        использоваться самостоятельно или в группах, и они могут или быть подписаны, или появляться без текста.</p>
    <p>При нажатии кнопки операционная система генерирует сообщение WM_COMMAND с параметром lParam, соответствующим
        дескриптору кнопки.</p>
    <p>Обработка нажатия кнопки:</p>
    <pre class="cpp-code"><code class="language-cpp">LONG WINAPI WndProc(HWND hwnd, UINT Message, WPARAM wparam, LPARAM lparam){
    switch (Message){
    case WM_COMMAND:
        //обработка нажатия кнопки
        if (lparam == (LPARAM)hBtn){
        }
        break;
    }
}</code></pre>
    <p>Пример кнопки представлен на рисунке 9.4.</p>
    <p class="photo"><img src="./img/9_chapter/9.4.png" alt=""></p>
    <p class="signature">Рисунок 9.4 &#8211; Пример обычной кнопки</p>
    <p class="photo"><img src="./img/9_chapter/9.5.png" alt=""></p>
    <p class="signature">Рисунок 9.5 &#8211; Пример «радио»-кнопки</p>
    <p class="photo"><img src="./img/9_chapter/9.6.png" alt=""></p>
    <p class="signature">Рисунок 9.6 &#8211; Пример кнопки-флажок</p>
    <h3 id="9.1.3.3">9.1.3.3 Поле редактирования</h3>
    <p><a href="glossary.html#m9">Поле редактирования</a> предназначено для ввода пользователем текста с клавиатуры. Щелчком мыши внутри элемента или
        путем
        нажатия клавиши табуляции (TAB) пользователь передает этому элементу фокус ввода (input focus). При этом внутри
        элемента появляется текстовый курсор &#8211; мигающая каретка. Пользователь может вводить текст, когда окно
        редактирования
        текста отображает мигающую каретку. Пользователь может использовать мышь для перемещения каретки по полю
        редактирования и выделению текста в этом поле <a href="source.html#metka18">[18]</a>.</p>
    <p>Для считывания информации из поля редактирования используется функция:</p>
    <pre class="cpp-code"><code class="language-cpp">int WINAPI GetWindowText(
	_In_   HWND hWnd,   // дескриптор поля
	_Out_  LPTSTR lpString, // указатель на текстовую строку
	_In_   int nMaxCount); // максимальное количество символов</code></pre>
    <p>Возвращаемое значение &#8211; длина считанной текстовой строки. Для установки текста в поле редактирования
        используется
        функция:</p>
    <pre class="cpp-code"><code class="language-cpp">BOOL WINAPI SetWindowText(
	_In_      HWND hWnd,   // дескриптор поля
	_In_opt_  LPCTSTR lpString); // указатель на текстовую строку</code></pre>
    <p>В случае успешного завершения функция возвращает не нулевое значение.</p>
    <p>Пример поля редактирования представлен на рисунке 9.7.</p>
    <p class="photo"><img src="./img/9_chapter/9.7.png" alt=""></p>
    <p class="signature">Рисунок 9.7 &#8211; Пример поля редактирования</p>
    <h3 id="9.1.3.4">9.1.3.4 Окно-список</h3>
    <p><a href="glossary.html#m9">Окно-список</a> используется для отображения списка имен (например, имен файлов). Пользователь может, просматривая
        список, выделить один или несколько элементов щелчком мыши. При выделении того или иного элемента списка он
        подсвечивается, а родительскому окну посылается сообщение-оповещение. Для очень больших списков могут
        использоваться
        полосы прокрутки.</p>
    <p>Пример окна-списка представлен на рисунке 9.8.</p>
    <p class="photo"><img src="./img/9_chapter/9.8.png" alt=""></p>
    <p class="signature">Рисунок 9.8 &#8211; Пример окна-списка</p>
    <h3 id="9.1.3.5">9.1.3.5 Выпадающий список</h3>
    <p><a href="glossary.html#m1">Выпадающий список</a> &#8211; это помесь поля редактирования с окном-списком. Этот элемент содержит поле
        редактирование и
        список, который может отображаться все время либо «выпадать» при нажатии на кнопку рядом с полем редактирования.
        Есть три основных типа выпадающих списка:</p>
    <ol>
        <li class="with-a-dash">«выпадающий» комбинированный список (CBS_DROPDOWN) содержит поле редактирования и
            «выпадающий» список;
        </li>
        <li class="with-a-dash">«выпадающий» список (CBS_DROPDOWNLIST) не содержит поля для изменения текста;</li>
        <li class="with-a-dash">простой список (CBS_SIMPLE) содержит поле редактирования и обычный список.</li>
    </ol>
    <p>Для работы с выпадающими списками существуют сообщения, аналогичные списковым: CB_ADDSTRING, CB_DELETESTRING,
        CB_INSERTSTRING, CB_FINDSTRING, CB_GETCOUNT, CB_GETCURSEL, CB_RESETCONTENT.</p>
    <p>Выпадающий список посылает родительскому диалогу сообщение WM_COMMAND со следующими кодами оповещения:</p>
    <ol>
        <li class="with-a-dash">CBN_SELCHANGE, когда пользователь выделяет другую строку в выпадающем списке;</li>
        <li class="with-a-dash">CBN_SELENDOK, когда пользователь выбрал элемент в выпадающем списке и щелкнул мышкой по
            выделению (подтвердил выделение), для простых комбобоксов посылается перед каждым CBN_SELCHANGE;
        </li>
        <li class="with-a-dash">CBN_SELENDCANCEL, когда пользователь закрыл выпадающий список, так и не выбрав никакой
            элемент;
        </li>
        <li class="with-a-dash">CBN_DROPDOWN, когда открывается выпадающий список;</li>
        <li class="with-a-dash">CBN_CLOSEUP, когда выпадающий список был закрыт по той или иной причине.</li>
    </ol>
    <p>Пример выпадающего списка представлен на рисунке 9.9.</p>
    <p class="photo"><img src="./img/9_chapter/9.9.png" alt=""></p>
    <p class="signature">Рисунок 9.9 &#8211; Пример выпадающего списка</p>
    <h3 id="9.1.3.6">9.1.3.6 Диалоговые окна </h3>
    <p>Диалогового окна &#8211; это средства диалога системы и прикладной программы с пользователем. В прикладных
        программах окна
        сообщений удобно использовать, например, для вывода результатов вычислений или информации о ходе выполнении
        программы. Большинство приложений использует диалоговые окна для запроса у пользователя дополнительной
        информации
        для выполнения каких-либо команд. Для вывода окна сообщения можно воспользоваться следующей функцией:</p>
    <pre class="cpp-code"><code class="language-cpp">int MessageBox(
  HWND    hWnd, // дескриптор окна
  LPCTSTR lpText, // сообщение, которое будет отображаться
  LPCTSTR lpCaption, // заголовок диалогового окна
  UINT    uType // содержание и поведение диалогового окна.
);</code></pre>
    <p>Параметры функции:</p>
    <ol>
        <li class="with-a-dash">HWND hwnd &#8211; дескриптор окна владельца создаваемого окна сообщения. Если этот
            параметр
            равен нулю, то окно сообщения не имеет окна владельца;
        </li>
        <li class="with-a-dash">LPCTSTR lpText &#8211; сообщение, которое будет отображаться. Если строка состоит из
            нескольких
            строк, вы можете разделить их с помощью символа возврата каретки и/или перевода строки между каждой строкой
        </li>
        <li class="with-a-dash">LPCTSTR lpCaption &#8211; заголовок диалогового окна. Если этот параметр равен NULL, то
            заголовок по умолчанию &#8211; «Error»;
        </li>
        <li class="with-a-dash">UINT uType &#8211; содержание и поведение диалогового окна. Этот параметр может быть
            комбинацией
            флагов из следующих групп флагов.
        </li>
    </ol>
    <p>Пример окна сообщений представлен на рисунке 9.10. Для вывода диалогового окна необходимо прописать следующую
        команду:</p>
    <pre class="cpp-code"><code class="language-cpp">MessageBox(NULL, "Привет, мир!", "Оконная процедура", 0); //сообщение</code></pre>
    <p class="photo"><img src="./img/9_chapter/9.10.png" alt=""></p>
    <p class="signature">Рисунок 9.10 &#8211; Пример диалогового окна</p>
    <h3 id="9.1.4">9.1.4 Обработчик сообщений</h3>
    <p>В теле оконной функции после объявления необходимых локальных переменных используется оператор switch...case.
        Например:</p>
    <pre class="cpp-code"><code class="language-cpp">LRESULT CALLBACK WndProc(HWND hWnd, UINT msg,
	WPARAM wParam, LPARAM lParam){
	switch (Msg){
	case WM_CREATE:
		return TRUE;
	case WM_KEYDOWN:
		/* Обрабатываем сообщение WM_KEYDOWN
		(нажатие клавиши) */
		switch (wParam){
			/* Клавиша Esc */
		case VK_ESCAPE:{
			SendMessage(hWnd, WM_CLOSE, 0, 0);
			break;
		}
			break;
		case WM_DESTROY:  /* Функция PostQuitMessage выполняет только одно действие,
		ставит в очередь сообщение WM_QUIT. Параметр у этой функции &#8211; код возврата,
		который помещается в Msg.wParam и возвращается главной функцией */
			PostQuitMessage(0);
			break;
		default:
			/*Обработка прочих сообщений по умолчанию*/
			return DefWindowProc(hWnd, msg, wParam, lParam);
		}
		return 0;
	}
}</code></pre>
    <p>Реально в программе требуется обрабатывать конкретные сообщения, а для обработки прочих сообщений предназначена
        функция DefWindowProc() (Default Windows Procedure).</p>
    <p>Оконная процедура получает сообщения, инициируемые тремя частями аппаратного обеспечения: клавиатурой, мышью и
        системным таймером. Все они генерируют аппаратные прерывания. Поскольку диспетчеризация Windows не действует в
        режиме прерываний, аппаратные события должны быть буферизованы. Это обеспечивает обработку событий в порядке их
        поступления.</p>
    <p>Например, при нажатии клавиши &ltК> прерывание уведомляет систему о том, что приготовлены данные от клавиатуры.
        Драйвер клавиатуры отыскивает эти данные и создает элемент в первичной очереди, откуда система их передает в
        очередь
        приложения, а точнее конкретного потока. Когда наступает его очередь, сообщения, содержащие информацию о клавише
        &ltК>, направляются в соответствующую оконную процедуру. Сообщения от мыши и системного таймера обрабатываются
        аналогично. В таблицах 9.2 &#8211; 9.6 представлены основные сообщения, которые формируются в ответ на различные
        события.</p>
    <p>Таблица 9.2 &#8211; Сообщения от мыши в клиентской области окна</p>
    <p class="tables"><img src="./img/9_chapter/table9.2.png" alt=""></p>
    <p>Таблица 9.3 &#8211; Сообщения от мыши вне клиентской области окна</p>
    <p class="tables"><img src="./img/9_chapter/table9.3.png" alt=""></p>
    <p>Таблица 9.4 &#8211; Сообщения от клавиатуры</p>
    <p class="tables"><img src="./img/9_chapter/table9.4.png" alt=""></p>
    <p>Таблица 9.5 &#8211; Оконные сообщения: уведомление</p>
    <p class="tables"><img src="./img/9_chapter/table9.5.png" alt=""></p>
    <p>Таблица 9.6 &#8211; Сообщения блока диалога и его элементов управления</p>
    <p class="tables"><img src="./img/9_chapter/table9.6.png" alt=""></p>
    <p>Следующая программа регистрирует класс, создает окно этого класса и обслуживает сообщение WM_LBUTTONUP (оно
        приходит
        по событию отпускания левой кнопки мыши), показывает окно и после обработки сообщения снова возвращается в цикл
        сообщений, находящийся в WinMain.</p>
    <p>Алгоритм обработки щелчка левой кнопки мыши:</p>
    <ol>
        <li class="with-a-bracket">пользователь нажимает левую кнопку мыши в то время, когда курсор мыши находится над
            рабочей областью окна;
        </li>
        <li class="with-a-bracket">windows помещает сообщение WM_LBUTTONDOWN в очередь потока;</li>
        <li class="with-a-bracket">цикл обработки сообщения должен вынуть сообщение с помощью функ-ции GetMessage и
            передать
            его на обработку функции DispatchMessage;
        </li>
        <li class="with-a-bracket">функция DispatchMessage находит окно, которому предназначено сообщение и помещает
            сообщение в его очередь;
        </li>
        <li class="with-a-bracket">функция окна обрабатывает сообщение WM_LBUTTONDOWN и возвращает результат;</li>
        <li class="with-a-bracket">тело цикла заканчивается, и управление снова передается функции GetMessage для
            ожидания
            новых сообщений.
        </li>
    </ol>
    <pre class="cpp-code"><code class="language-cpp">#include &ltwindows.h>
// объявление функций
LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);
ATOM RegMyWindowClass(HINSTANCE, LPCTSTR);
// функция вхождений программы WinMain
int APIENTRY WinMain(HINSTANCE hInstance,
	HINSTANCE         hPrevInstance,
	LPSTR             lpCmdLine,
	int               nCmdShow){
	// имя будущего класса
	LPCTSTR lpzClass = TEXT("My Window Class!");
	// регистрация класса
	if (!RegMyWindowClass(hInstance, lpzClass))
		return 1;
	// вычисление координат центра экрана
	RECT screen_rect;
	GetWindowRect(GetDesktopWindow(), &screen_rect); // разрешение экрана
	int x = screen_rect.right / 2 - 150;
	int y = screen_rect.bottom / 2 - 75;
	// создание диалогового окна
	HWND hWnd = CreateWindow(lpzClass, TEXT("Dialog Window"),
		WS_OVERLAPPEDWINDOW | WS_VISIBLE, x, y, 300, 150, NULL, NULL,
		hInstance, NULL);
	// если окно не создано, описатель будет равен 0
	if (!hWnd) return 2;
	// цикл сообщений приложения
	MSG msg = { 0 };    // структура сообщения
	int iGetOk = 0;   // переменная состояния
	while ((iGetOk = GetMessage(&msg, NULL, 0, 0)) != 0){
		// цикл сообщений
		if (iGetOk == -1) return 3;  // если GetMessage вернул ошибку &#8211; выход
		TranslateMessage(&msg);
		DispatchMessage(&msg);
	}
	return msg.wParam;  // возвращаем код завершения программы
} // функция регистрации класса окон
ATOM RegMyWindowClass(HINSTANCE hInst, LPCTSTR lpzClassName){
	WNDCLASS wcWindowClass = { 0 };
	// адрес ф-ции обработки сообщений
	wcWindowClass.lpfnWndProc = (WNDPROC)WndProc;
	// стиль окна
	wcWindowClass.style = CS_HREDRAW | CS_VREDRAW;
	// дискриптор экземпляра приложения
	wcWindowClass.hInstance = hInst;
	// название класса
	wcWindowClass.lpszClassName = lpzClassName;
	// загрузка курсора
	wcWindowClass.hCursor = LoadCursor(NULL, IDC_ARROW);
	// загрузка цвета окон
	wcWindowClass.hbrBackground = (HBRUSH)COLOR_APPWORKSPACE;
	return RegisterClass(&wcWindowClass); // регистрация класса
}
// функция обработки сообщений
LRESULT CALLBACK WndProc(
	HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam){
	// выборка и обработка сообщений
	switch (message){
	case WM_LBUTTONUP:		// реакция на сообщение
		MessageBox(hWnd, TEXT("Вы кликнули!"), TEXT("событие"), 0);
		break;
	case WM_DESTROY:
		PostQuitMessage(0);  // реакция на сообщение
		break;
	default:		// все сообщения, не обработанные вами, обработает сама Windows
		return DefWindowProc(hWnd, message, wParam, lParam);
	}
	return 0;
}</code></pre>
    <p>Результат работы программы представлен на рисунках 9.11 &#8211; 9.12.</p>
    <p class="photo"><img src="./img/9_chapter/9.11.png" alt=""></p>
    <p class="signature">Рисунок 9.11 &#8211; Главное окно</p>
    <p class="photo"><img src="./img/9_chapter/9.12.png" alt=""></p>
    <p class="signature">Рисунок 9.12 &#8211; Обработка нажатия левой кнопки мыши по области главного окна</p>
    <p>В ОС Windows при каждом событии, произошедшем в системе, отсылается «сообщение Windows» («windows message»). Эти
        сообщения уведомляют программу о событиях в системе, а программа, в свою очередь, может на них реагировать.
        Сообщения может отсылать не только Windows, но и сами приложения. Это является одним из способов организации
        связи
        между процессами в системе. Конечно, программа может отсылать сообщения и самой себе.</p>
    <p>Следует обратить внимание, что сообщение можно отослать функцией SendMessage или ее асинхронным аналогом
        PostMessage.</p>
    <p>Для приема сообщений в программе должен находиться «цикл сообщений» («message loop»), который обычно выглядит
        так:</p>
    <pre class="cpp-code"><code class="language-cpp">//цикл сообщений приложения
MSG msg = { 0 };  //структура сообщения
int iGetOk = 0;   //переменная состояния
while ((iGetOk = GetMessage(&msg, NULL, 0, 0)) != 0){
    //цикл сообщений
    //если GetMessage вернул ошибку &#8211; выход
    if (iGetOk == -1) return 3;
    TranslateMessage(&msg);
    DispatchMessage(&msg);
}</code></pre>
    <p>Функция GetMessage принимает следующие параметры:</p>
    <ol>
        <li class="with-a-dash">LPMSG lpMsg &#8211; указатель на структуру сообщения, в которую GetMessage вернет
            результат
        </li>
        <li class="with-a-dash">HWND hWnd &#8211; описатель окна, от которого GetMessage примет сообщение (NULL
            означает, что
            GetMessage принимает сообщения от всех окон, принадлежащих потоку);
        </li>
        <li class="with-a-dash">UINT wMsgFilterMin &#8211; наименьший идентификатор сообщения, которое примет
            GetMessage
        </li>
        <li class="with-a-dash">UINT wMsgFilterMax &#8211; наибольший идентификатор сообщения, которое примет GetMessage
            (если в
            значениях параметров wMsgFilterMin и wMsgFilterMax передать 0, функция будет принимать ВСЕ сообщения).
        </li>
    </ol>
    <p>Функция GetMessage не отдает управление программе, пока не придет какое-либо сообщение. Если пришедшее сообщение
        &#8211;
        WM_QUIT, функция GetMessage вернет 0. Тогда цикл прервется, и программа завершит свою работу. При любом другом
        сообщении функция GetMessage возвращает значение больше нуля, и начинается выполнение тела цикла. При ошибке
        GetMessage возвращает -1.</p>
    <h3 id="9.1.5">9.1.5 Пример создания визуального приложения с помощью технологии WinAPI</h3>
    <p>Для ознакомления работы с технологией WinAPI представлен пример создания приложений Windows в инструментальной
        среде
        Microsoft Visual Studio.</p>
    <p>Следующий пример демонстрирует создание формы, в которой использованы все элементы управления. Представлена
        анкета
        для студентов, в которой они должны ввести свои данные. По нажатию кнопки выводится сообщение о том, что анкета
        принята.</p>
    <p>Для создания оконного приложения необходимо открыть инструментальную среду Microsoft Visual Studio, затем нажать
        на
        вкладку «Файл», далее «Создать проект» (рисунок 9.13).</p>
    <p class="photo"><img src="./img/9_chapter/9.13.png" alt=""></p>
    <p class="signature">Рисунок 9.13 &#8211; Окно создания</p>
    <p>Откроется следующее окно выбора шаблона (рисунок 9.14). Необходимо выбрать пункт «Классическое приложение
        Windows».</p>
    <p class="photo"><img src="./img/9_chapter/9.14.png" alt=""></p>
    <p class="signature">Рисунок 9.14 &#8211; Выбор шаблона</p>
    <p>Как видно на рисунке 9.15, в качестве имени проекта было задано имя «Project1».</p>
    <p class="photo"><img src="./img/9_chapter/9.15.png" alt=""></p>
    <p class="signature">Рисунок 9.15 &#8211; Задание имени проекта</p>
    <p>При выборе «Классическое приложение Windows» пользователю предоставляется готовый шаблон (рисунок 9.16).</p>
    <p class="photo"><img src="./img/9_chapter/9.16.png" alt=""></p>
    <p class="signature">Рисунок 9.16 &#8211; Классическое приложение Windows</p>
    <p>В данном шаблоне пользователь может редактировать код под свою задачу. Чтобы добавить к проекту файл типа
        «имя».cpp,
        нужно кликнуть по вкладке «Файлы исходного кода» правой кнопкой мыши, в раскрывающемся списке выбрать вкладку
        «Добавить», далее «Создать элемент...». В результате должно появиться окно, показанное на рисунке 9.14. В
        рассматриваемом примере было использовано имя файла «Source.cpp».</p>
    <p class="photo"><img src="./img/9_chapter/9.17.png" alt=""></p>
    <p class="signature">Рисунок 9.17 &#8211; Добавление файла</p>
    <p>Далее представлен код приложения для данного примера по созданию анкеты для студентов, созданного с помощью
        технологии WinAPI с использованием основных элементов управления окна.</p>
    <p>Для начала создадим пустое окно (рисунок 9.18). Подключим директиву <strong>#include &ltwindows.h></strong>.</p>
    <p>Создание главного диалогового окна описывается функцией</p>
    <pre class="cpp-code"><code class="language-cpp">HWND hWnd = CreateWindow(lpzClass, TEXT("Dialog Window"),
        WS_OVERLAPPEDWINDOW | WS_VISIBLE, x, y, 400, 400, NULL, NULL, hInstance, NULL);</code></pre>
    <p>Размер окна в примере 400х400.</p>
    <p class="photo"><img src="./img/9_chapter/9.18.png" alt=""></p>
    <p class="signature">Рисунок 9.18 &#8211; Пустое окно</p>
    <p>Для создания приложения Windows необходимы три функции:</p>
    <p>1) Функция вхождений программы WinMain.</p>
    <pre class="cpp-code"><code class="language-cpp">int APIENTRY WinMain(HINSTANCE hInstance,
	HINSTANCE         hPrevInstance,
	LPSTR             lpCmdLine,
	int               nCmdShow)
{	// имя будущего класса
	LPCTSTR lpzClass = TEXT("My Window Class!");
	// регистрация класса
	if (!RegMyWindowClass(hInstance, lpzClass))
		return 1;
	// вычисление координат центра экрана
	RECT screen_rect;
GetWindowRect(GetDesktopWindow(), &screen_rect); // разрешение экрана
	int x = screen_rect.right / 2 - 150;
	int y = screen_rect.bottom / 2 - 75;
	// создание диалогового окна
HWND hWnd = CreateWindow(lpzClass, TEXT("Dialog Window"),
	WS_OVERLAPPEDWINDOW | WS_VISIBLE, x, y, 300, 150, NULL, NULL,
	hInstance, NULL);
	// если окно не создано, описатель будет равен 0
	if (!hWnd) return 2;
	// цикл сообщений приложения
	MSG msg = { 0 };    // структура сообщения
	int iGetOk = 0;   // переменная состояния
	while ((iGetOk = GetMessage(&msg, NULL, 0, 0)) != 0) // цикл сообщений
	{if (iGetOk == -1) return 3;  // если GetMessage вернул ошибку - выход
		TranslateMessage(&msg);
		DispatchMessage(&msg);	}
	return msg.wParam;  // возвращаем код завершения программы
}
</code></pre>
    <p>Для корректной работы программы следует объявить функции перед функцией вхождения.</p>
    <pre class="cpp-code"><code class="language-cpp">LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);
ATOM RegMyWindowClass(HINSTANCE, LPCTSTR);
</code></pre>
    <p>2) Функция регистрации класса окон:</p>
    <pre class="cpp-code"><code class="language-cpp">ATOM RegMyWindowClass(HINSTANCE hInst, LPCTSTR lpzClassName)
{	WNDCLASS wcWindowClass = { 0 };
	// адрес ф-ции обработки сообщений
	wcWindowClass.lpfnWndProc = (WNDPROC)WndProc;
	// стиль окна
	wcWindowClass.style = CS_HREDRAW | CS_VREDRAW;
	// дискриптор экземпляра приложения
	wcWindowClass.hInstance = hInst;
    // название класса
	wcWindowClass.lpszClassName = lpzClassName;
	// загрузка курсора
	wcWindowClass.hCursor = LoadCursor(NULL, IDC_ARROW);
	// загрузка цвета окон
	wcWindowClass.hbrBackground = (HBRUSH)COLOR_APPWORKSPACE;
	return RegisterClass(&wcWindowClass); // регистрация класса}
</code></pre>
    <p>3) Функция обработки сообщений:</p>
    <pre class="cpp-code"><code class="language-cpp">LRESULT CALLBACK WndProc(
	HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{	// выборка и обработка сообщений
	switch (message)
	{
	case WM_DESTROY:
		PostQuitMessage(0);  // реакция на сообщение
		break;
	default:	// все сообщения, не обработанные вами, обработает сама Windows
		return DefWindowProc(hWnd, message, wParam, lParam); }
	return 0;}
</code></pre>
    <p>Далее все манипуляции с кодом будут проводиться в функции обработки сообщений. Важной частью функции обработки
        сообщений является оператор switch...case. Для удобства следует разделить функцию на 2 части: в первой, до
        оператора switch…case, объявляются переменные, во второй, в самом операторе switch...case, обрабатываются
        конкретные сообщения.</p>
    <p>Чтобы можно было создавать элементы управления, необходимо добавить в оператор switch…case обработчик
        создания:</p>
    <pre class="cpp-code"><code class="language-cpp">case WM_CREATE:
break;
</code></pre>
    <p>Здесь создаются все элементы управления.</p>
    <p>Для начала следует создать элемент «Статический текст». Для этого объявляется дескриптор статического текста в 1
        части функции:</p>
    <pre class="cpp-code"><code class="language-cpp">static HWND hStat; // дескриптор статического текста</code></pre>
    <p>Теперь нужно создать элемент во второй части функции в обработчике с помощью следующей команды:</p>
    <pre class="cpp-code"><code class="language-cpp">hStat = CreateWindow(TEXT("static"), TEXT("Анкета"),
WS_CHILD | WS_VISIBLE, 100, 10, 120, 20, hWnd, 0, hInst, NULL);</code></pre>
    <p>Для отображения элемента необходима команда:</p>
    <pre class="cpp-code"><code class="language-cpp">ShowWindow(hStat, SW_SHOWNORMAL);</code></pre>
    <p>В результате получим статический текст «Анкета» размером 120х20 и положением х = 100, у = 10 (рисунок 9.19).
        Изменяя данные параметры, можно менять вид, размер и положение элемента управления.</p>
    <p class="photo"><img src="./img/9_chapter/9.19.png" alt=""></p>
    <p class="signature">Рисунок 9.19 &#8211; Добавление статического текста</p>
    <p>Далее необходимо добавить окно редактирования. Дескриптор окна редактирования:</p>
    <pre class="cpp-code"><code class="language-cpp">static HWND hEdt1; // дескриптор поля редактирования</code></pre>
    <p>Теперь нужно создать элемент во 2 части функции в обработчике:</p>
    <pre class="cpp-code"><code class="language-cpp">hEdt1 = CreateWindow(TEXT("edit"),
NULL, WS_CHILD | WS_VISIBLE | WS_BORDER, 100, 30, 180, 30, hWnd, 0, hInst, NULL);
ShowWindow(hEdt1, SW_SHOWNORMAL);
</code></pre>
    <p>В результате было получено пустое окно редактирования размером 180х30, положением х = 100, у = 30 (рисунок 9.20).</p>
    <p class="photo"><img src="./img/9_chapter/9.20.png" alt=""></p>
    <p class="signature">Рисунок 9.20 &#8211; Добавление окна редактирования</p>
    <p>Следующий элемент &#8211; радиокнопки. В примере будет две радиокнопки. Сначала нужно объявить дескрипторы
        кнопок:</p>
    <pre class="cpp-code"><code class="language-cpp">static HWND rBtn1, rBtn2;</code></pre>
    <p>Так как кнопки-давилки, кнопки-галочки и радиокнопки представляют собой один и тот же элемент, кнопке необходимо
        прописать стиль <strong>BS_RADIOBUTTON или BS_AUTORADIOBUTTON</strong>, чтобы придать вид радиокнопки. В первом
        случае обработчик
        нажатия кнопки необходимо прописывать самостоятельно. Во втором случае программа делает это автоматически.</p>
    <p>Команда для создания кнопок:</p>
    <pre class="cpp-code"><code class="language-cpp">rBtn1 = CreateWindow(TEXT("button"), TEXT("Мужской"),
WS_CHILD | WS_VISIBLE | BS_AUTORADIOBUTTON, 100, 70, 120, 20, hWnd, 0, hInst, NULL);
ShowWindow(rBtn1, SW_SHOWNORMAL);
rBtn2 = CreateWindow(TEXT("button"), TEXT("Женский"),
WS_CHILD | WS_VISIBLE | BS_AUTORADIOBUTTON, 100, 90, 120, 20, hWnd, 0, hInst, NULL);
ShowWindow(rBtn2, SW_SHOWNORMAL);
</code></pre>
    <p>В результате были получены две радиокнопки, связанные между собой (рисунок 9.21).</p>
    <p class="photo"><img src="./img/9_chapter/9.21.png" alt=""></p>
    <p class="signature">Рисунок 9.21 &#8211; Результат добавления радиокнопок</p>
    <p>Далее было реализовано добавление выпадающего списка. Объявление дескриптора:</p>
    <pre class="cpp-code"><code class="language-cpp">static HWND сBox; // дескриптор выпадающего списка</code></pre>
    <p>Создание выпадающего списка:</p>
    <pre class="cpp-code"><code class="language-cpp">cBox = CreateWindow(TEXT("combobox"), NULL,
WS_CHILD | WS_VISIBLE | WS_VSCROLL | CBS_DROPDOWNLIST | CBS_HASSTRINGS | CBS_AUTOHSCROLL,
100, 120, 120, 100, hWnd, (HMENU)cBox, hInst, NULL);</code></pre>
    <p>Для записи строк в выпадающий список нужно использовать команду:</p>
    <pre class="cpp-code"><code class="language-cpp">LRESULT SendMessage(
    HWND hWnd,
    UINT Msg,
    WPARAM wParam,
    LPARAM lParam
);</code></pre>
    <p>Функция SendMessage отправляет заданное сообщение окну или окнам. Чтобы отправить сообщение окну, необходимо его
        задать. Это можно сделать с помощью команды</p>
    <pre class="cpp-code"><code class="language-cpp">int wsprintf(
    LPTSTR lpOut,
    LPCTSTR lpFmt,
     ...
);</code></pre>
    <p>Функция wsprintf форматирует и хранит ряд символов и значений в буфере. Данный код отправляет четыре сообщения
        элементу «Выпадающий список».</p>
    <pre class="cpp-code"><code class="language-cpp">wsprintf(str, L"До 18 лет", NULL);
SendMessage(cBox, CB_ADDSTRING, 0, (LPARAM)str);
wsprintf(str, L"От 18 до 25 лет", NULL);
SendMessage(cBox, CB_ADDSTRING, 1, (LPARAM)str);
wsprintf(str, L"От 25 до 40 лет", NULL);
SendMessage(cBox, CB_ADDSTRING, 2, (LPARAM)str);
wsprintf(str, L"От 40 до 60 лет", NULL);
SendMessage(cBox, CB_ADDSTRING, 3, (LPARAM)str);
wsprintf(str, L"От 60 лет", NULL);
SendMessage(cBox, CB_ADDSTRING, 4, (LPARAM)str);
SendMessage(cBox, CB_SETCURSEL, 0, 0L);
</code></pre>
    <p>Теперь можно показать окно:</p>
    <pre class="cpp-code"><code class="language-cpp">ShowWindow(hBtn, SW_SHOWNORMAL);</code></pre>
    <p>В результате был получен выпадающий список, состоящий из 4 строк, представленный на рисунке 9.22.</p>
    <p class="photo"><img src="./img/9_chapter/9.22.png" alt=""></p>
    <p class="signature">Рисунок 9.22 &#8211; Добавление выпадающего списка</p>
    <p>Следующий элемент &#8211; «Check-box» или «кнопка-галочка». Объявление дескрипторов кнопок:</p>
    <pre class="cpp-code"><code class="language-cpp">static HWND cBtn1, cBtn2, cBtn3;</code></pre>
    <p>Так как кнопки-давилки, кнопки-галочки и радиокнопки представляют собой один и тот же элемент, кнопке необходимо
        прописать стиль <strong>BS_CHECKBOX или BS_ AUTOCHECKBOX</strong>, чтобы придать вид кнопки-галочки.</p>
    <p>Создание кнопок:</p>
    <pre class="cpp-code"><code class="language-cpp">cBtn1 = CreateWindow(TEXT("button"), TEXT("С++"),
WS_CHILD | WS_VISIBLE | BS_AUTOCHECKBOX, 100, 170, 70, 20, hWnd, 0, hInst, NULL);
ShowWindow(cBtn1, SW_SHOWNORMAL);
cBtn2 = CreateWindow(TEXT("button"), TEXT("Python"),
WS_CHILD | WS_VISIBLE | BS_AUTOCHECKBOX, 100, 190, 70, 20, hWnd, 0, hInst, NULL);
ShowWindow(cBtn2, SW_SHOWNORMAL);
cBtn3 = CreateWindow(TEXT("button"), TEXT("Java"),
WS_CHILD | WS_VISIBLE | BS_AUTOCHECKBOX, 100, 210, 70, 20, hWnd, 0, hInst, NULL);
ShowWindow(cBtn3, SW_SHOWNORMAL);
</code></pre>
    <p>Результат добавления представлен на рисунке 9.23.</p>
    <p class="photo"><img src="./img/9_chapter/9.23.png" alt=""></p>
    <p class="signature">Рисунок 9.23 &#8211; Результат добавления кнопок-галочек</p>
    <p>Теперь нужно создать окно-список. Объявление дескриптора:</p>
    <pre class="cpp-code"><code class="language-cpp">static HWND lBox; // дескриптор окна-списка</code></pre>
    <p>Команда для создания окна-списка:</p>
    <pre class="cpp-code"><code class="language-cpp">lBox = CreateWindow(TEXT("listbox"), TEXT("ОК"),
WS_CHILD | WS_VISIBLE | LBS_STANDARD | LBS_WANTKEYBOARDINPUT | LBS_SORT | WS_HSCROLL,
100, 250, 220, 80, hWnd, (HMENU)lBox, hInst, NULL);
ShowWindow(hBtn, SW_SHOWNORMAL);
</code></pre>
    <p>Теперь список необходимо заполнить. Запись строк в список происходит так же, как и в окно-список. Данный код
        отправляет 9 сообщений элементу «Окно-список»:</p>
    <pre class="cpp-code"><code class="language-cpp"></code>// Отменяется режим перерисовки списка
SendMessage(lBox, WM_SETREDRAW, FALSE, 0L);
// Добавляется в список несколько строк
wsprintf(str, L"Зеленый", NULL);
SendMessage(lBox, LB_ADDSTRING, 0, (LPARAM)(LPSTR)str);
wsprintf(str, L"Красный", NULL);
SendMessage(lBox, LB_ADDSTRING, 0, (LPARAM)(LPSTR)str);
wsprintf(str, L"Розовый", NULL);
SendMessage(lBox, LB_ADDSTRING, 0, (LPARAM)(LPSTR)str);
wsprintf(str, L"Пурпурный", NULL);
SendMessage(lBox, LB_ADDSTRING, 0, (LPARAM)(LPSTR)str);
wsprintf(str, L"Синий", NULL);
SendMessage(lBox, LB_ADDSTRING, 0, (LPARAM)(LPSTR)str);
wsprintf(str, L"Желтый", NULL);
SendMessage(lBox, LB_ADDSTRING, 0, (LPARAM)(LPSTR)str);
wsprintf(str, L"Фиолетовый", NULL);
SendMessage(lBox, LB_ADDSTRING, 0, (LPARAM)(LPSTR)str);
wsprintf(str, L"Черный", NULL);
SendMessage(lBox, LB_ADDSTRING, 0, (LPARAM)(LPSTR)str);
wsprintf(str, L"Белый", NULL);
SendMessage(lBox, LB_ADDSTRING, 0, (LPARAM)(LPSTR)str);
// Включается режим перерисовки списка
SendMessage(lBox, WM_SETREDRAW, TRUE, 0L);
// Перерисовывается список
InvalidateRect(lBox, NULL, TRUE);
</pre>
    <p>Результат добавления показан на рисунке 9.24.</p>
    <p class="photo"><img src="./img/9_chapter/9.24.png" alt=""></p>
    <p class="signature">Рисунок 9.24 &#8211; Добавление окна-списка</p>
    <p>Осталось создать кнопку. Далее был объявлен дескриптор кнопки:</p>
    <pre class="cpp-code"><code class="language-cpp">static HWND hBtn;</code></pre>
    <p>Создаем и показываем кнопку:</p>
    <pre class="cpp-code"><code class="language-cpp">hBtn = CreateWindow(TEXT("button"), TEXT("ОК"),
WS_CHILD | WS_VISIBLE | WS_BORDER, 100, 330, 80, 25, hWnd, 0, hInst, NULL);</code></pre>
    <p>В результате получаем кнопку-давилку с надписью «ОК» (рисунок 9.25).</p>
    <p class="photo"><img src="./img/9_chapter/9.25.png" alt=""></p>
    <p class="signature">Рисунок 9.25 &#8211; Результат добавления push-кнопки</p>
    <p>Для подписи элементов можно использовать текстовые сообщения. Для вывода текстовых сообщений в окно воспользуемся
        обработчиком перерисовки окна:</p>
    <pre class="cpp-code"><code class="language-cpp">case WM_PAINT:
break;
</code></pre>
    <p>Для вывода сообщений используется команда:</p>
    <pre class="cpp-code"><code class="language-cpp">BOOL TextOut(
  HDC hdc,           // дескриптор DC
  int nXStart,       // x-координата начальной позиции
  int nYStart,       // y-координата начальной позиции
  LPCTSTR lpString,  // строка символов
  int cbString       // число символов
);
</code></pre>
    <p>Чтобы начать перерисовку окна, необходимо объявить дескриптор контекста устройства:</p>
    <pre class="cpp-code"><code class="language-cpp">HDC hdc;</code></pre>
    <p>А в обработчике сообщений обозначить начало и конец перерисовки:</p>
    <pre class="cpp-code"><code class="language-cpp">hdc = BeginPaint(hWnd, &ps); // начало перерисовки
EndPaint(hWnd, &ps); // конец перерисовки
</code></pre>
    <p>Полный код обработчика перерисовки окна представлен ниже:</p>
    <pre class="cpp-code"><code class="language-cpp">case WM_PAINT: // перерисовка окна
			hdc = BeginPaint(hWnd, &ps); // начало перерисовки
			TextOut(hdc, 10, 30, TEXT("Ваше имя:"), 10); // вывод текстовых сообщений
			TextOut(hdc, 10, 70, TEXT("Ваш пол:"), 10);
			TextOut(hdc, 10, 120, TEXT("Возраст:"), 10); // вывод текстовых сообщений
			TextOut(hdc, 10, 150, TEXT("На каком языке программируете?"), 30);
			TextOut(hdc, 10, 230, TEXT("Выберите любимый цвет:"), 23);
			EndPaint(hWnd, &ps); // конец перерисовки
			break;
</code></pre>
    <p>Результат перерисовки представлен на рисунке 9.26.</p>
    <p class="photo"><img src="./img/9_chapter/9.26.png" alt=""></p>
    <p class="signature">Рисунок 9.26 &#8211; Результат перерисовки</p>
    <p>Получилась форма, на которой представлены элементы управления классического приложения Windows. Теперь необходимо
        добавить обработчик нажатия кнопки.</p>
    <p>Для этого нужно воспользоваться обработчиком:</p>
    <pre class="cpp-code"><code class="language-cpp">case WM_COMMAND:
break;
</code></pre>
    <p>Чтобы понимать, работает ли обработчик нажатия кнопки, можно добавить вывод диалогового окна с сообщением по нажатию
        кнопки «ОК»:</p>
    <pre class="cpp-code"><code class="language-cpp">if (lParam == (LPARAM)hBtn)  // если нажали на кнопку
	{
		MessageBox(hWnd, TEXT("Анкета принята!"), TEXT("Событие"), 0);
	}
</code></pre>
    <p>В результате по нажатию кнопки «ОК» будет выводиться следующее сообщение: «Анкета принята!» (рисунок 9.27).</p>
    <p class="photo"><img src="./img/9_chapter/9.27.png" alt=""></p>
    <p class="signature">Рисунок 9.27 &#8211; Диалоговое окно</p>
    <p>Полный листинг программы будет выглядеть следующим образом:</p>
    <pre class="cpp-code"><code class="language-cpp">#include &ltwindows.h>
// объявление функций
LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);
ATOM RegMyWindowClass(HINSTANCE, LPCTSTR);
// функция вхождений программы WinMain
int APIENTRY WinMain(HINSTANCE hInstance,
	HINSTANCE         hPrevInstance,
	LPSTR             lpCmdLine,
	int               nCmdShow){
	// имя будущего класса
	LPCTSTR lpzClass = TEXT("My Window Class!");
	// регистрация класса
	if (!RegMyWindowClass(hInstance, lpzClass))
		return 1;
	// вычисление координат центра экрана
	RECT screen_rect;
	GetWindowRect(GetDesktopWindow(), &screen_rect); // разрешение экрана
	int x = screen_rect.right / 2 - 150;
	int y = screen_rect.bottom / 2 - 75;
	// создание диалогового окна
	HWND hWnd = CreateWindow(lpzClass, TEXT("Dialog Window"),
		WS_OVERLAPPEDWINDOW | WS_VISIBLE, x, y, 400, 400, NULL, NULL,
		hInstance, NULL);
	// если окно не создано, описатель будет равен 0
	if (!hWnd) return 2;
	// цикл сообщений приложения
	MSG msg = { 0 };    // структура сообщения
	int iGetOk = 0;   // переменная состояния
	while ((iGetOk = GetMessage(&msg, NULL, 0, 0)) != 0){
		// цикл сообщений
		if (iGetOk == -1) return 3;  // если GetMessage вернул ошибку - выход
		TranslateMessage(&msg);
		DispatchMessage(&msg);
	}
	return msg.wParam;  // возвращаем код завершения программы
}
// функция регистрации класса окон
ATOM RegMyWindowClass(HINSTANCE hInst, LPCTSTR lpzClassName){
	WNDCLASS wcWindowClass = { 0 };
	// адрес ф-ции обработки сообщений
	wcWindowClass.lpfnWndProc = (WNDPROC)WndProc;
	// стиль окна
	wcWindowClass.style = CS_HREDRAW | CS_VREDRAW;
	// дискриптор экземпляра приложения
	wcWindowClass.hInstance = hInst;
	// название класса
	wcWindowClass.lpszClassName = lpzClassName;
	// загрузка курсора
	wcWindowClass.hCursor = LoadCursor(NULL, IDC_ARROW);
	// загрузка цвета окон
	wcWindowClass.hbrBackground = (HBRUSH)COLOR_APPWORKSPACE;
	return RegisterClass(&wcWindowClass); // регистрация класса
}
// функция обработки сообщений
LRESULT CALLBACK WndProc(
	HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam){
	HDC hdc;
	HINSTANCE hInst;
	PAINTSTRUCT ps;
	static HWND hBtn, rBtn1, rBtn2, cBtn1, cBtn2, cBtn3;// дескриптор кнопки
	static HWND hEdt1; // дескрипторы полей редактирования
	static HWND hStat; // дескриптор статического текста
	static HWND lBox; // дескриптор статического текста
	static HWND cBox; // дескриптор статического текста
	TCHAR StrA[20];
	int a, b, sum, Len;
	LPWSTR str = new TCHAR[20];
	switch (message){
	case WM_CREATE:
		hInst = ((LPCREATESTRUCT)lParam)->hInstance; // дескриптор приложения
			  // Создается и показывается первое поле редактирования
		rBtn1 = CreateWindow(TEXT("button"), TEXT("Мужской"),
			WS_CHILD | WS_VISIBLE | BS_AUTORADIOBUTTON, 100, 70, 120, 20,
			hWnd, 0, hInst, NULL);
		ShowWindow(rBtn1, SW_SHOWNORMAL);
		rBtn2 = CreateWindow(TEXT("button"), TEXT("Женский"),
			WS_CHILD | WS_VISIBLE | BS_AUTORADIOBUTTON, 100, 90, 120, 20,
			hWnd, 0, hInst, NULL);
		ShowWindow(rBtn2, SW_SHOWNORMAL);
		cBtn1 = CreateWindow(TEXT("button"), TEXT("С++"),
			WS_CHILD | WS_VISIBLE | BS_AUTOCHECKBOX, 100, 170, 70, 20,
			hWnd, 0, hInst, NULL);
		ShowWindow(cBtn1, SW_SHOWNORMAL);
		cBtn2 = CreateWindow(TEXT("button"), TEXT("Python"),
			WS_CHILD | WS_VISIBLE | BS_AUTOCHECKBOX, 100, 190, 70, 20,
			hWnd, 0, hInst, NULL);
		ShowWindow(cBtn2, SW_SHOWNORMAL);
		cBtn3 = CreateWindow(TEXT("button"), TEXT("Java"),
			WS_CHILD | WS_VISIBLE | BS_AUTOCHECKBOX, 100, 210, 70, 20,
			hWnd, 0, hInst, NULL);
		ShowWindow(cBtn3, SW_SHOWNORMAL);
		// Создаем и показываем кнопку
		hBtn = CreateWindow(TEXT("button"), TEXT("ОК"),
			WS_CHILD | WS_VISIBLE | WS_BORDER,
			100, 330, 80, 25, hWnd, 0, hInst, NULL);
		ShowWindow(hBtn, SW_SHOWNORMAL);
		hEdt1 = CreateWindow(TEXT("edit"), NULL,
			WS_CHILD | WS_VISIBLE | WS_BORDER,
			100, 30, 180, 30, hWnd, 0, hInst, NULL);
		ShowWindow(hEdt1, SW_SHOWNORMAL);
		lBox = CreateWindow(TEXT("listbox"), TEXT("ОК"),
			WS_CHILD | WS_VISIBLE | LBS_STANDARD | LBS_WANTKEYBOARDINPUT | LBS_SORT | WS_HSCROLL,
			100, 250, 220, 80, hWnd, (HMENU)lBox, hInst, NULL);
		ShowWindow(hBtn, SW_SHOWNORMAL);
		// Отменяется режим перерисовки списка
		SendMessage(lBox, WM_SETREDRAW, FALSE, 0L);
		// Добавляется в список несколько строк
		wsprintf(str, L"Зеленый", NULL);
		SendMessage(lBox, LB_ADDSTRING, 0, (LPARAM)(LPSTR)str);
		wsprintf(str, L"Красный", NULL);
		SendMessage(lBox, LB_ADDSTRING, 0, (LPARAM)(LPSTR)str);
		wsprintf(str, L"Розовый", NULL);
		SendMessage(lBox, LB_ADDSTRING, 0, (LPARAM)(LPSTR)str);
		wsprintf(str, L"Пурпурный", NULL);
		SendMessage(lBox, LB_ADDSTRING, 0, (LPARAM)(LPSTR)str);
		wsprintf(str, L"Синий", NULL);
		SendMessage(lBox, LB_ADDSTRING, 0, (LPARAM)(LPSTR)str);
		wsprintf(str, L"Желтый", NULL);
		SendMessage(lBox, LB_ADDSTRING, 0, (LPARAM)(LPSTR)str);
		wsprintf(str, L"Фиолетовый", NULL);
		SendMessage(lBox, LB_ADDSTRING, 0, (LPARAM)(LPSTR)str);
		wsprintf(str, L"Черный", NULL);
		SendMessage(lBox, LB_ADDSTRING, 0, (LPARAM)(LPSTR)str);
		wsprintf(str, L"Белый", NULL);
		SendMessage(lBox, LB_ADDSTRING, 0, (LPARAM)(LPSTR)str);
		// Включается режим перерисовки списка
		SendMessage(lBox, WM_SETREDRAW, TRUE, 0L);
		// Перерисовываемтся список
		InvalidateRect(lBox, NULL, TRUE);
		cBox = CreateWindow(TEXT("combobox"), NULL,
			WS_CHILD | WS_VISIBLE | WS_VSCROLL | CBS_DROPDOWNLIST | CBS_HASSTRINGS
        | CBS_AUTOHSCROLL, 100, 120, 120, 100, hWnd, (HMENU)cBox, hInst, NULL);
		//Запись строки в список
		wsprintf(str, L"До 18 лет", NULL);
		SendMessage(cBox, CB_ADDSTRING, 0, (LPARAM)str);
		wsprintf(str, L"От 18 до 25 лет", NULL);
		SendMessage(cBox, CB_ADDSTRING, 1, (LPARAM)str);
		wsprintf(str, L"От 25 до 40 лет", NULL);
		SendMessage(cBox, CB_ADDSTRING, 2, (LPARAM)str);
		wsprintf(str, L"От 40 до 60 лет", NULL);
		SendMessage(cBox, CB_ADDSTRING, 3, (LPARAM)str);
		wsprintf(str, L"От 60 лет", NULL);
		SendMessage(cBox, CB_ADDSTRING, 4, (LPARAM)str);
		SendMessage(cBox, CB_SETCURSEL, 0, 0L);
		ShowWindow(hBtn, SW_SHOWNORMAL);
		// Создаемтся и показываем поле текста для результата
		hStat = CreateWindow(TEXT("static"), TEXT("Анкета"), WS_CHILD | WS_VISIBLE,
			100, 10, 120, 20, hWnd, 0, hInst, NULL);
		ShowWindow(hStat, SW_SHOWNORMAL);
		break;
	case WM_COMMAND:  // сообщение о команде
		if (lParam == (LPARAM)hBtn){
			// если нажали на кнопку
			MessageBox(hWnd, TEXT("Анкета принята!"), TEXT("Событие"), 0);
		}
		break;
	case WM_PAINT: // перерисовка окна
		hdc = BeginPaint(hWnd, &ps); // начало перерисовки
		TextOut(hdc, 10, 30, TEXT("Ваше имя:"), 10); // вывод текстовых сообщений
		TextOut(hdc, 10, 70, TEXT("Ваш пол:"), 10);
		TextOut(hdc, 10, 120, TEXT("Возраст:"), 10); // вывод текстовых сообщений
		TextOut(hdc, 10, 150, TEXT("На каком языке программируете?"), 30);
		TextOut(hdc, 10, 230, TEXT("Выберите любимый цвет:"), 23);
		EndPaint(hWnd, &ps); // конец перерисовки
		break;
	case WM_DESTROY:
		PostQuitMessage(0);  // реакция на сообщение
		break;
	default: 	// все сообщения, не обработанные вами, обработает сама Windows
		return DefWindowProc(hWnd, message, wParam, lParam);
	}
	return 0;
}</code></pre>
    <h3 id="9.2">9.2 Microsoft Foundation Classes (MFC)</h3>
    <h3 id="9.2.1">9.2.1 Основы MFC. Иерархия классов</h3>
    <p>MFC &#8211; это библиотека классов, написанных на языке C++. MFC является оболочкой для Win32 API и содержит
        многоуровневую
        иерархию классов. Не все функции Win32 API включены в MFC. Эта библиотека классов охватывает большую часть
        функциональных возможностей Windows и предоставляет разработчику ряд механизмов для проектирования и создания
        программных продуктов.</p>
    <p>На вершине иерархии MFC находится единственный базовый класс &#8211; CObject. Все остальные классы библиотеки MFC
        можно
        условно разбить на две группы: производные и не производные от него. Чаще всего создание нового MFC-приложения
        поручается мастеру MFC Application Wizard. Мастер генерирует основной скелет приложения, который впоследствии
        заполняется нужным кодом, предоставляя готовое приложение <a href="source.html#metka21">[21]</a>.</p>
    <p>Некоторые классы MFC порождаются непосредственно от CObject. Наиболее широко используемыми среди них являются
        CCmdTarget, CFile, CDC, CGDIObject и CMenu. Класс CCmdTarget предназначен для обработки сообщений. Класс CFile
        предназначен для работы с файлами. Класс CDC обеспечивает поддержку контекстов устройств. В этот класс включены
        практически все функции графики GDI. CGDIObject является базовым классом для различных GDI-объектов, таких как
        перья, кисти, шрифты и другие. Класс СMenu предназначен для работы меню.</p>
    <p>Класс CCmdTarget. От класса CCmdTarget порождается очень важный класс CWnd. Он является базовым для создания всех
        типов окон, включая масштабируемые («обычные») и диалоговые, а также различные элементы управления. Наиболее
        широко
        используемым производным классом является CFrameWnd. В большинстве программ главное окно создается с помощью
        именно
        этого класса. От класса CCmdTarget через класс CWinThread порождается единственный из наиболее важных классов,
        обращение к которому в MFC-программах происходит напрямую, &#8211; это класс CWinApp. Это один из
        фундаментальных классов,
        поскольку предназначен для создания самого приложения. В каждой программе имеется один и только один объект
        этого
        класса. Как только он будет создан, приложение начнет выполняться.</p>
    <p>Класс CWinApp. Класс CWinApp является базовым классом, на основе которого образуют обязательный объект &#8211;
        приложение
        Windows. Основными задачами объекта этого класса являются инициализация и создание главного окна, а затем опрос
        системных сообщений. Иерархия класса CWinApp: CObject -> CCmdTarget -> CWinThread -> CWinApp.</p>
    <p>Класс CWnd. Класс CFrameWnd («окна-рамки») и производные от него классы определяют окна-рамки на мониторе.
        Элементы
        управления, создаваемые при проектировании интерфейса пользователя, принадлежат семейству классов элементов
        управления. Появляющиеся в процессе работы приложения <a href="glossary.html#m5">диалоговые окна</a> &#8211; это объекты классов, производных
        от CDialog.
        Классы CView, CFrameWnd, CDialog и все классы элементов управления наследуют свойства и поведение своего
        базового
        класса CWnd («окно»), определяющего Windows-окно. Этот класс является наследником базового класса CObject
        («объект»). Структура приложения определяется архитектурой Document-View (документ-вид). Это означает, что
        приложение состоит из одного или нескольких документов &#8211; объектов, классы которых являются производными от
        класса
        CDocument (класс «документ»). С каждым из документов связаны один или несколько видов &#8211; объектов классов,
        производных от CView (класс «вид») и определяющих методы обработки объектов класса документа <a href="source.html#metka21">[21]</a>.</p>
    <p>В MFC допускается непосредственное обращение к элементам управления, но на практике это происходит очень редко.
        Удобнее пользоваться соответствующими классами. Наиболее часто элементы управления используются с диалоговыми
        окнами, хотя можно создавать и отдельные элементы, расположенные в главном окне.</p>
    <p>В MFC содержатся классы для всех стандартных элементов управления. Эти классы описывают сами элементы и содержат
        функции для работы с ними &#8211; классы управления, они порождаются от класса CWnd. Все они обладают
        характеристиками
        окна. Ниже приведены основные классы управления (таблица 9.7).</p>
    <p>Таблица 9.7 &#8211; Классы MFC для элементов управления</p>
    <p class="tables"><img src="./img/9_chapter/table9.7.png" alt=""></p>
    <p>Диалоги как ресурсы. Диалоги не создаются программно. При необходимости из ресурсов загружаются описания
        диалогов, и
        Windows по этому описанию формирует окно и размещает на нем все элементы управления. Диалоги редактируются
        визуально
        из ресурсного редактора. Диалог вместе со всеми элементами управления представляет собой один ресурс со своим
        идентификатором. Кроме того, каждый элемент управления имеет свой идентификатор, который может быть только
        числовым.
        Обычно идентификаторы имеют префикс в соответствии с названием данного элемента управления, хотя при желании
        можно
        использовать любые идентификаторы <a href="source.html#metka20">[21]</a>.</p>
    <p>Класс CDialog. В MFC все диалоги являются экземплярами либо класса CDialog, либо порожденных от него классов.
        Лишь
        самые простые диалоги используют непосредственно класс CDialog. В общем же случае необходимо определять
        собственный
        класс. Класс CDialog имеет конструкторы со следующими прототипами.</p>
    <p>Обработка сообщений от диалогов. Все диалоги являются разновидностью окон, поэтому для них используется такой же
        механизм сообщений, как и для главного окна. Для каждого диалога организуется собственная очередь сообщений так
        же
        точно, как и для главного окна. Когда элемент управления диалога активизируется, диалогу посылается сообщение
        WM_COMMAND. С этим сообщением передается идентификатор элемента управления. Для обработки сообщений в карту
        сообщений диалога нужно поместить макрос ON_COMMAND(). Многие элементы управления генерируют также
        идентификационный
        код, который позволяет определить, какое действие было произведено с элементом управления. Во многих случаях по
        этому коду выбирается тот или иной обработчик.</p>
    <h3 id="9.2.2">9.2.2 Создание приложения MFC</h3>
    <h3 id="9.2.2.1">9.2.2.1 Возможности инструментальной среды MS Visual Studio для создания оконных приложений</h3>
    <p>Для инициализации создания проекта MFC в MS Visual Studio в стартовом окне нужно нажать кнопку «Создать
        проект».</p>
    <p class="photo"><img src="./img/9_chapter/9.28.png" alt=""></p>
    <p class="signature">Рисунок 9.28 &#8211; Создание проекта</p>
    <p>В левом столбце необходимо найти проект MFC, следуя по последовательности вкладок: «Установленные» -> «Шаблоны»
        ->
        «Visual C++» -> «MFC». Следует выбрать «Приложение MFC», ввести имя проекта и нажать «ОК».</p>
    <p class="photo"><img src="./img/9_chapter/9.29.png" alt=""></p>
    <p class="signature">Рисунок 9.29 &#8211; Создание проекта MFC</p>
    <p>В случае, если MFC не установлена на устройстве, будет выведено следующее окно и предложено установить
        данную
        библиотеку.</p>
    <p class="photo"><img src="./img/9_chapter/9.30.png" alt=""></p>
    <p class="signature">Рисунок 9.30 &#8211; Установка библиотеки</p>
    <p>Открывается окно «Мастер Приложений MFC». Он включает в себя множество различных функций и условий, которые могут
        быть изменены пользователем по его усмотрению. Однако в рамках процесса обучения рекомендуется выставлять
        значения,
        приведенные ниже.</p>
    <p class="photo"><img src="./img/9_chapter/9.31.png" alt=""></p>
    <p class="signature">Рисунок 9.31 &#8211; Мастер приложений MFC</p>
    <p class="photo"><img src="./img/9_chapter/9.32.png" alt=""></p>
    <p class="signature">Рисунок 9.32 &#8211; Создание проекта</p>
    <p>Тип приложения: на основе диалоговых окон, Использование MFC: в статической библиотеке. Убирается галочка с
        «Проверки
        жизненного цикла», «далее».</p>
    <p class="photo"><img src="./img/9_chapter/9.33.png" alt=""></p>
    <p class="signature">Рисунок 9.33 &#8211; Свойства пользовательского интерфейса</p>
    <p>Ставятся галочки «Кнопка свертывания» и «Кнопка развертывания», нажимается «Далее».</p>
    <p class="photo"><img src="./img/9_chapter/9.34.png" alt=""></p>
    <p class="signature">Рисунок 9.34 &#8211; Дополнительные параметры</p>
    <p>Ничего не меняется. Требуется нажать «Далее», затем «Готово».</p>
    <p class="photo"><img src="./img/9_chapter/9.35.png" alt=""></p>
    <p class="signature">Рисунок 9.35 &#8211; Результат создания проекта</p>
    <p class="photo"><img src="./img/9_chapter/9.36.png" alt=""></p>
    <p class="signature">Рисунок 9.36 &#8211; Главное окно проекта</p>
    <p>После создания проекта перед пользователем открывается рабочая область. Помимо знакомых элементов интерфейса,
        добавляются несколько новых. Справа располагается «Панель элементов», на основе которых проектируется интерфейс
        программы и панель «Свойства», характеризующая эти элементы. В отличие от консольного приложения, в центре
        рабочей
        области располагается не поле для ввода кода, а основная форма (макет) интерфейса, на которую и будут помещаться
        его элементы.</p>
    <p>Для более детальной работы во вкладке «Формат» необходимо перейти в «Направляющие» и в появившемся окне выбрать
        значение «Сетка».</p>
    <p class="photo"><img src="./img/9_chapter/9.37.png" alt=""></p>
    <p class="signature">Рисунок 9.37 &#8211; Настройка сетки</p>
    <p class="photo"><img src="./img/9_chapter/9.38.png" alt=""></p>
    <p class="signature">Рисунок 9.38 &#8211; Настройка сетки, задание параметров</p>
    <p class="photo"><img src="./img/9_chapter/9.39.png" alt=""></p>
    <p class="signature">Рисунок 9.39 &#8211; Результат настройки сетки</p>
    <p>При запуске приложения будет получена на выходе пустая форма будущего проекта.</p>
    <p class="photo"><img src="./img/9_chapter/9.40.png" alt=""></p>
    <p class="signature">Рисунок 9.40 &#8211; Пустая форма будущего проекта</p>
    <h3 id="9.2.2.2">9.2.2.2 Этапы создания MFC приложения</h3>
    <p>На панели элементов находим элемент «Static Text» и переносим его на основную форму. Данный элемент чаще всего
        используется для вывода какой-либо символьной информации. Конечное взаимодействие пользователя с ним
        минимально.</p>
    <p class="photo"><img src="./img/9_chapter/9.41.png" alt=""></p>
    <p class="signature">Рисунок 9.41 &#8211; Добавление текстового поля</p>
    <p class="photo"><img src="./img/9_chapter/9.42.png" alt=""></p>
    <p class="signature">Рисунок 9.42 &#8211; Редактирование текстового поля</p>
    <p>Следующий необходимый элемент на панели &#8211; это «Edit Control». Данный элемент используется пользователем для
        ввода
        данных различного вида, но также может быть использован для вывода информации.</p>
    <p>Все элементы изначально имеют стандартное наименование, которое может быть изменено во вкладке «Свойства».
        Перейти
        туда можно путем нажатия правой кнопки мыши на необходимом элементе и выбором соответствующего пункта
        всплывающего
        меню либо же переходом на вкладку «Свойства» в левом нижнем углу экрана.</p>
    <p class="photo"><img src="./img/9_chapter/9.43.png" alt=""></p>
    <p class="signature">Рисунок 9.43 &#8211; Свойства текстового поля</p>
    <p class="photo"><img src="./img/9_chapter/9.44.png" alt=""></p>
    <p class="signature">Рисунок 9.44 &#8211; Изменение свойства текстового поля</p>
    <p>За изменение текста на элементе отвечает параметр «Подпись». Данный параметр может принимать любое значение по
        желанию пользователя.</p>
    <p>Чтобы реализовать данную программу, следует добавить еще несколько элементов, а также поменять их подписи в
        соответствии с их предназначением. Для вывода результата вычисления использовалось текстовое поле «Static Text»
        со
        знаком «!».</p>
    <p class="photo"><img src="./img/9_chapter/9.45.png" alt=""></p>
    <p class="signature">Рисунок 9.45 &#8211; Изменение свойства текстового поля</p>
    <p>Для того чтобы взаимодействовать с элементами как с переменными, их нужно инициализировать в качестве
        переменных.
        Для этого в пустой области формы нажимаем правую кнопку мыши и выбираем пункт «Добавить переменную», после
        открытия
        мастера добавления переменной-члена задаем необходимые для конкретного элемента параметры: тип будущей
        переменной,
        категория, имя и др.</p>
    <p class="photo"><img src="./img/9_chapter/9.46.png" alt=""></p>
    <p class="signature">Рисунок 9.46 &#8211; Добавление переменной</p>
    <p class="photo"><img src="./img/9_chapter/9.47.png" alt=""></p>
    <p class="signature">Рисунок 9.47 &#8211; Мастер добавления переменной</p>
    <p>Для проведения расчетов нужен элемент, при активации которого будут произведены вычисления. Самым
        распространенным
        является <a href="glossary.html#m7">кнопка</a>, которая на панели имеет имя «Button».</p>
    <p class="photo"><img src="./img/9_chapter/9.48.png" alt=""></p>
    <p class="signature">Рисунок 9.48 &#8211; Настройка мастера добавления переменной</p>
    <p>При двойном нажатии создается класс, отвечающий за процесс, происходящий после нажатия кнопки при работе
        программы.
        Разработчик переносит в меню написания кода внутрь класса. В самом верху вписывается библиотека math для
        выполнения
        математических операций.</p>
    <p class="photo"><img src="./img/9_chapter/9.49.png" alt=""></p>
    <p class="signature">Рисунок 9.49 &#8211; Обработчик события</p>
    <p class="photo"><img src="./img/9_chapter/9.50.png" alt=""></p>
    <p class="signature">Рисунок 9.50 &#8211; Задание классов</p>
    <p>Внутри класса записывается основной код программы.</p>
    <p class="photo"><img src="./img/9_chapter/9.51.png" alt=""></p>
    <p class="signature">Рисунок 9.51 &#8211; Запись кода программы</p>
    <p>В результате выполнения программного кода получается следующее:</p>
    <p class="photo"><img src="./img/9_chapter/9.52.png" alt=""></p>
    <p class="signature">Рисунок 9.52 &#8211; Работа программы</p>
    <p class="photo"><img src="./img/9_chapter/9.53.png" alt=""></p>
    <p class="signature">Рисунок 9.53 &#8211; Результат работы программы</p>
    <h3 id="9.2.2.3">9.2.2.3 Пример создания MFC приложения</h3>
    <p>Далее представлен пример программы с использованием графического интерфейса пользователя для вычисления значения
        функции. При реализации программы предусмотреть ввод данных пользователя средствами диалогового окна, а также
        вывод
        результатов вычислений на форму.</p>
    <p class="formula"><img src="./img/9_chapter/(9.1).png" alt="">(9.1)</p>
    <p>Код для реализации программы:</p>
    <pre class="cpp-code"><code class="language-cpp">#include "framework.h"
#include "kaba1x.h"
#include "kaba1xDlg.h"
#include "afxdialogex.h"
#include "afxwin.h"
#ifdef _DEBUG
#define new DEBUG_NEW
#endif
// Диалоговое окно CAboutDlg используется для описания сведений о приложении
class CAboutDlg : public CDialogEx{
public:
	CAboutDlg();
	// Данные диалогового окна
#ifdef AFX_DESIGN_TIME
	enum { IDD = IDD_ABOUTBOX };
#endif
protected:
	virtual void DoDataExchange(CDataExchange* pDX); // поддержка DDX/DDV
// Реализация
protected:
	DECLARE_MESSAGE_MAP()
};
CAboutDlg::CAboutDlg() : CDialogEx(IDD_ABOUTBOX){}
void CAboutDlg::DoDataExchange(CDataExchange* pDX){
	CDialogEx::DoDataExchange(pDX);
}
BEGIN_MESSAGE_MAP(CAboutDlg, CDialogEx)
END_MESSAGE_MAP()
// Диалоговое окно Ckaba1xDlg
Ckaba1xDlg::Ckaba1xDlg(CWnd* pParent /*=nullptr*/){
	: CDialogEx(IDD_KABA1X_DIALOG, pParent)
	, hislo(0)
	, granica(0){
	m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);
}
void Ckaba1xDlg::DoDataExchange(CDataExchange* pDX){
	CDialogEx::DoDataExchange(pDX);
	DDX_Text(pDX, IDC_EDIT1, hislo);
	DDX_Text(pDX, IDC_EDIT2, granica);
}
BEGIN_MESSAGE_MAP(Ckaba1xDlg, CDialogEx)
	ON_WM_SYSCOMMAND()
	ON_WM_PAINT()
	ON_WM_QUERYDRAGICON()
	ON_EN_CHANGE(IDC_EDIT1, &Ckaba1xDlg::OnEnChangeEdit1)
	ON_BN_CLICKED(IDC_BUTTON1, &Ckaba1xDlg::OnBnClickedButton1)
	ON_BN_CLICKED(IDOK, &Ckaba1xDlg::OnBnClickedOk)
	ON_EN_CHANGE(IDC_EDIT2, &Ckaba1xDlg::OnEnChangeEdit2)
END_MESSAGE_MAP()
// Обработчики сообщений Ckaba1xDlg
BOOL Ckaba1xDlg::OnInitDialog() {
	CDialogEx::OnInitDialog();
	// Добавление пункта "О программе..." в системное меню.
	// IDM_ABOUTBOX должен быть в пределах системной команды.
	ASSERT((IDM_ABOUTBOX & 0xFFF0) == IDM_ABOUTBOX);
	ASSERT(IDM_ABOUTBOX < 0xF000);
	CMenu* pSysMenu = GetSystemMenu(FALSE);
	if (pSysMenu != nullptr) {
		BOOL bNameValid;
		CString strAboutMenu;
		bNameValid = strAboutMenu.LoadString(IDS_ABOUTBOX);
		ASSERT(bNameValid);
		if (!strAboutMenu.IsEmpty()) {
			pSysMenu->AppendMenu(MF_SEPARATOR);
			pSysMenu->AppendMenu(MF_STRING, IDM_ABOUTBOX, strAboutMenu);
		}
	}
	// Задает значок для этого диалогового окна.  Среда делает это автоматически,
	//  если главное окно приложения не является диалоговым
	SetIcon(m_hIcon, true);			// Крупный значок
	SetIcon(m_hIcon, false);		// Мелкий значок
	// TODO: добавьте дополнительную инициализацию
	return true;  // возврат значения TRUE, если фокус не передан элементу управления
}
void Ckaba1xDlg::OnSysCommand(UINT nID, LPARAM lParam){
	if ((nID & 0xFFF0) == IDM_ABOUTBOX){
		CAboutDlg dlgAbout;
		dlgAbout.DoModal();
	}
	else{
		CDialogEx::OnSysCommand(nID, lParam);
	}
}
// При добавлении кнопки свертывания в диалоговое окно нужно воспользоваться приведенным ниже кодом,
// чтобы нарисовать значок. Для приложений MFC, использующих модель документов или представлений,
// это автоматически выполняется рабочей областью.
void Ckaba1xDlg::OnPaint(){
	if (IsIconic()){
		CPaintDC dc(this); // контекст устройства для рисования
		SendMessage(WM_ICONERASEBKGND, reinterpret_cast&ltWPARAM>(dc.GetSafeHdc()), 0);
		// Выравнивание значка по центру клиентского прямоугольника
		int cxIcon = GetSystemMetrics(SM_CXICON);
		int cyIcon = GetSystemMetrics(SM_CYICON);
		CRect rect;
		GetClientRect(&rect);
		int x = (rect.Width() - cxIcon + 1) / 2;
		int y = (rect.Height() - cyIcon + 1) / 2;
		// Нарисуйте значок
		dc.DrawIcon(x, y, m_hIcon);
	}
	else{
		CDialogEx::OnPaint();
	}
}
// Система вызывает эту функцию для получения отображения курсора при перемещении
// свернутого окна.
HCURSOR Ckaba1xDlg::OnQueryDragIcon(){
	return static_cast&ltHCURSOR>(m_hIcon);
}</code></pre>
    <p>Результат выполнения данного программного кода представлен на рисунках 9.54 и 9.55.</p>
    <p class="photo"><img src="./img/9_chapter/9.54.png" alt=""></p>
    <p class="signature">Рисунок 9.54 &#8211; Результат работы программы. Ввод данных</p>
    <p class="photo"><img src="./img/9_chapter/9.55.png" alt=""></p>
    <p class="signature">Рисунок 9.55 &#8211; Результат работы программы. Результат работы программы</p>
    <h3 id="9.3">9.3 Контрольные вопросы для закрепления изученного материала</h3>
    <ol>
        <li class="with-a-bracket">Основные понятия и термины, используемые при разработке Windows-приложений.</li>
        <li class="with-a-bracket">Создание простейших Windows-приложений с использованием Microsoft Foundation Classes
            (MFC)
        </li>
        <li class="with-a-bracket">Создание оконного приложения. Настройка сетки.</li>
        <li class="with-a-bracket">Создание оконного приложения. Добавление переменной.</li>
        <li class="with-a-bracket">Создание оконного приложения. Обработка событий.</li>
    </ol>
</script>

<script id="page9.4" type="text/html">
    <TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0>
        <TR>
            <TD width="50%"><a name="3"></a>
                <HR>
                <div align=justify><h1>Тренировочные упражнения</h1></div>
  <form name="f1">
   <ol> 
    <li class="without-parentheses"> Выберите один правильный вариант ответа. Какой код cоответсвует данному диалоговому окну указанному на рисунке?
    	 <p class="photo"><img src="./img/10_chapter/10.11.png" alt=""></p>
    
    	 <label><p><img src="./img/10_chapter/10.6.png" alt=""></p><input type="checkbox" value="object" name="vop3" id="one"></label><br>
    	 <label><p><img src="./img/10_chapter/10.7.png" alt=""></p><input type="checkbox" value="o" name="vop4" id="two"></label><br>
    	 <label><p><img src="./img/10_chapter/10.10.png" alt=""></p><input type="checkbox" value="object" name="vop5" id="tree"></label><br>
    	 <label><p><img src="./img/10_chapter/10.9.png" alt=""></p><input type="checkbox" value="object" name="vop6" id="four"></label><br>
    	 <input type="button" class="fun1"  value="Проверить">
                  <input id ="output" type="reset" value="Сброс">
                  <br><br>
 		<div id="resultaat"></div>
                  </form>
              </li><br><br>
   <form>           
<li class="without-parentheses"> Напишите с заглавной буквы следущее определние термина </li>
	<p><input type="text" id="glav9_2" size="4"> функция – это функция обратного вызова, предназначенная для обработки сообщений, адресованных окну того оконного класса, в котором содержится ссылка на данную процедуру </p>	
	<br>
 <input type="button" value="Ответить" class="proverit_glav_9_2"></input>
              <input type="reset" value ="Очистить"></input>
              <br><br>
                 <div id="resultat_9"></div>
                  </form>
</li><br><br>


</script> 

<script id="page9.5" type="text/html">
    <TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0>
        <TR>
            <TD width="50%"><a name="3"></a>
                <HR>
                <div align=justify><h1 align="center">Тестирование по девятой главе</h1></div>
                <form name=test>
                    <ol>
                        <li>
                            <h4><input type=text name=T1 style="height: 15px; width:15px;" value=''> Свойство Height
                                визуальных компонентов задает:</h4>
                            <input type=radio name=Q1> ширину компонента;<br>
                            <input type=radio name=Q1> высоту компонента;<br>
                            <input type=radio name=Q1> цвет компонента;<br>
                            <input type=radio name=Q1> расположение относительно оси X;<br>
                            <input type=radio name=Q1> расположение относительно оси Y.<br>
                            <br>
                        </li>
                        <li>
                            <h4><input type=text name=T2 style="height: 15px; width:15px;" value=''> Обработчик события
                                OnClick задает:</h4>
                            <input type=radio name=Q2> функцию, вызываемую при одном щелчке мышью на компоненте;<br>
                            <input type=radio name=Q2> функцию, вызываемую при двойном щелчке мышью на компоненте;<br>
                            <input type=radio name=Q2> функцию, вызываемую при одном нажатии клавиши на клавиатуре;<br>
                            <input type=radio name=Q2> функцию, вызываемую при двойном нажатии клавиши на
                            клавиатуре;<br>
                            <input type=radio name=Q2> ничего из вышеперечисленного.<br>
                            <br>
                        </li>
                        <li>
                            <h4><input type=text name=T3 style="height: 15px; width:15px;" value=''> Обработчик события
                                OnDblClick задает:</h4>
                            <input type=radio name=Q3> функцию, вызываемую при одном щелчке мышью на компоненте;<br>
                            <input type=radio name=Q3> функцию, вызываемую при двойном щелчке мышью на компоненте;<br>
                            <input type=radio name=Q3> функцию, вызываемую при одном нажатии клавиши на клавиатуре;<br>
                            <input type=radio name=Q3> функцию, вызываемую при двойном нажатии клавиши на
                            клавиатуре;<br>
                            <input type=radio name=Q3> ничего из вышеперечисленного.<br>
                            <br>
                        </li>
                        <li>
                            <h4><input type=text name=T4 style="height: 15px; width:15px;" value=''> Функция, вызываемая
                                при нажатии клавиши на клавиатуре, задается в обработчике события:</h4>
                            <input type=radio name=Q4> OnKeyDown;<br>
                            <input type=radio name=Q4> OnKeyUp;<br>
                            <input type=radio name=Q4> OnClick;<br>
                            <input type=radio name=Q4> KeyUp;<br>
                            <input type=radio name=Q4> MouseClick.<br>
                            <br>
                        </li>
                        <li>
                            <h4><input type=text name=T5 style="height: 15px; width:15px;" value=''> Функция, вызываемая
                                при отпускании клавиши на клавиатуре, задается в обработчике события:</h4>
                            <input type=radio name=Q5> OnKeyDown;<br>
                            <input type=radio name=Q5> OnKeyUp;<br>
                            <input type=radio name=Q5> OnClick;<br>
                            <input type=radio name=Q5> KeyUp;<br>
                            <input type=radio name=Q5> MouseClick.<br>
                            <br>
                        </li>
                        <li>
                            <h4><input type=text name=T6 style="height: 15px; width:15px;" value=''> Свойство Top
                                визуальных компонентов задает:</h4>
                            <input type=radio name=Q6> ширину компонента;<br>
                            <input type=radio name=Q6> высоту компонента;<br>
                            <input type=radio name=Q6> цвет компонента;<br>
                            <input type=radio name=Q6> расположение относительно оси X;<br>
                            <input type=radio name=Q6> расположение относительно оси Y.<br>
                            <br>
                        </li>
                        <li>
                            <h4><input type=text name=T7 style="height: 15px; width:15px;" value=''> Свойство Left
                                визуальных компонентов задает:</h4>
                            <input type=radio name=Q7> ширину компонента;<br>
                            <input type=radio name=Q7> высоту компонента;<br>
                            <input type=radio name=Q7> цвет компонента;<br>
                            <input type=radio name=Q7> расположение относительно оси X;<br>
                            <input type=radio name=Q7> расположение относительно оси Y.<br>
                            <br>
                        </li>
                        <li>
                            <h4><input type=text name=T8 style="height: 15px; width:15px;" value=''> Свойство Width
                                визуальных компонентов измеряется в:</h4>
                            <input type=radio name=Q8> пикселях;<br>
                            <input type=radio name=Q8> сантиметрах;<br>
                            <input type=radio name=Q8> метрах;<br>
                            <input type=radio name=Q8> точках;<br>
                            <input type=radio name=Q8> пунктах.<br>
                            <br>
                        </li>
                        <li>
                            <h4><input type=text name=T9 style="height: 15px; width:15px;" value=''> Библиотека C++ для
                                визуального программирования называется:</h4>
                            <input type=radio name=Q9> MLM;<br>
                            <input type=radio name=Q9> MVC;<br>
                            <input type=radio name=Q9> MFC;<br>
                            <input type=radio name=Q9> .NET;<br>
                            <input type=radio name=Q9> JSF.<br>
                            <br>
                        </li>
                        <li>
                            <h4><input type=text name=T10 style="height: 15px; width:15px;" value=''> Если в программе
                                имеется три окна, то она может содержать:</h4>
                            <input type=radio name=Q10> один поток команд;<br>
                            <input type=radio name=Q10> два потока команд;<br>
                            <input type=radio name=Q10> пять потоков команд;<br>
                            <input type=radio name=Q10> три потока команд;<br>
                            <input type=radio name=Q10> четыре потока команд.<br>
                            <br>
                        </li>
                    </ol>
                    <div align="center">
                        <div>
                            <input type=button value="Показать результат" onClick="test1('MjEyMTI1NDEzMg', 10)">
                        </div>
                        <div>
                            <textarea style="margin-top:6px" rows=5 cols="100%" name=s1></textarea>
                        </div>
                        <div>
                            <input type=reset value="Очистить выбранные пункты">
                        </div>
                        <br>
                        <Div align=center>
                            <a href="#3">В начало страницы</a>
                        </div>
                        <br>
                    </div>
                </form>
            </TD>
        </TR>
    </TABLE>
</script>

<!-- /page10 -->
<script id="page10" type="text/html">
    <h2 id="10">10 Введение в объектно-ориентированное программирование</h2>
    <h3 id="10.1">10.1 Основы объектно-ориентированного подхода</h3>
    <!-- начало главы 10.1 -->
    <p> Объектно-ориентированное программирование - расширение структурного программирования, в котором основными концепциями являются понятия классов и объектов. Основное отличие языка программирования С++ от С состоит в том, что в С нет классов, а следовательно язык С не поддерживает ООП, в отличие от С++.</p>
    <p>В традиционном программировании, программа - это набор инструкций для компьютера, которые определяют данные (через объекты), а затем работают с этими данными (через операторы и функции)  <a href="source.html#metka25">[25]</a>. Объекты и функции, которые работают с этими данными, являются отдельными единицами, которые объединяются для получения программистом желаемого результата. Из-за того, что они являются отдельными единицами, традиционное программирование часто не позволяет использовать интуитивное представление реальности. Это является делом программиста - управлять и соединять свойства (переменные) с поведением (функциями) соответствующим образом, что приводит к созданию следующего кода:</p>
    <b>driveTo(you, work);</b>
    <p> Для лучшего понимания перехода на объектно-ориентированный подход следует понять, что объекты находятся везде: книги, здания, еда и даже люди сами. Объекты имеют два основных компонента:<br>-   свойства (например, вес, цвет, размер, прочность, форма и т.д.);<br> -  поведение, которое они могут проявлять (например, открывать что-либо, делать что-то и т.д.).
    </p>
    <p>Свойства и поведение неотделимы друг от друга. <a href="glossary.html#m8">Объектно-ориентированное программирование (ООП)</a> предоставляет возможность создавать объекты, которые объединяют свойства и поведение в самостоятельный союз, который затем можно многоразово использовать. Описанный выше код можно представить следующим образом:</p>
    <b>you.driveTo(work);</b>
    <p>Так не только читабельнее, но и понятнее, кем является объект (you - вы) и какое поведение вызывается (driveTo - поездка). Вместо того, чтобы сосредоточиться на написании функций, мы концентрируемся на определении объектов, которые имеют четкий набор поведений. Вот почему эта парадигма называется «объектно-ориентированной»  <a href="source.html#metka25">[25]</a>.</p>
    <p>Это позволяет создавать программы модульным способом, что упрощает не только написание и понимание кода, но и обеспечивает более высокий уровень возможности повторного использования этого кода. Объекты также обеспечивают более интуитивный способ работы с данными, позволяя программисту определить, как он будет взаимодействовать с объектами, и как эти объекты будут взаимодействовать с другими объектами.</p>
    <p>Объектно-ориентированное программирование (ООП) - методология программирования, основанная на представлении программы в виде совокупности объектов, каждый из которых является экземпляром определённого класса, а классы образуют иерархию наследования.</p>

    <!-- 10.2 -->
    <h3 id="10.2">10.2 Определение классов</h3>
    <p>Классы и объекты в С++ являются основными концепциями объектно-ориентированного программирования. Классы в С++  это абстракция описывающая методы, свойства, ещё не существующих объектов.</p>
    <p>Объекты - конкретное представление абстракции, имеющее свои свойства и методы. Созданные объекты на основе одного класса называются экземплярами этого класса. Эти объекты могут иметь различное поведение, свойства, но все равно будут являться объектами одного класса. </p>
    <p>Чтобы понять, для чего же в действительности нужны классы, можно провести аналогию с каким-нибудь объектом из повседневной жизни, например,  с велосипедом. Велосипед - это объект, который был построен согласно чертежам. Так вот, эти самые чертежи играют роль классов в ООП. Таким образом, классы - это некоторые описания, схемы, чертежи по которым создаются объекты. Теперь ясно, что для создания объекта в ООП необходимо сначала составить чертежи, то есть классы. Классы имеют свои функции, которые называются методами класса. Передвижение велосипеда осуществляется за счёт вращения педалей, если рассматривать велосипед с точки зрения ООП, то механизм вращения педалей - это метод класса. Каждый велосипед имеет свой цвет, вес, различные составляющие - всё это свойства. Причём у каждого созданного объекта свойства могут различаться. </p>
    <p>Имея один класс, можно создать  неограниченно количество объектов, каждый из которых будет обладать одинаковым набором методов, при этом можно не задумываться о внутренней реализации механизма вращения педалей, колёс, срабатывания системы торможения, так как всё это уже будет определено в классе.</p>
    <p>В объектно-ориентированном программировании существует три основных принципа построения классов:<br>1) <a href="glossary.html#m6">Инкапсуляция</a>  - это свойство, позволяющее объединить в классе и данные, и методы, работающие с ними и скрыть детали реализации от пользователя.<br>
   2) Наследование - это свойство, позволяющее создать новый класс-потомок на основе уже существующего, при этом все характеристики класса родителя присваиваются классу-потомку.<br>3) <a href="glossary.html#m9">Полиморфизм</a> - свойство классов, позволяющее использовать объекты классов с одинаковым интерфейсом без информации о типе и внутренней структуре объекта. </p>
   <p>Каждое свойство построения классов будут рассмотрены далее. Для начала рассмотрим структуру объявления классов. Объявление класса в объектно-ориентированном программировании начинается с зарезервированного ключевого слова class, после которого пишется имя класса. Далее представлена структура объявления класса.</p>

   <pre class="cpp-code"><code class="language-cpp">
    // объявление классов в С++
    class /*имя класса*/
{
  private:
  /* список свойств и методов для использования внутри класса */
  public:
  /* список методов доступных другим функциям и объектам программы */
  protected:
  /*список средств, доступных при наследовании*/
};
   </code></pre>
   <p>При создании класса в фигурных скобочках объявляется тело класса, причём после закрывающейся скобочки обязательно нужно ставить точку с запятой. В теле класса объявляются три метки спецификации доступа, после каждой метки нужно обязательно ставить двоеточие. Объявлена метка спецификатора доступа private. Все методы и свойства класса, объявленные после спецификатор доступа private будут доступны только внутри класса.</p>
   <p>Далее объявлен спецификатор доступа public, все методы и свойства класса, объявленные после спецификатора доступа  public будут доступны другим функциям и объектам в программе.</p>
   <p>При объявлении класса, не обязательно объявлять три спецификатора доступа, и не обязательно их объявлять в таком порядке. Но лучше сразу определиться с порядком объявления спецификаторов доступа, и стараться его придерживаться  <a href="source.html#metka25">[25]</a>.</p>
   <p>Далее представлена программа, в которой объявлен простейший класс, в котором будет задана одна функция, печатающая сообщение.</p>
   <pre class="cpp-code"><code class="language-cpp">
    // classes.cpp: определяет точку входа для консольного приложения.
#include <iostream>
using namespace std;
// начало объявления класса
class CppStudio // имя класса
{
public: // спецификатор доступа
    void message() // функция (метод класса) выводящая сообщение на экран
    {
        cout << "website: cppstudio.com\ntheme: Classes and Objects in C + +\n";
    }
}; // конец объявления класса CppStudio
 int main(int argc, char* argv[])
{
    CppStudio objMessage; // объявление объекта
    objMessage.message(); // вызов функции класса message
    system("pause");
    return 0;
}
   </code></pre>
   <p>В данном примере был определен класс с именем CppStudio. Имя класса принято начинать с большой буквы, последующие слова в имени также должны начинаться с большой буквы. Такое сочетание букв называют верблюжьим регистром, так как чередование больших и маленьких букв напоминает силуэт верблюда. В теле класса объявлен спецификатор доступа public, который позволяет вызывать другим функциям <a href="glossary.html#m8">методы класса</a>, объявленные после public. Вот именно поэтому в главной функции вызвана функция message(). В классе CppStudio объявлена всего одна функция, которая не имеет параметров и выводит сообщение на экран. </p>
   <p>Далее объявлена переменная objMessage типа CppStudio, так вот, переменная objMessage - это объект класса CppStudio. Таким образом, класс является сложным типом данных. После того как объект класса объявлен, можно воспользоваться его методами. Метод всего один - функция message(). Для этого обращаемся к методу объекта objMessage через точку, как показано в строке 19, в результате программа выдаст текстовое сообщение (рисунок 10.1).</p>

    <p class="photo"><img src="./img/10_chapter/10.1.jpg" alt=""></p>
    <p class="signature">Рисунок 10.1 &#8211; Классы в C++</p>
    <p>Классы очень похожи на структуры в языке C++, за исключением того, что они обеспечивают гораздо большую мощность и гибкость. Далее приведен пример задания структуры и класса, которые будут идентичны по функционалу друг другу.</p>

    <pre class="cpp-code"><code class="language-cpp">
        struct DateStruct
{
    int day;
    int month;                    // Задана структура
    int year;
};
и
 class DateClass
{
public:
    int m_day;
    int m_month;                // Задан класс
    int m_year;
};

    </code></pre>

    <p>Единственным существенным отличием является использование ключевое слово в классе public. Так же, как и объявление структуры, объявление класса не приводит к выделению какой-либо памяти. </p>
    <p>В языке С++ для использования класса необходимо объявить переменную этого типа класса:</p><p><b>DateClass today {12, 11, 2018}; // инициализация переменной класса DateClass</b></p>
    <p>В этом случае переменная класса называется экземпляром (или «объектом») класса. Точно так же, как определение переменной фундаментального типа данных (например, int x) приводит к выделению памяти для этой переменной, так же и создание объекта класса (например, DateClass today) приводит к выделению памяти для этого объекта.</p>

    <!-- 10.3 -->
    <h3 id="10.3">10.3 Методы класса</h3>
    <p>Помимо хранения данных, классы могут содержать и функции. Функции, определенные внутри класса, называются методами. </p>
    <p>Методы класса - это те же функции, только объявлены они внутри класса, поэтому все, что относится к функциям актуально и для методов классов. Объявление классов выполняется аналогично объявлению функций, то есть класс можно объявлять в отдельном файле или в главном файле.</p>
    <p>Методы класса работают следующим образом: все вызовы методов должны быть связаны с объектом класса. Для работы с функциями, не являющимися членами класса, нужно передавать данные в эту функцию явно (в качестве параметров). А для работы с методами всегда есть неявный объект класса.</p>
    <p>Использование префикса m_ (англ. «m» = «members») для переменных-членов помогает различать переменные-члены от параметров функции или локальных переменных внутри методов класса. Это полезно по нескольким причинам:<br>-   во-первых, когда мы видим переменную с префиксом m_, то мы понимаем, что работаем с переменной-членом класса;<br> -  во-вторых, в отличие от параметров функции или локальных переменных, объявленных внутри функции, переменные-члены объявляются в определении класса. Следовательно, если мы хотим знать, как объявлена переменная с префиксом  m_, мы понимаем, что искать нужно в определении класса, а не внутри функции.</p>
    <p>Далее приведен еще один пример программы с использованием класса для вывода информации о работниках на экран с использованием метода void.</p>
    <pre class="cpp-code"><code class="language-cpp">
#include &ltiostream>
#include &ltstring>
using namespace std;
 class Employee
{
public:
    string m_name;
    int m_id;
    double m_wage;
     // Метод вывода информации о работнике на экран
    void print()
    {
        cout << "Name: " << m_name <<
                "\nId: " << m_id << 
                "\nWage: $" << m_wage << '\n'; 
    }
};
 int main()
{
    // Определяем двух работников
    Employee john { "John", 5, 30.00 };
    Employee max { "Max", 6, 32.75 };
     // Выводим информацию о работниках на экран
    john.print();
    cout << endl;
    max.print();
     return 0;
}

    </code></pre>

    <p class="photo"><img src="./img/10_chapter/10.2.jpg" alt=""></p>
    <p class="signature">Рисунок 10.2 &#8211; Вывод информации о работниках с помощью метода void</p>
    <p>Методы могут быть определены, как внутри, так и вне класса. Далее рассмотрен пример определения методов внутри класса. В данном случае приведен еще один пример работы с датой, создан класса Date с методом вывода для вывода даты.</p>

    <pre class="cpp-code"><code class="language-cpp">
    class DateClass
{
public:
    int m_day;
    int m_month;
    int m_year;
     void print() // определяется функция-член
    {
        cout << m_day << "/" << m_month << "/" << m_year;
    }
};

    </code></pre>
    <p>Точно так же, как к членам структуры, так и к класса доступ осуществляется через оператор выбора членов (.):</p>
    <pre class="cpp-code"><code class="language-cpp">
#include &ltiostream>
using namespace std;
 class DateClass
{
public:
    int m_day;
    int m_month;
    int m_year;
     void print()
    {
        cout << m_day << "/" << m_month << "/" << m_year;
    }
};
 int main()
{
    DateClass today {12, 11, 2018};
     today.m_day = 18; // используется оператор выбора членов для выбора переменной-члена m_day объекта today класса DateClass
    today.print(); // используется оператор выбора членов для вызова метода print() объекта today класса DateClass
     return 0;
}

    </code></pre>
    <p class="photo"><img src="./img/10_chapter/10.3.jpg" alt=""></p>
    <p class="signature">Рисунок 10.3 &#8211; Создание простого класса</p>

    <br><h3 id="10.4">1.4 Спецификаторы доступа public и private</h3>
    <p>Каждый объект имеет какие-то свои свойства или атрибуты, которые характеризуют его на протяжении всей жизни. Атрибуты объекта хранятся в переменных, объявленных внутри класса, которому принадлежит данный объект. Причём, объявление переменных должно выполняться со спецификатором доступа private. Такие переменные называются элементами данных. Так как элементы данных объявлены в private, то и доступ к ним могут получить только методы класса, внешний доступ к элементам данных запрещён. </p><p>Для понимания работы спецификаторов доступа далее рассмотрен следующий код.</p>

    <pre class="cpp-code"><code class="language-cpp">
struct DateStruct // члены структуры являются открытыми по умолчанию 
{
    int day; // открыто по умолчанию, доступ имеет любой объект  
    int month; // открыто по умолчанию, доступ имеет любой объект
    int year; // открыто по умолчанию, доступ имеет любой объект
};
 int main()
{
    DateStruct date;
    date.day = 12;
    date.month = 11;
    date.year = 2018;
     return 0;
}
    </code></pre>
    <p>Здесь объявляется структура DateStruct, а затем напрямую идет обращение к её членам для их инициализации. Это работает, так как все члены структуры являются открытыми по умолчанию. Открытые члены (или «public-члены») - это члены структуры или класса, к которым можно получить доступ извне этой же структуры или класса. В программе, приведенной выше, функция main() находится вне структуры, но она может напрямую обращаться к членам day, month и year, так как они являются открытыми.</p><p>С другой стороны, идет следующий почти идентичный класс:</p>
    <pre class="cpp-code"><code class="language-cpp">
    class DateClass // члены класса являются закрытыми по умолчанию
{
    int m_day; // закрыто по умолчанию, доступ имеют только другие члены класса
    int m_month; // закрыто по умолчанию, доступ имеют только другие члены класса
    int m_year; // закрыто по умолчанию, доступ имеют только другие члены класса
};
 int main()
{
    DateClass date;
    date.m_day = 12; // ошибка
    date.m_month = 11; // ошибка
    date.m_year = 2018; // ошибка
     return 0;
}
    </code></pre>
    <p>Здесь бы не удалось скомпилировать эту программу, так как все члены класса являются закрытыми по умолчанию. Закрытые члены (или «private-члены») - это члены класса, доступ к которым имеют только другие члены этого же класса. Поскольку функция main() не является членом DateClass, то она и не имеет доступа к закрытым членам объекта date.</p><p>Хотя члены класса являются закрытыми по умолчанию, можно сделать их открытыми, используя ключевое слово public.</p>

    <pre class="cpp-code"><code class="language-cpp">
  class DateClass
{
public: // следует обратить внимание на ключевое слово public и двоеточие
    int m_day; // открыто, доступ имеет любой объект 
    int m_month; // открыто, доступ имеет любой объект
    int m_year; // открыто, доступ имеет любой объект
};
 int main()
{
    DateClass date;
    date.m_day = 12; // ок, так как m_day имеет спецификатор доступа public
    date.m_month = 11; // ок, так как m_month имеет спецификатор доступа public
    date.m_year = 2018; // ок, так как m_year имеет спецификатор доступа public
     return 0;
}
    </code></pre>
    <p>Поскольку теперь члены класса DateClass являются открытыми, то к ним можно получить доступ напрямую из функции main().</p><p>Ключевое слово public вместе с двоеточием называется спецификатором доступа. Спецификатор доступа определяет, кто имеет доступ к членам этого спецификатора. Каждый из членов «приобретает» уровень доступа в соответствии со спецификатором доступа (или, если он не указан, в соответствии со спецификатором доступа по умолчанию).</p>
    <p>В языке C++ есть три уровня доступа:<br>- спецификатор public делает члены открытыми;<br>- спецификатор private делает члены закрытыми;<br>- спецификатор protected открывает доступ к членам только для дружественных и дочерних классов.</p>

    <br><h3 id="10.5">10.5 Функции доступа get и set</h3>
    <p>В зависимости от класса, может быть уместным (в контексте того, что делает класс) иметь возможность получать/устанавливать значения закрытым переменным-членам класса.</p>
    <p>Функция доступа - это короткая открытая функция, задачей которой является получение или изменение значения закрытой переменной-члена класса. Например, в ниже представленном коде getLength() является функцией доступа, которая просто возвращает значение m_length.</p>

    <pre class="cpp-code"><code class="language-cpp">
class MyString
{
private:
    char *m_string; // динамически выделяем строку
    int m_length; // используем переменную для отслеживания длины строки
 public:
    int getLength() { return m_length; } // функция доступа для получения значения m_length
};
    </code></pre>
    <p>Функции доступа обычно бывают двух типов:<br>1 get - это функции, которые возвращают значения закрытых переменных-членов класса;<br>2 set - это функции, которые позволяют присваивать значения закрытым переменным-членам класса.</p>
    <p>Далее представлен пример класса, который использует функции get и set для всех своих закрытых переменных-членов:</p>

    <pre class="cpp-code"><code class="language-cpp">
 class Date
{
private:
    int m_day;
    int m_month;
    int m_year;
 public:
    int getDay() { return m_day; } // геттер для day
    void setDay(int day) { m_day = day; } // сеттер для day
     int getMonth() { return m_month; } // геттер для month
    void setMonth(int month) { m_month = month; } // сеттер для month
     int getYear() { return m_year; } // геттер для year
    void setYear(int year) { m_year = year; } // сеттер для year
};
    </code></pre>
    <p>В этом классе нет никаких проблем с тем, чтобы пользователь мог напрямую получать или присваивать значения закрытым переменным-членам этого класса, так как есть полный набор геттеров и сеттеров. В примере с классом MyString для переменной m_length не было предоставлено сеттера, так как не было необходимости в том, чтобы пользователь мог напрямую устанавливать длину.</p>
    <p>Следует предоставлять функции доступа только в том случае, когда нужно, чтобы пользователь имел возможность получать или присваивать значения членам класса.</p>
    <p>Set-функции инициализируют элементы данных, get-функции позволяют просмотреть значения элементов данных. Далее представлен класс  CppStudio, в котором можно было хранить дату в формате дд.мм.гг. Для изменения и просмотра даты будут использоваться соответственно set и get функции.</p>

    <pre class="cpp-code"><code class="language-cpp">
        // classes.cpp: определяет точку входа для консольного приложения.
 #include "stdafx.h"
#include &ltiostream>
using namespace std;
class CppStudio // имя класса
{
private: // спецификатор доступа private
    int day, // день
    month, // месяц
    year; // год
public: // спецификатор доступа public
    void message() // функция (метод класса) выводящая сообщение на экран
    {
        cout << "\nwebsite: cppstudio.comntheme: Classes and Objects in C + +\n";
    }
    void setDate(int date_day, int date_month, int date_year) // установка даты в формате дд.мм.гг
    {
        day   = date_day; // инициализация день
        month = date_month; // инициализация месяц
        year  = date_year; // инициализация год
    }
    void getDate() // отобразить текущую дату
    {
        cout << "Date: " << day << "." << month << "." << year << endl;
    }
}; // конец объявления класса CppStudio
 int main(int argc, char* argv[])
{
    setlocale(LC_ALL, "rus"); // установка локали
    int day, month, year;
    cout << "Введите текущий день месяц и год!\n";
    cout << "день: ";     cin >> day;
    cout << "месяц: ";    cin >> month;
    cout << "год: ";  cin >> year;
    CppStudio objCppstudio; // объявление объекта
    objCppstudio.message(); // вызов функции класса message
    objCppstudio.setDate(day, month, year); // инициализация даты
    objCppstudio.getDate(); // отобразить дату
    system("pause");
    return 0;
}
    </code></pre> <p>Результат работы программы представлен на рисунке 10.4.</p>

    <p class="photo"><img src="./img/10_chapter/10.4.jpg" alt=""></p>
    <p class="signature">Рисунок 10.4 &#8211; Использование функций get и set</p>

    <p>В данном примере в определении класса использовался спецификатор доступа private. Данный спецификатор доступа ограничивает доступ к переменным, которые объявлены после него и до начала спецификатора доступа public. Таким образом, к переменным day, month, year, могут получить доступ только методы класса. Функции, не принадлежащие классу, не могут обращаться к этим переменным. Элементы данных или методы класса, объявленные после спецификатора доступа private, но до начала следующего спецификатора доступа называются закрытыми элементами данных и закрытыми методами класса. Следуя принципу наименьших привилегий и принципу хорошего программирования, целесообразно объявлять элементы данных после спецификатора доступа private, а методы класса - после спецификатора доступа public. Тогда, для манипулирования элементами данных, объявляются специальные функции - get и set. </p>
    <p>В класс CppStudio были добавлены два метода setDate() и getDate(), подробно рассмотрим каждый метод. Затем определен метод setDate(). Как уже ранее упоминалось, set - функции инициализируют элементы данных, поэтому метод setDate() выполняет именно такую функцию. То есть метод setDate() инициализирует переменные day, month, year. Чтобы просмотреть,  значения в закрытых элементах данных объявлена функция  getDate(), которая возвращает значения из переменных day, month, year в виде даты. На этом определение класса закончено. В main(), как и всегда, созданы объекты класса, и через объект вызваны его методы.  Если бы элементы данных были объявлены после спецификатора public, то можно было бы к ним обратиться точно также, как и к методам класса. </p>

    <br><h3 id="10.6">10.6 Конструкторы</h3>
    <p>Когда все члены класса (или структуры) являются открытыми, то можно инициализировать класс (или структуру) напрямую, используя список инициализаторов или uniform-инициализацию.</p>

    <pre class="cpp-code"><code class="language-cpp">
class Boo
{
public:
    int m_a;
    int m_b;
};
int main()
{
    Boo boo1 = { 7, 8 }; // список инициализаторов
    Boo boo2 { 9, 10 }; // uniform-инициализация
    return 0;
}
    </code></pre>

    <p>Однако, как только были сделаны какие-либо переменные-члены класса закрытыми, то больше нельзя будет их инициализировать напрямую. Здесь есть смысл: если нельзя напрямую обращаться к переменной (потому что она закрыта), то и не должно быть возможности напрямую её инициализировать.</p><p>Для того, чтобы инициализировать класс с закрытыми переменными-членами необходимо использовать<a href="glossary.html#m7">конструкторы</a>.</p><p>Конструктор - это особый тип метода класса, который автоматически вызывается при создании объекта этого же класса. Конструкторы обычно используются для инициализации переменных-членов класса значениями, которые предоставлены по умолчанию/пользователем, или для выполнения любых шагов настройки, необходимых для используемого класса (например, открыть определенный файл или базу данных).</p><p>Другими словами конструктор - специальная функция, которая выполняет начальную инициализацию элементов данных, причём имя конструктора обязательно должно совпадать с именем класса. Важным отличием конструктора от остальных функций является то, что он не возвращает значений вообще никаких, в том числе и void. В любом классе должен быть конструктор, даже если явным образом конструктор не объявлен (как в предыдущем классе), то компилятор предоставляет конструктор по умолчанию, без параметров  <a href="source.html#metka25">[25]</a>.</p><p>Далее представлен класс CppStudio, с добавленным к нему конструктором.</p>


    <pre class="cpp-code"><code class="language-cpp">
// classes.cpp: определяет точку входа для консольного приложения.
#include "stdafx.h"
#include &ltiostream>
using namespace std;
class CppStudio // имя класса
{
private: // спецификатор доступа private
    int day, // день
        month, // месяц
        year; // год
public: // спецификатор доступа public
    CppStudio(int date_day, int date_month, int date_year ) // конструктор класса
    {
  setDate(date_day, date_month, date_year); // вызов функции установки даты
    }
    void message() // функция (метод класса) выводящая сообщение на экран
    {
        cout << "\nwebsite: cppstudio.com\ntheme: Classes and Objects in C + +\n";
    }
    void setDate(int date_day, int date_month, int date_year) // установка даты в формате дд.мм.гг
    {
        day   = date_day; // инициализация день
        month = date_month; // инициализация месяц
        year  = date_year; // инициализация год
    }
    void getDate() // отобразить текущую дату
    {
        cout << "date: " << day << "." << month << "." << year << endl;
    }
}; // конец объявления класса CppStudio
 
int main(int argc, char* argv[])
{
    CppStudio objCppstudio(11,11,2011); // объявление объекта и инициализация элементов данных
    objCppstudio.message(); // вызов функции message
    objCppstudio.getDate(); // отобразить дату
    system("pause");
    return 0;
}
    </code></pre>
    <p>В данном примере конструктор имеет три параметра, через которые он получает информацию о дате, в теле конструктора вызывается set - функция для установки даты. Можно было реализовать начальную инициализацию элементов данных класса и без set - функции, но так как эта функция была предусмотрена, то правильнее будет использовать именно эту функцию.  Объявлен объект класса, причём после имени объекта в круглых скобочках передаём три аргумента. Вот так с помощью конструктора выполняется начальная инициализация элементов данных (рисунок 10.5).</p>
     <p class="photo"><img src="./img/10_chapter/10.5.jpg" alt=""></p>
    <p class="signature">Рисунок 10.5 &#8211; Конструкторы в С++</p>


    <br><h3 id="10.7">10.7 Классы, содержащие другие классы</h3>
    <p>Одни классы могут содержать другие классы в качестве переменных-членов. По умолчанию, при создании внешнего класса, для переменных-членов будут вызываться конструкторы по умолчанию. Это произойдет до того, как тело конструктора выполнится. Это можно продемонстрировать следующим образом:</p>


    <pre class="cpp-code"><code class="language-cpp">
#include &ltiostream>
using namespace std;
 class A
{
public:
    A() { cout << "A\n"; }
};
 
class B
{
private:
    A m_a; // B содержит A, как переменную-член
 
public:
    B() { cout << "B\n"; }
};
 
int main()
{
    B b;
    return 0;
}

    </code></pre>
     <p class="photo"><img src="./img/10_chapter/10.6.jpg" alt=""></p>
    <p class="signature">Рисунок 10.6 &#8211; Работа с классами, содержащих другие классы</p>
    <p>При создании переменной b вызывается конструктор B(). Прежде чем тело конструктора выполнится, m_a инициализируется, вызывая конструктор по умолчанию класса A. Таким образом, выведется A. Затем управление возвратится обратно к конструктору B, и тело конструктора B начнет свое выполнение.
Здесь есть смысл, так как конструктор B() может захотеть использовать переменную m_a, поэтому сначала нужно инициализировать m_a.
</p>

<br>


<br><h3 id="10.8">10.8 Отделение интерфейса от реализации</h3>
<p> Интерфейс класса - конструкция, определяющая методы и свойства, предоставляемые классом. Реализация класса - это способ осуществления работоспособности класса. До этого мы не отделяли интерфейс класса от его реализации, то есть реализация методов осуществлялась внутри класса. Отделение интерфейса от реализации класса выполняется для того, чтобы скрыть способ осуществления работоспособности класса. Отделение интерфейса от реализации выполняется за 5 шагов:<br><br>1)   добавить в проект заголовочный файл *.h;<br>2)  определить интерфейс класса в заголовочном файле<br>3)  добавить в проект исполняемый файл *.cpp;<br>4) в исполняемом файле выполнить реализацию класса;<br>5)  подключить заголовочный файл к программе.</p>

<p>Как добавить заголовочный файл в проект уже было рассмотрено - точно также добавляется и исполняемый файл, имена этим файлам даются, как правило, одинаковые.  Интерфейс класса должен выглядеть следующим образом.</p>
<pre class="cpp-code"><code class="language-cpp">
// заголовочный файл класса СppStudio.h
// интерфейс класса
 // объявление класса
class CppStudio // имя класса
{ 
private: // спецификатор доступа private
    int day, // день
        month, // месяц
        year; // год
public: // спецификатор доступа public
    CppStudio(int, int, int); // конструктор класса
    void message(); // функция (метод класса) выводящая сообщение на экран
    void setDate(int, int, int); // установка даты в формате дд.мм.гг
    void getDate(); // отобразить текущую дату
}; // конец объявления класса CppStudio
    </code></pre>

    <p>В интерфейсе класса остались объявленные переменные и прототипы методов класса. Теперь рассмотрим содержимое файла реализации методов класса.</p>

<pre class="cpp-code"><code class="language-cpp">
// файл реализации класса CppStudio.cpp
 #include &ltiostream>
using namespace std;
// подключаем интерфейс класса к файлу его реализации
#include "CppStudio.h"
 CppStudio::CppStudio(int date_day, int date_month, int date_year ) // конструктор класса
{
 setDate(date_day, date_month, date_year); // вызов функции установки даты
}
 void CppStudio::message() // функция (метод класса) выводящая сообщение на экран
{
 cout << "nwebsite: cppstudio.comntheme: Classes and Objects in C + +n";
}
 
void CppStudio::setDate(int date_day, int date_month, int date_year) // установка даты в формате дд.мм.гг
{
 day   = date_day; // инициализация день
 month = date_month; // инициализация месяц
 year  = date_year; // инициализация год
}
 void CppStudio::getDate() // отобразить текущую дату
{
 cout << "date: " << day << "." << month << "." << year << endl;
}
</code></pre>
<p>Чтобы связать интерфейс класса и его реализацию, необходимо в файле реализации подключить заголовочный файл с определением класса. После этого можно объявлять методы класса. Методы класса объявляются точно так же как и функции, только перед именем метода необходимо написать имя класса и поставить унарную операцию разрешения области действия «::«.</p>

<pre class="cpp-code"><code class="language-cpp">
// синтаксис объявления методов класса вне тела класса
/*возвращаемый тип данных*/ /*имя класса*/::/*имя метода*/(/*параметры метода*/)
{
 // операторы
}

</code></pre>
<p>Так как методы класса объявляются вне тела класса, то необходимо связать реализацию метода с классом, а для этого воспользуемся бинарной операцией разрешения области действия. Бинарная операция разрешения области действия привязывает метод, объявленный извне, к классу, имя которого совпадает с именем в объявлении метода. Вот именно поэтому в объявлении метода класса необходимо добавлять имя класса и операцию разрешения области действия.</p>
<p>Итак, интерфейс класса определён, методы класса объявлены, осталось подключить заголовочный файл в исполняемом файле с main() функцией и программа готова.</p>

<pre class="cpp-code"><code class="language-cpp">
// classes.cpp: определяет точку входа для консольного приложения.
 #include "stdafx.h"
// подключаем класс CppStudio
#include "CppStudio.h"
 int main(int argc, char*argv[])
{
    CppStudio objCppstudio(11,11,2011); // объявление объекта и инициализвция элементов данных
    objCppstudio.message(); // вызов функции message
    objCppstudio.getDate(); // отобразить дату
    system("pause");
    return 0;
}
</code></pre>
<p>В данном примере в пятой строке подключается заголовочный файл класса, после чего можно создавать объекты этого класса.</p>


<br><h3 id="10.9">10.9 Инкапсуляция</h3>
<br><h3>10.9.1 Введение в инкапсуляцию</h3>
<p>В объектно-ориентированном программировании инкапсуляция (или «сокрытие информации») - это процесс скрытого хранения деталей реализации объекта. Пользователи обращаются к объекту через открытый интерфейс.</p><p>Это аналогично тому, как в обыденной жизни мы имеем доступ ко многим электронным устройствам. К телевизору есть пульт дистанционного управления, с помощью которого можно включать/выключать телевизор. Управление автомобилем позволяет в разы быстрее передвигаться между двумя точками. С помощью фотоаппарата можно делать снимки.</p><p>Все эти вещи используют общий шаблон: они предоставляют вам простой интерфейс (<a href="glossary.html#m7">кнопка</a>, руль и т.д.) для выполнения определенного действия. Однако, то, как эти устройства фактически работают, скрыто от вас (как от пользователей). Для нажатия кнопки на пульте дистанционного управления вам не нужно знать, что выполняется «под капотом» пульта для взаимодействия с телевизором. Когда вы нажимаете на педаль газа в своем автомобиле, вам не нужно знать о том, как двигатель внутреннего сгорания приводит в движение колеса. Когда вы делаете снимок, вам не нужно знать, как датчики собирают свет в пиксельное изображение.</p>
<p>Такое разделение интерфейса и реализации чрезвычайно полезно, поскольку оно позволяет использовать объекты, без необходимости понимания их реализации. Это значительно снижает сложность использования этих устройств и значительно увеличивает их количество (устройства с которыми можно взаимодействовать). По аналогичным причинам разделение реализации и интерфейса полезно и в программировании  <a href="source.html#metka25">[25]</a>.</p><p>Инкапсуляция позволяет пользователю не задумываться о сложности объекта (то, что у него внутри), а взаимодействовать с ним посредством предоставляемого интерфейса, а также объединить в единое целое и защитить как данные, так и алгоритмы обработки этих данных. При этом пользователю предоставляется только спецификация объекта. </p>
<p>Рассмотрим принципы инкапсуляции на примере кота, представленного на рисунке 10.7. </p>

<p class="photo"><img src="./img/10_chapter/10.7.jpg" alt=""></p>
    <p class="signature">Рисунок 10.7 &#8211; Визуальное представление инкапсуляции</p>
<p>Объект кот обладает рядом внутренних (в терминах ООП – «приватных») параметров, характеризующих его состояние: mood (настроение), hungry (голод), energy (энергия) и методом meow (мяукать). Пользователь не может напрямую влиять на перечисленные параметры, но ему доступны «публичные» методы взаимодействия с котом, которые совокупно влияют на внутренние показатели: sleep (спать), eat (кушать), play (играть). Возможны два способа представления классов, когда реализация методов осуществляется внутри класса и когда интерфейс класса разделяют от реализации, это делается для того, чтобы скрыть способ осуществления работоспособности класса.</p>

<pre class="cpp-code"><code class="language-cpp">
class Rectangle { public: int Height; int Width; };
</code></pre>
<p>А использование класса</p>
<pre class="cpp-code"><code class="language-cpp">
Rectangle R; 
R.Width = 20; 
R.Height = 10; 
float CenterX = R.Width / 2.0; 
float CenterY = R.Height / 2.0; 
int Perimeter = 2 * (R.Width + R.Height);
int Area = R.Width * R.Height; 
float Scale = R.Height; 
float Deformation = (float) R.Height / R.Width; 
cout <<"Прямоугольник со сторонами "<< R.Width <<" и "<< R.Height << endl; 
cout <<"Прямоугольник с центром ("<< CenterX <<","<< CenterY <<")"<< endl; 
cout <<"Периметр прямоугольника P = "<< Perimeter << endl; cout <<"Площадь прямоугольника S = "<< Area << endl; 
cout <<"Прямоугольник с деформацией = "<< Deformation <<" и масштабом = "<< Scale << endl;
</code></pre>

<p>Результат выполнения кода представлен на рисунке 10.8. </p>

<p class="photo"><img src="./img/10_chapter/10.8.jpg" alt=""></p>
<p class="signature">Рисунок 10.8 &#8211; Демонстрация запуска не инкапсулированного кода</p>

<p>Инкапсуляция описанного выше класса близка к нулю, что снижает удобство пользования классом. Необходимо провести скрытие в два этапа. Внутреннее состояние объектов переместить в приватную область видения и отделить интерфейс от реализации. Первая задача решается выделением приватных членов класса.</p>
<pre class="cpp-code"><code class="language-cpp">
private: 
int Height; 
int Width; 
float CenterX; 
float CenterY; 
float Scale; 
float Deformation; 
int Perimeter() {return 2 * (Width + Height);} 
int Area() {return Width * Height;}
</code></pre>
<p>Публичными методами реализуется конструктор и описание класса.</p>
<pre class="cpp-code"><code class="language-cpp">
public: Rectangle(int_widht, 
int_height) {     Height = _height;    
Width = _widht;     
CenterX = Width / 2.0;     
CenterY = Height / 2.0;     Scale = Height;     
Deformation = (float) Height / Width; }
</code></pre>
<p>Конструктор прямоугольника принимает 2 параметра – ширину и высоту, а на основе них метод рассчитывает координаты центральной точки, масштаб и коэффициент трансформации прямоугольника. Эти параметры используются в классе для оформления следующего публичного метода Description(), который служит для вывода описания (всех внутренних полей класса) в стандартный поток вывода cout.</p>

<pre class="cpp-code"><code class="language-cpp">
public: 
. . . 
Void Description() 
{     
cout<<"Прямоугольник со сторонами "<< Width<<" и  "<< Height<<<"Прямоугольник с центром ("<< CenterX <<","<< CenterY <<")"<< endl;    
cout <<"Периметр прямоугольника P = "<< Perimeter() << endl;    
cout <<"Площадь прямоугольника S = "<< Area() << endl;     
cout <<"Прямоугольник с деформацией = "<< Deformation <<" и масштабом = "<< Scale << endl; }
</code></pre>

<p>Выделение интерфейса класса (в заголовочном файле "Rectangle.h") класса может выглядеть так:</p>

<pre class="cpp-code"><code class="language-cpp">
//Заголовочный файл "Rectangle.h".
class Rectangle 
{ 
private: 
int Height; 
int Width; 
float CenterX; 
float CenterY; 
float Scale; 
float Deformation; 
int Perimeter(); 
int Area(); 
public: 
Rectangle(int_widht, int_height); void Description(); };

    </code></pre>

<p>Рассмотрим содержимое файла реализации (исполняемый файл "Rectangle.cpp") методов класса. Подключение внешних файлов, реализация конструктора класса.</p>
<pre class="cpp-code"><code class="language-cpp">
//Исполняемый файл "Rectangle.cpp".
#include "Rectangle.h" 
#include &ltiostream> 
 using namespace std; 
int Rectangle::Perimeter() { return 2 * (Width + Height); }
 int Rectangle::Area() { return Width * Height; } Rectangle::Rectangle(int_widht, int_height) 
{ 
Height = _height; Width = _widht; CenterX = Width / 2.0; CenterY = Height / 2.0; Scale = Height; Deformation = (float)Height / Width; 
}
</code></pre>

<p>Методы класса объявляются точно так же, как и функции, только перед именем метода необходимо написать имя класса и поставить унарную операцию разрешения области действия «::». Так как методы класса объявляются вне тела класса, то необходимо связать реализацию метода с классом, а для этого воспользуемся бинарной операцией разрешения области действия. Бинарная операция разрешения области действия привязывает метод, объявленный извне, к классу, имя которого совпадает с именем в объявлении метода. Вот именно поэтому в объявлении метода класса необходимо добавлять имя класса и операцию разрешения области действия.</p>

<pre class="cpp-code"><code class="language-cpp">
//Исполняемый файл "Rectangle.cpp"
void Rectangle::Description() { setlocale(LC_ALL, "rus"); // устанавливаем кодировку вы‐ вода 
cout <<"Прямоугольник со сторонами "<< Width <<" и "<< Height << endl; 
cout <<"Прямоугольник с центром ("<< CenterX <<","<< CenterY <<")"<< endl; 
cout <<"Периметр прямоугольника P = "<< Perimeter() << endl; cout <<"Площадь прямоугольника S = "<< Area() << endl; 
cout <<"Прямоугольник с деформацией = "<< Deformation <<" и масштабом = "<< Scale << endl; }

</code></pre>


<p>После того как интерфейс класса определен, методы класса объявлены, можно проверить работу класса в новом приложении. Для этого необходимо в исполняемом файле приложения с точкой входа (функция main) подключить заголовочный файл нового класса "Rec‐ tangle.h" и далее использовать класс в программе.</p>

<pre class="cpp-code"><code class="language-cpp">
//Исполняемый файл "Source.cpp".
#include #include "Rectangle.h" Using namespace std; int main() { 
Rectangle R = Rectangle(20,10); 
R.Description(); 
system("pause");
return 0; 
}
</code></pre>

<p>Структура описанного проекта в среде программирования Visual Studio представлена на рисунке 6 (код в левой части, иерархия файлов справа в обозревателе решений), а результат выполнения приложения не изменился после выделения интерфейса и был представлен ранее на рисунке 10.9.</p>

<p class="photo"><img src="./img/10_chapter/10.9.jpg" alt=""></p>
<p class="signature">Рисунок 10.9 &#8211; Структура приложения с Rectangle</p>
<p>Таким образом, использование инкапсуляции имеет несколько преимуществ:<br>1 Инкапсулированные классы проще в использовании и уменьшают сложность программ.<br>С полностью инкапсулированным классом нужно знать только то, какие методы являются доступными для использования, какие аргументы они принимают и какие значения возвращают. Не нужно знать, как класс реализован изнутри. Например, класс, содержащий список имен, может быть реализован с использованием динамического массива array, vector, map, list или любой другой структуры данных. Для использования этого класса не нужно знать детали его реализации. Это значительно снижает сложность  программ, а также уменьшает количество возможных ошибок. Это является ключевым преимуществом инкапсуляции.<br>Все классы cтандартной библиотеки C++ инкапсулированы, следовательно разработчику не нужно знать реализацию std::string, std::vector или std::cout (и других объектов) для того, чтобы их использовать.<br>2  Инкапсулированные классы помогают защитить данные и предотвращают их неправильное использование.</p>
<p>Глобальные переменные опасны, так как нет строгого контроля над тем, кто имеет к ним доступ и как их используют. Классы с открытыми членами имеют ту же проблему, только в меньших масштабах. Например, для того, чтобы написать строковый класс необходимо могли бы начать со следующего:</p>
<pre class="cpp-code"><code class="language-cpp">
    class MyString
{
    char *m_string; // динамически выделяем строку 
    int m_length; // используем переменную для отслеживания длины строки
};
</code></pre>

<p>Эти два члена связаны: m_length всегда должен соответствовать длине строки, удерживаемой m_string. Если бы m_length был открытым, то любой мог бы изменить длину строки без изменения m_string (или наоборот). Это точно привело бы к проблемам. Делая как m_length, так и m_string закрытыми, пользователи вынуждены использовать методы для взаимодействия с классом.</p>
<p>Также можно улучшить защиту класса от неправильного использования. Например, рассмотрим класс с открытой переменной-членом в виде массива:</p>

<pre class="cpp-code"><code class="language-cpp">
class IntArray
{
public:
    int m_array[10];
};

</code></pre>
<p>Если бы пользователи могли напрямую обращаться к массиву, то они могли бы использовать недопустимый индекс:</p>


<pre class="cpp-code"><code class="language-cpp">
    int main()
{
    IntArray array;
    array.m_array[16] = 2; // некорректный индекс, вследствие чего перезаписываем память, которой мы не владеем
}

</code></pre>

<p>Однако, если сделать массив закрытым, то можно заставить пользователя использовать функцию, которая первым делом проверяет корректность индекса: </p>

<pre class="cpp-code"><code class="language-cpp">
    class IntArray
{
private:
    int m_array[10]; // пользователь не имеет прямого доступа к этому члену
 
public:
    void setValue(int index, int value)
    {
        // Если индекс недействителен, то не делаем ничего
        if (index < 0 || index >= 10)
            return;
         m_array[index] = value;
    }
}; 
</code></pre>
<p>Таким образом, мы защитим целостность нашей программы.<br>
3 Инкапсулированные классы легче изменить.<br>Для простоты понимания данного преимущества представлен пример. </p>

<pre class="cpp-code"><code class="language-cpp">
#include &ltiostream>
class Values
{
public:
    int m_number1;
    int m_number2;
    int m_number3;
};
int main()
{
    Values value;
    value.m_number1 = 7;
    cout << value.m_number1 << '\n';
}
</code></pre>

<p>Что произойдет, если необходимо будет переименовать m_number1 или изменить тип этой переменной. В данном случае  была бы нарушена работоспособность не только этой программы, но и большей части программ, которые используют класс Values.</p>
<p>Инкапсуляция предоставляет возможность изменения способа реализации классов, не нарушая при этом работу всех программ, которые их используют. Далее представлена инкапсулированная версия класса, приведенного выше, но которая использует методы для доступа к m_number1:</p>

<pre class="cpp-code"><code class="language-cpp">
#include &ltiostream>
using namespace std;
 class Values
{
private:
    int m_number1;
    int m_number2;
    int m_number3;
 public:
    void setNumber1(int number) { m_number1 = number; }
    int getNumber1() { return m_number1; }
};
int main()
{
    Values value;
    value.setNumber1(7);
    cout << value.getNumber1() << '\n';
}

</code></pre>

<p>Можно также изменить реализацию класса:</p>
<pre class="cpp-code"><code class="language-cpp">
#include &ltiostream>
using namespace std;
 class Values
{
private:
    int m_number[3]; // здесь изменяем реализацию этого класса
 public:
    // Нам нужно обновить переменные методов, чтобы заработала новая реализация
    void setNumber1(int number) { m_number[0] = number; }
    int getNumber1() { return m_number[0]; }
};
 int main()
{
    // Программа продолжает работать как прежде
    Values value;
    value.setNumber1(7);
    cout << value.getNumber1() << '\n';
}
</code></pre>

<p>В данном случае, поскольку не были изменены прототипы каких-либо функций в открытом интерфейсе класса, программа, использующая класс, продолжает работать без каких-либо изменений или проблем  <a href="source.html#metka25">[25]</a>.</p>
<p>И, наконец, инкапсуляция помогает проводить отладку программ, когда что-то идет не по плану. Часто причиной неправильной работы программы является некорректное значение одной из переменных. Если каждый объект имеет прямой доступ к переменной, то отследить часть кода, которая изменила переменную, может быть довольно-таки трудно. Однако, если для изменения значения нужно вызывать один и тот же метод, можно просто использовать точку останова для этого метода и посмотреть, как каждый вызывающий объект изменяет значение, пока не будет замечено что-то странное.</p>


<br><h3>10.10 Наследование </h3>
<br><h3 id="10.10.1">10.10.1 Введение в наследование</h3>
<p><a href="glossary.html#m8">Наследование</a> – свойство языка программирования, позволяющее описать новый класс на основе уже существующего (родительского), при этом свойства и функциональность родительского класса заимствуются новым классом. Класс, от которого произошло наследование, называется базовым или родительским. Наследование классов схоже с наследованием на представленном рисунке 10.10</p>

<p class="photo"><img src="./img/10_chapter/10.10.jpg" alt=""></p>
<p class="signature">Рисунок 10.10 &#8211; Визуальное представление наследования</p>

<p>Классы, которые произошли от базового, называются потомками, наследниками или производными классами. Из определения следует, что класс-наследник реализует интерфейс базового класса, что позволяет обращаться с объектами класса-наследника точно так же, как с объектами базового класса.</p>
<p>Для понимания процесса наследования далее рассмотрен пример с яблоками и бананами. Хотя яблоко и банан - это разные фрукты, но у них обоих есть одно общее свойство: они оба являются фруктами. И поскольку яблоки и бананы - это фрукты, то, всё, что верно для фруктов, верно и для яблок с бананами. </p>
<p>Если изобразить отношения между яблоками, бананами и фруктами на диаграмме, то это будет выглядеть как указано на рисунке 10.11.</p>

<p class="photo"><img src="./img/10_chapter/10.11.jpg" alt=""></p>
<p class="signature">Рисунок 10.11 &#8211; Наследование свойств фруктов яблоками и бананами</p>

<p>На данном рисунке наглядно видна иерархия. Иерархия - это диаграмма со связями объектов. Большинство иерархий либо демонстрируют прогрессию с течением времени, либо классифицируют вещи таким образом, чтобы они переходили от общего к конкретному. </p>
<p>Далее представлен еще один пример иерархии: квадрат является прямоугольником, который является четырехугольником, который является фигурой. Правильный треугольник - это треугольник, который также является фигурой (рисунок 10.12).</p>

<p class="photo"><img src="./img/10_chapter/10.12.jpg" alt=""></p>
<p class="signature">Рисунок 10.12 &#8211; Наследование свойств геометрических фигур</p>

<p>Здесь каждый элемент наследует свойства и поведение элемента над ним (движемся сверху вниз).</p>


<br><h3 id="10.10.2">10.10.2 Базовое наследование</h3>
<p>Наследование в C++ происходит между классами и имеет тип отношений «является». Класс, от которого наследуют, называется родительским (или «базовым», «суперклассом»), а класс, который наследует, называется дочерним (или «производным», «подклассом»).</p>
<p>На рисунке 10.8 фрукт является родительским классом, а яблоко и банан - дочерними классами. На рисунке 10.9 геометрических фигур треугольник является дочерним классом (родитель - фигура) и родительским (для правильного треугольника) одновременно.</p>
<p>Дочерний класс наследует как поведение (методы), так и свойства (переменные-члены) от родителя. Эти методы и переменные становятся членами дочернего класса.</p>
<p>Поскольку дочерние классы являются полноценными классами, то они могут иметь и свои собственные члены. Рассмотрим конкретный пример.</p>
<p>Далее представлен простой класс Human для представления человека.</p>

<pre class="cpp-code"><code class="language-cpp">
#include &ltstring>
using namespace std;
class Human
{ public:
    string m_name;
    int m_age;
    Human(string name = "", int age = 0)
        : m_name(name), m_age(age)
    {
    }
    string getName() const { return m_name; }
    int getAge() const { return m_age; }
};
</code></pre>
<p>В данном классе были определены только те члены, которые являются общими для всех объектов этого класса. Каждый человек (независимо от пола, профессии и т.д.) имеет имя и возраст.</p>
<p>Следует обратить внимание, что в данном примере  все переменные-члены и методы класса были сделаны открытыми. Это реализовано ради простоты примера. Обычно переменные-члены нужно делать private. </p>
<p>Далее представлена программа, которая будет отслеживать информацию о баскетболистах, в которой сохраняется средний уровень игры баскетболиста и количество очков.</p>
<p>Вот наш незавершенный класс BasketballPlayer:</p>

<pre class="cpp-code"><code class="language-cpp">
class BasketballPlayer
{
public:
    double m_gameAverage;
    int m_points;
    BasketballPlayer(double gameAverage = 0.0, int points = 0)
       : m_gameAverage(gameAverage), m_points(points)
    {
    }
};
</code></pre>
<p>Также нам нужно знать имя и возраст баскетболиста, а эта информация уже есть: она хранится в классе Human.</p>
<p>Есть три варианта добавления имени и возраста в BasketballPlayer:<br>1  Добавить имя и возраст в класс BasketballPlayer непосредственно в качестве членов. Это плохой вариант, так как произойдет дублирование кода, который уже существует в классе Human. <br>2   Добавить класс Human в качестве члена в класс BasketballPlayer, используя композицию. Но возникает вопрос: «Может ли BasketballPlayer иметь Human». Но это некорректно.<br>3   Сделать так, чтобы BasketballPlayer унаследовал необходимые атрибуты от Human. Тип отношений в наследовании - «является». Является ли BasketballPlayer Human-ом (т.е. человеком). Конечно. Поэтому лучший выбор – наследование  <a href="source.html#metka25">[25]</a>.
</p>
<p>Далее необходимо сделать класс BasketballPlayer дочерним. Чтобы класс BasketballPlayer унаследовал информацию от класса Human, необходимо после объявления BasketballPlayer (class BasketballPlayer) использовать двоеточие, ключевое слово public и имя класса, от которого нужно унаследовать. Это называется открытым наследованием.</p>

<pre class="cpp-code"><code class="language-cpp">
// BasketballPlayer открыто наследует Human
class BasketballPlayer : public Human
{
public:
    double m_gameAverage;
    int m_points;
    BasketballPlayer(double gameAverage = 0.0, int points = 0)
       : m_gameAverage(gameAverage), m_points(points)
    {
    }
};
</code></pre>
<p>Когда BasketballPlayer наследует свойства класса Human, то BasketballPlayer приобретает методы и переменные-члены класса Human. Кроме того, BasketballPlayer имеет еще два своих собственных члена: m_gameAverage и m_points. Здесь есть смысл, так как эти свойства специфичны только для BasketballPlayer, а не для каждого Human-а.</p>
<p>Таким образом, объекты BasketballPlayer будут иметь четыре члена:</p>

<pre class="cpp-code"><code class="language-cpp">
    m_gameAverage и m_points от BasketballPlayer;
    m_name и m_age от Human.
</code></pre>

<p>Полный код программы будет выглядеть следующим образом:</p>

<pre class="cpp-code"><code class="language-cpp">
#include &ltiostream>
#include &ltstring>
using namespace std;
class Human
{  public:
    string m_name;
    int m_age;
    Human(std::string name = "", int age = 0)
        : m_name(name), m_age(age)
    {
    }
    string getName() const { return m_name; }
    int getAge() const { return m_age; }
};
// BasketballPlayer открыто наследует Human
class BasketballPlayer : public Human
{ public:
    double m_gameAverage;
    int m_points;
    BasketballPlayer(double gameAverage = 0.0, int points = 0)
       : m_gameAverage(gameAverage), m_points(points)
    {
    }
};
int main()
{    // Создаем нового Баскетболиста
    BasketballPlayer anton;
    // Присваиваем ему имя (мы можем делать это напрямую, так как m_name является public)
    anton.m_name = "Anton";
    // Выводим имя Баскетболиста
    cout << anton.getName() << '\n'; // используем метод getName(), который мы унаследовали от класса Human
    return 0;
}
</code></pre>
<p>Результат выполнения программы представлен на рисунке 10.13.</p>

<p class="photo"><img src="./img/10_chapter/10.13.jpg" alt=""></p>
<p class="signature">Рисунок 10.13 &#8211; Работа с данными баскетболиста</p>

<p>Это работает, так как anton является объектом класса BasketballPlayer, а все объекты класса BasketballPlayer имеют переменную-член m_name и метод getName(), унаследованные от класса Human.</p>
<p>Далее попробуем создать класс, который также будет наследовать свойства Human. Например, класс Employee (работник). Работник «является» человеком, поэтому использовать наследование здесь уместно:</p>


<pre class="cpp-code"><code class="language-cpp">
// Employee открыто наследует Human
using namespace std;
class Employee: public Human
{ public:
    int m_wage;
    long m_employeeID;
     Employee(int wage = 0, long employeeID = 0)
        : m_wage(wage), m_employeeID(employeeID)
    {
    }
     void printNameAndWage() const
    {        cout << m_name << ": " << m_wage << '\n';
    }
};
</code></pre>

<p>Работник наследует m_name и m_age от Human-а (а также два метода) и имеет еще две собственные переменные-члены и один метод. Обратите внимание, метод printNameAndWage() использует переменные как из класса, к которому принадлежит (Employee::m_wage), так и с родительского класса (Human::m_name). Это будет выглядеть как представлен на рисунке 10.14.</p>

<p class="photo"><img src="./img/10_chapter/10.14.jpg" alt=""></p>
<p class="signature">Рисунок 10.14 &#8211; Наследование свойств человека работником</p>

<p>Следует обратить внимание на то, что классы Employee и BasketballPlayer не имеют прямых отношений, хотя оба наследуют свойства класса Human. Полный код представлен далее.</p>

<pre class="cpp-code"><code class="language-cpp">
#include &ltiostream>
#include &ltstring>
using namespace std;
 class Human
{public:
    string m_name;
    int m_age;
     string getName() const { return m_name; }
    int getAge() const { return m_age; }
     Human(std::string name = "", int age = 0)
        : m_name(name), m_age(age)
    {
    }};
 // Employee открыто наследует Human
class Employee: public Human
{public:
    int m_wage;
    long m_employeeID;
     Employee(int wage = 0, long employeeID = 0)
        : m_wage(wage), m_employeeID(employeeID)
    {
    }
     void printNameAndWage() const
    {        cout << m_name << ": " << m_wage << '\n';
    }
};
 int main()
{    Employee ivan(350, 787);
    ivan.m_name = "Ivan"; // мы можем это сделать, так как m_name является public
     ivan.printNameAndWage();
        return 0; }
</code></pre>

<p>Результат выполнения программы представлен на рисунке 10.15.</p>
<p class="photo"><img src="./img/10_chapter/10.15.jpg" alt=""></p>
<p class="signature">Рисунок 10.14 &#8211; Работа с классом работник</p>

<p>Можно наследовать от класса, который сам наследует от другого класса. Например, напишем класс Supervisor (супервайзер). Супервайзер - это работник, который «является» человеком. Ранее уже был написан класс Employee, поэтому он будет использоваться в качестве родительского класса:</p>

<pre class="cpp-code"><code class="language-cpp">
    class Supervisor: public Employee
{
public:
    // Этот супервайзер может наблюдать максимум за 5-тью работниками
    long m_nOverseesIDs[5];
     Supervisor()
    {    } };
</code></pre>

<p class="photo"><img src="./img/10_chapter/10.16.jpg" alt=""></p>
<p class="signature">Рисунок 10.16 &#8211; Наследование от класса, который сам наследует от другого класса</p>
<p>Все объекты Supervisor наследуют методы и переменные от Employee и Human, а также имеют свою собственную переменную-член m_nOverseesIDs.</p>
<p>Построив такие цепочки наследований, можно создать набор повторно используемых классов, которые будут иметь общие свойства вверху и становиться всё более специфичными на каждом последующем уровне наследования.</p>
<p>Использование наследования означает, что не нужно переопределять информацию из родительских классов в дочерних. Автоматически получаются методы и переменные-члены суперкласса через наследование, а затем просто добавляются специфичные методы или переменные-члены, которые необходимы. Это не только экономит время и усилия, но также является очень эффективным: если когда-либо будет обновлен или изменен базовый класс, то все производные классы автоматически унаследуют эти изменения  <a href="source.html#metka25">[25]</a>.</p>
<p>Например, если добавить новый метод в Human, то Employee и Supervisor автоматически получат доступ к нему. Если добавить новую переменную в Employee, Supervisor также получит доступ к ней. Это позволяет создавать новые классы более простым, интуитивно-понятным способом.</p>


<br><h3 id="10.10.3">10.10.3 Порядок построения дочерних классов</h3>
<p>Для понимания работы по построению дочерних классов представлен пример по работе с двумя классами.</p>

<pre class="cpp-code"><code class="language-cpp">
 class Parent
{ public:
    int m_id;
     Parent(int id=0)
        : m_id(id)
    {
    }
     int getId() const { return m_id; }
};
 class Child: public Parent
{ public:
    double m_value;
    Child(double value=0.0)
        : m_value(value)
    {
    }
     double getValue() const { return m_value; }
};
</code></pre>
<p>В этом примере класс Child является дочерним, а класс Parent – родительским (рисунок 10.17).</p>
<p class="photo"><img src="./img/10_chapter/10.17.jpg" alt=""></p>
<p class="signature">Рисунок 10.17 &#8211; Наследование ребенком свойств родителя</p>
<p>Поскольку Child наследует переменные-члены и методы класса Parent, то можно предположить, что члены класса Parent копируются в класс Child, но это не так. Вместо этого рассматривайте Child как класс, который состоит из двух частей: первая - Parent, вторая – Child (рисунок 10.18).</p>
<p class="photo"><img src="./img/10_chapter/10.18.jpg" alt=""></p>
<p class="signature">Рисунок 10.18 &#8211; Класс ребенок состоит из двух частей</p>

<p>Parent - это не дочерний класс, так как он не наследует свойства каких-либо других классов. C++ выделяет память для Parent, затем вызывается конструктор по умолчанию класса Parent для выполнения инициализации.</p>
<p>Далее представлен пример создания объектов дочернего класса.</p>

<pre class="cpp-code"><code class="language-cpp">
    int main()
{
    Child child;
     return 0; 
 };
</code></pre>
<p>На первый взгляд, всё вроде бы так же, как и в предыдущем примере, но «под капотом» всё несколько иначе. Как мы уже говорили, класс Child состоит из двух частей: часть Parent и часть Child. Когда C++ создает объекты дочерних классов, то он делает это поэтапно. Сначала создается самый верхний класс иерархии (тот, который родитель). Затем создается дочерний класс, который идет следующим по порядку, и так до тех пор, пока не будет создан последний класс (тот, который находится в самом низу иерархии).</p>
<p>Поэтому, при создании объекта класса Child, сначала создается часть Parent класса Child (с использованием конструктора по умолчанию класса Parent) и после того, как с частью Parent покончено, создается вторая часть Child (с использованием конструктора по умолчанию класса Child). В нашем примере больше нет дочерних классов, поэтому на этом всё и заканчивается.</p><p>Этот процесс на самом деле легко проиллюстрировать:</p>
<pre class="cpp-code"><code class="language-cpp">
#include &ltiostream>
using namespace std;
 class Parent
{
public:
    int m_id;
     Parent(int id=0)
        : m_id(id)
    {
        cout << "Parent\n";
    }
    int getId() const { return m_id; }
};
class Child: public Parent
{
public:
    double m_value;
     Child(double value=0.0)
        : m_value(value)
    {
        cout << "Child\n";
    }
    double getValue() const { return m_value; }
};
 int main()
{
    cout << "Instantiating Parent:\n";
    Parent dParent;
     cout << "Instantiating Child:\n";
    Child dChild;
     return 0;
}
</code></pre>
<p>Результат выполнения программы представлен на рисунке 10.19.</p>
<p class="photo"><img src="./img/10_chapter/10.19.jpg" alt=""></p>
<p class="signature">Рисунок 10.19 &#8211; Пример работы с дочерними классами</p>
<p>Как видно на рисунке 10.16, при создании Child сначала создается часть Parent класса Child. В этом есть смысл, так как по логике вещей ребенок не может существовать без родителей. Это также способствует безопасности и эффективности выполнения кода: дочерний класс часто использует переменные-члены и методы родителя, но родительский класс ничего не знает о своем дочернем классе. Первоначальная инициализация родительского класса гарантирует, что его переменные-члены и методы будут проинициализированы до момента использования их дочерним классом.</p>
<p>Следует помнить,  что в C++ всегда идет построение с «первого» или «топового» класса иерархии. Затем C++ переходит к следующему классу в иерархии и выполняет его построение. Этот процесс последовательный.</p>
<p>Проиллюстрируем порядок построения классов в цепочке наследования, приведенной выше:</p>

<pre class="cpp-code"><code class="language-cpp">
using namespace std;
int main()
{
    cout << "Constructing A: \n";
    A cA;
     cout << "Constructing B: \n";
    B cB;
     cout << "Constructing C: \n";
    C cC;
     cout << "Constructing D: \n";
    D cD;
}
</code></pre>
<p>Результат выполнения данного кода представлен на рисунке 10.20.</p>
<p class="photo"><img src="./img/10_chapter/10.20.jpg" alt=""></p>
<p class="signature">Рисунок 10.20 &#8211; Построение классов в цепочке наследования</p>
<p>Таким образом, язык C++ выполняет построение дочерних классов поэтапно, начиная с верхнего класса иерархии и заканчивая нижним классом иерархии. По мере построения каждого класса для выполнения инициализации вызывается соответствующий конструктор соответствующего класса.</p>

<br><br><h3 id="10.10.4">10.10.4 Конструкторы и инициализация дочерних классов</h3>
<p>Для понимания работы конструкторов и инициализации далее рассмотрен пример использования классов Parent и Child.</p>
<pre class="cpp-code"><code class="language-cpp">
    Class Parent
{
public:
    int m_id;
     Parent(int id=0)
        : m_id(id)
    {
    }
     int getId() const { return m_id; }
};
 class Child: public Parent
{
public:
    double m_value;
     Child(double value=0.0)
        : m_value(value)
    {
    }
     double getValue() const { return m_value; }
};
</code></pre>
<p>В данном коде объект класса Parent создается следующим образом:</p>
<pre class="cpp-code"><code class="language-cpp">
    int main()
{
    Parent parent(7); // вызывается конструктор Parent(int)
     return 0;
}
</code></pre>
<p>С обычными (не дочерними) классами конструктору нужно заморачиваться только с членами своего класса. Вот что на самом деле происходит при инициализации объекта parent:<br>- выделяется память для объекта parent;<br>- вызывается соответствующий конструктор класса Parent;
<br>- список инициализации инициализирует переменные;
<br>- выполняется тело конструктора;
<br>- точка выполнения возвращается обратно в caller.</p>
<p>С дочерними классами дела обстоят несколько сложнее. Вот что происходит при инициализации объекта child:
<br>- выделяется память для объекта дочернего класса (достаточная порция памяти для части Parent и части Child объекта класса Child);
<br>- вызывается соответствующий конструктор класса Child;
<br>- создается объект класса Parent с использованием соответствующего конструктора класса Parent. Если такой конструктор программистом не предоставлен, то будет использоваться конструктор по умолчанию класса Parent;
<br>- список инициализации инициализирует переменные;
<br>- выполняется тело конструктора класса Child;
<br>- точка выполнения возвращается обратно в caller.
</p>

<p>Единственное различие между инициализацией объектов обычного и дочернего класса заключается в том, что при инициализации объекта дочернего класса, сначала выполняется конструктор родительского класса (для инициализации части родительского класса) и только потом уже выполняется конструктор дочернего класса.</p>
<p>Одним из недостатков созданного в примере дочернего класса Child является то, что мы не можем инициализировать m_id при создании объекта класса Child. Что, если мы хотим задать значение как для m_value (части Child), так и для m_id (части Parent).</p>
<p>Можно пытаться решить эту проблему следующим образом:</p>

<pre class="cpp-code"><code class="language-cpp">
class Child: public Parent
{
public:
    double m_value;
    Child(double value=0.0, int id=0)
        // Не сработает
        : m_value(value), m_id(id)
    {
    }
     double getValue() const { return m_value; }
};
</code></pre>
<p>Это хорошая попытка и почти правильная идея. Нам определенно нужно добавить еще один параметр в конструктор, иначе C++ не будет понимать, каким значением необходимо инициализировать m_id.</p>
<p>Однако C++ запрещает дочерним классам инициализировать наследуемые переменные-члены родительского класса в списке инициализации своего конструктора. Другими словами, значение переменной может быть задано только в списке инициализации конструктора, принадлежащего тому же классу, что и переменная-член<a href="source.html#metka1">[1]</a>.</p>
<p>Это связано с константными переменными и ссылками. Например, чтобы произошло бы, если бы m_id был const. Поскольку константы должны быть инициализированы значениями при создании, то конструктор родительского класса должен установить это значение при создании переменной-члена. В то же время конструктор дочернего класса выполняется только после выполнения конструкторов родительского класса. Каждый дочерний класс имел бы тогда возможность инициализировать эту переменную, потенциально изменяя её значение. Ограничивая инициализацию переменных конструктором класса, к которому принадлежат эти переменные, язык C++ гарантирует, что все переменные будут инициализированы только один раз.</p>
<p>Конечным результатом выполнения кода, приведенного выше, является ошибка, так как m_id унаследован от класса Parent, а только ненаследуемые переменные-члены могут быть изменены в списке инициализации конструктора класса Child.</p>
<p>Однако наследуемые переменные могут по-прежнему изменять свои значения в теле конструктора через операцию присваивания. Следовательно, новички часто пытаются сделать следующее:</p>
<pre class="cpp-code"><code class="language-cpp">
class Child: public Parent
{
public:
    double m_value;
     Child(double value=0.0, int id=0)
        : m_value(value)
    {
        m_id = id;
    }
     double getValue() const { return m_value; }
};
</code></pre>
<p>Хотя подобное действительно сработает в данном случае, но это не сработает, если m_id будет константой или ссылкой (поскольку константы и ссылки должны быть инициализированы в списке инициализации конструктора). Кроме того, это неэффективно, так как для m_id присваивают значение дважды: первый раз в списке инициализации конструктора класса Parent, а затем в теле конструктора класса Child. И, наконец, что, если классу Parent необходим доступ к этому значению во время инициализации.</p>
<p>Итак, как правильно инициализировать m_id при создании объекта класса Child. Во всех описанных примерах, при создании объекта класса Child, вызывался конструктор по умолчанию класса Parent. Потому что не указывалось иначе.</p>
<p>Язык C++ предоставляет возможность явно выбирать конструктор класса Parent для выполнения инициализации части Parent. Для этого необходимо  добавить вызов нужного нам конструктора в списке инициализации конструктора дочернего класса.</p>

<pre class="cpp-code"><code class="language-cpp">
class Child: public Parent
{
public:
    double m_value;
 
    Child(double value=0.0, int id=0)
        : Parent(id), // вызывается конструктор Parent(int) со значением id!
            m_value(value)
    {
    }
    double getValue() const { return m_value; }
};
</code></pre>

<p>Теперь при выполнении следующего кода конструктор Parent(int) будет использоваться для инициализации m_id значением 7, а конструктор дочернего класса будет использоваться для инициализации m_value значением 1.5.</p>
<pre class="cpp-code"><code class="language-cpp">
    int main()
{
    Child child(1.5, 7); // вызывается конструктор Child(double, int)
    cout << "ID: " << child.getId() << '\n';
    cout << "Value: " << child.getValue() << '\n';
    return 0;
}
</code></pre>
<p>Результат выполнения программы представлен на рисунке 10.21.</p>
<p class="photo"><img src="./img/10_chapter/10.21.jpg" alt=""></p>
<p class="signature">Рисунок 10.21 &#8211; Инициализация дочерних классов</p>

<p>В данном примере происходит выполнение следующих шагов:
<br>- Выделяется память для объекта child.
<br>- Вызывается конструктор Child(double, int), где value = 1.5, а id = 7.
<br>- Компилятор смотрит, запрашиваем ли мы какой-нибудь конкретный конструктор класса Parent. И видит, что запрашиваеncя Поэтому вызывается Parent(int) с параметром id, которому мы до этого присвоили значение 7.
<br>- Список инициализации конструктора класса Parent присваивает для m_id значение 7.
<br>- Выполняется тело конструктора класса Parent, которое ничего не делает.
<br>- Завершается выполнения конструктора класса Parent.
<br>- Список инициализации конструктора класса Child присваивает для m_value значение 1.5.
<br>- Выполняется тело конструктора класса Child, которое ничего не делает.
<br>- Завершается выполнения конструктора класса Child.
</p>
<p>Следует обратить внимание что, не имеет значения, где в списке инициализации конструктора класса Child вызывается конструктор класса Parent - он всегда будет выполняться первым.</p>
<p>Теперь после инициализации членов родительского класса, нет никакой необходимости сохранять переменные-члены открытыми. Они сделаны private.</p>
<p>Доступ к членам public открыт для всех. Доступ к членам private открыт только для других членов этого же класса. Следует обратить внимание на то, что дочерние классы не могут напрямую обращаться к закрытым членам родительского класса. Дочерним классам нужно использовать геттеры и сеттеры для доступа к этим членам.</p>
<p>Например, далее представлен код программы, в котором  m_id и m_value были сделаны закрытыми. Для их инициализации используются соответствующие конструкторы, а для доступа - открытые функции доступа (геттеры).</p>
<pre class="cpp-code"><code class="language-cpp">
#include &ltiostream>
using namespace std;
 class Parent
{
private: // наш m_id теперь закрытый
    int m_id;
 public:
    Parent(int id=0)
        : m_id(id)
    {
    }
     int getId() const { return m_id; }
};
class Child: public Parent
{
private: // наш m_value теперь закрытый
    double m_value;
 public:
    Child(double value=0.0, int id=0)
        : Parent(id), // вызывается конструктор Parent(int) со значением id!
            m_value(value)
    {
    }
     double getValue() const { return m_value; }
};
 int main()
{
    Child child(1.5, 7); // вызывается конструктор Child(double, int)
    cout << "ID: " << child.getId() << '\n';
    cout << "Value: " << child.getValue() << '\n';
     return 0;
}
</code></pre>
<p>Результат выполнения программы представлен на рисунке 10.22.</p>
<p class="photo"><img src="./img/10_chapter/10.21.jpg" alt=""></p>
<p class="signature">Рисунок 10.22 &#8211; Работа с конструкторами дочерних классов</p>
<p>Стоит отметить, что конструкторы дочернего класса могут вызывать конструкторы только того родительского класса, от которого они напрямую наследуют. При уничтожении дочернего класса, каждый <a href="glossary.html#m5">деструктор</a> вызывается в порядке обратном построению классов. </p>
<p>Таким образом, при инициализации объектов дочернего класса, конструктор дочернего класса отвечает за то, какой конструктор родительского класса вызывать. Если этот конструктор явно не указан, то вызывается конструктор по умолчанию родительского класса. Если же компилятор не может найти конструктор по умолчанию родительского класса, то компилятор выдаст ошибку  <a href="source.html#metka25">[25]</a>.</p>


<br><br><h3 id="10.10.5">10.10.5 Указатели, ссылки и дочерние классы </h3>
<p>Как известно,  при создании объекта дочернего класса выполняется построение 2-х частей, из которых этот объект и состоит: родительская и дочерняя  <a href="source.html#metka25">[25]</a>. Например, далее приведён код. В данном примере при создании объекта класса Child сначала выполняется построение части Parent, а затем уже части Child. Следует помнить, что тип отношений в наследовании - «является». Поскольку Child «является» Parent, то логично, что Child содержит часть Parent.</p>
<pre class="cpp-code"><code class="language-cpp">
class Parent
{
protected:
    int m_value;
 public:
    Parent(int value)
        : m_value(value)
    {
    }
     const char* getName() { return "Parent"; }
    int getValue() { return m_value; }
};
 class Child: public Parent
{
public:
    Child(int value)
        : Parent(value)
    {
    }
    const char* getName() { return "Child"; }
    int getValueDoubled() { return m_value * 2; }
};
</code></pre>
<p>Можно дать команду указателям и ссылкам класса Child указывать на другие объекты класса Child.</p>
<pre class="cpp-code"><code class="language-cpp">
#include &ltiostream>
using namespace std;
 int main()
{
    Child child(7);
    cout << "child is a " << child.getName() << " and has value " << child.getValue() << '\n';
     Child &rChild = child;
    cout << "rChild is a " << rChild.getName() << " and has value " << rChild.getValue() << '\n';
     Child *pChild = &child;
    cout << "pChild is a " << pChild->getName() << " and has value " << pChild->getValue() << '\n';
     return 0;
}
</code></pre>
<p>Тогда в результате выполнения данного кода на экран будет выведено следующее (рисунок 10.22).</p>
<p class="photo"><img src="./img/10_chapter/10.23.jpg" alt=""></p>
<p class="signature">Рисунок 10.23 &#8211; Ссылки и дочерние классы</p>

<p>Поскольку Child имеет часть Parent, то можно дать команду указателю или ссылке класса Parent указывать на объект класса Child.</p>
<pre class="cpp-code"><code class="language-cpp">
#include &ltiostream>
using namespace std;
 int main()
{
    Child child(7);
     // Всё корректно
    Parent &rParent = child;
    Parent *pParent = &child;
     cout << "child is a " << child.getName() << " and has value " << child.getValue() << '\n';
    cout << "rParent is a " << rParent.getName() << " and has value " << rParent.getValue() << '\n';
    cout << "pParent is a " << pParent->getName() << " and has value " << pParent->getValue() << '\n';
     return 0;
}
</code></pre>
<p>Результат выполнения данного кода на экран будет выведено следующее (рисунок 10.23).</p>
<p class="photo"><img src="./img/10_chapter/10.24.jpg" alt=""></p>
<p class="signature">Рисунок 10.24 &#8211; Использование указателей на объект</p>

<p>Поскольку rParent и pParent являются ссылкой и указателем класса Parent, то они могут видеть только члены класса Parent. Таким образом, указатель/ссылка класса Parent не может увидеть Child::getName(). Следовательно, вызывается Parent::getName(), а rParent и pParent сообщают, что они относятся к классу Parent, а не к классу Child.</p>
<p>Следует обратить внимание, это также означает, что невозможно вызвать Child::getValueDoubled() через rParent или pParent. Они не могут видеть что-либо в классе Child.</p>
<p>Вот еще один более сложный пример работы с классом животные.</p>

<pre class="cpp-code"><code class="language-cpp">
#include &ltiostream> 
#include &ltstring>
using namespace std;
 class Animal
{
protected:
    string m_name;
     // Мы делаем этот конструктор protected так как не хотим, чтобы пользователи создавали объекты класса Animal напрямую,
    // но хотим, чтобы у дочерних классов доступ был открыт
    Animal(string name)
        : m_name(name)
    {
    }
 public:
    string getName() { return m_name; }
    const char* speak() { return "???"; }
};
 class Cat: public Animal
{
public:
    Cat(string name)
        : Animal(name)
    {
    }
     const char* speak() { return "Meow"; }
};
 
class Dog: public Animal
{
public:
    Dog(string name)
        : Animal(name)
    {
    }
     const char* speak() { return "Woof"; }
};
 int main()
{
    Cat cat("Matros");
    cout << "cat is named " << cat.getName() << ", and it says " << cat.speak() << '\n';
     Dog dog("Barsik");
    cout << "dog is named " << dog.getName() << ", and it says " << dog.speak() << '\n';
     Animal *pAnimal = &cat;
    cout << "pAnimal is named " << pAnimal->getName() << ", and it says " << pAnimal->speak() << '\n';
     pAnimal = &dog;
    cout << "pAnimal is named " << pAnimal->getName() << ", and it says " << pAnimal->speak() << '\n';
     return 0;
}
</code></pre>
<p>Результат выполнения программы представлен на рисунке 10.25.</p>
<p class="photo"><img src="./img/10_chapter/10.25.jpg" alt=""></p>
<p class="signature">Рисунок 10.25 &#8211; Работа с классом Animal</p>
<p>Как видно на рисунке 10.22 здесь присутствует таже самая проблема. Поскольку pAnimal является указателем типа Animal, то он может видеть только часть Animal. Следовательно, pAnimal->speak() вызывает Animal::speak(), а не Dog::Speak() или Cat::speak().</p>
<p>Почему необходимо использовать указатель или ссылку родительского класса на объект дочернего класса, если можно просто использовать дочерний объект. Для их использования есть несколько веских причин.</p>
<p>Во-первых, предположим, что необходимо написать функцию, которая выводит имя и звук животного. Без использования указателя на родительский класс,  придется реализовать это через перегрузку функций. Например:</p>
<pre class="cpp-code"><code class="language-cpp">
    void report(Cat &cat)
{
    cout << cat.getName() << " says " << cat.speak() << '\n';
}
 void report(Dog &dog)
{
    cout << dog.getName() << " says " << dog.speak() << '\n';
}
</code></pre>
<p>Не слишком сложно, но если необходимо описать 30 разных типов животных, тогда бы пришлось бы написать 30 перегрузок. Кроме того, если  когда-либо добавить новый тип животных, то также придется написать новую функцию для этого типа животных. </p>
<p>Однако, поскольку Cat и Dog наследуют Animal, Cat и Dog имеют часть Animal, поэтому можно сделать следующее.</p>

<pre class="cpp-code"><code class="language-cpp">
    void report(Animal &rAnimal)
{
    cout << rAnimal.getName() << " says " << rAnimal.speak() << '\n';
}
</code></pre>
<p>Это позволит передавать любой класс, который является дочерним классу Animal. Вместо отдельного метода на каждый дочерний класс записан один метод, который работает сразу со всеми дочерними классами.</p>
<p>Проблема, конечно, в том, что, поскольку rAnimal является ссылкой класса Animal, то rAnimal.speak()вызовет Animal::speak() вместо метода speak() дочернего класса.</p>
<p>Во-вторых, если есть три кошки и три собаки, которых необходимо сохранить в массиве для легкого доступа к ним. Поскольку массивы могут содержать объекты только одного типа, то без указателей/ссылок на родительский класс, пришлось создавать отдельный массив для каждого дочернего класса. Например:</p>
<pre class="cpp-code"><code class="language-cpp">
#include &ltiostream>
using namespace std;
 int main()
{
    Cat cats[] = { Cat("Matros"), Cat("Ivan"), Cat("Martun") };
    Dog dogs[] = { Dog("Barsik"), Dog("Tolik"), Dog("Tyzik") };
     for (int iii=0; iii < 3; ++iii)
        cout << cats[iii].getName() << " says " << cats[iii].speak() << '\n';
     for (int iii=0; iii < 3; ++iii)
        cout << dogs[iii].getName() << " says " << dogs[iii].speak() << '\n';
     return 0;
}
</code></pre>
<p>Теперь если необходимо описать 30 разных типов животных, пришлось бы создать 30 массивов - по одному на каждый тип животного. Однако, поскольку Cat и Dog наследуют Animal, то можно сделать следующее.</p>
<pre class="cpp-code"><code class="language-cpp">
#include &ltiostream>
int main()
{
    Cat matros("Matros"), ivan("Ivan"), martun("Martun");
    Dog barsik("Barsik"), tolik("Tolik"), tyzik("Tyzik");
    // Создаем массив указателей на наши объекты Cat и Dog
    Animal *animals[] = { &matros, &ivan, &martun, &barsik, &tolik, &tyzik};
    for (int iii=0; iii < 6; ++iii)
        cout << animals[iii]->getName() << " says " << animals[iii]->speak() << '\n';
    return 0;
}
    </code></pre>
<p>Каждый элемент массива animals является указателем на Animal, означает, что animals[iii]->speak() будет вызывать Animal::speak(), вместо методов speak() дочерних классов. Данные примеры показали актуальность использования виртуальных функций.</p>

<br><br><h3 id="10.11">10.11 Полиморфизм</h3>
<p>Полиморфизм (polymorphism) (от греческого polymorphos) - это свойство, которое позволяет одно и то же имя использовать для решения двух или более схожих, но технически разных задач. Целью полиморфизма, применительно к объектно-ориентированному программированию, является использование одного имени для задания общих для класса действий. Выполнение каждого конкретного действия будет определяться типом данных. </p>
<p>В более общем смысле, концепцией полиморфизма является идея "один интерфейс, множество методов". Это означает, что можно создать общий интерфейс для группы близких по смыслу действий. </p>
<p>Полиморфизм – возможность объектов с одинаковым интерфейсом иметь различную реализацию. Язык программирования поддерживает полиморфизм, если классы с одинаковой спецификацией могут иметь различную реализацию (например, реализация класса может быть изменена в процессе наследования). Пояснение определению дает шуточное изображение на рисунке 10.25. Абстрактное животное имеет несколько предопределенных навыков («ходить» и «подавать голос»). Все «производные» животные обязаны также обладать этими навыками, но реализация и соответственно результат этих навыков может быть специфичным, как, например, команда «подать голос» у кота выдает «Мяу», а у козлика «Мее».</p>

<p class="photo"><img src="./img/10_chapter/10.26.jpg" alt=""></p>
<p class="signature">Рисунок 10.26 &#8211; Визуальное представление полиморфизма</p>
<p>Реализация полиморфизма базируется на использовании вирутальных функций.</p>

<br><br><h3 id="10.11.1">10.11.1 Виртуальные функции и полиморфизм</h3>
<p>Очень часто может возникать проблема, когда родительский указатель или ссылка вызывали только родительские методы, а не дочерние. Например:</p>
<pre class="cpp-code"><code class="language-cpp">
#include &ltiostream>
using namespace std;
 class Parent
{
public:
    const char* getName() { return "Parent"; }
};
 class Child: public Parent
{
public:
    const char* getName() { return "Child"; }
};
 int main()
{
    Child child;
    Parent &rParent = child;
    cout << "rParent is a " << rParent.getName() << '\n';
}
</code></pre>
<p>Результат представлен на рисунке 10.27.</p>
<p class="photo"><img src="./img/10_chapter/10.27.jpg" alt=""></p>
<p class="signature">Рисунок 10.27 &#8211; Работа с виртуальными функциями</p>
<p>Поскольку rParent является ссылкой класса Parent, то вызывается Parent::getName(), хотя фактически мы ссылаемся на часть Parent объекта child.</p>
<p>Можно решить эту проблему с помощью виртуальных функций. Виртуальная функция в языке С++ - это особый тип функции, которая, при её вызове, выполняет «наиболее» дочерний метод, который существует между родительским и дочерними классами. Это свойство еще известно, как полиморфизм. Дочерний метод вызывается тогда, когда совпадает сигнатура (имя, типы параметров и является ли метод константным) и тип возврата дочернего метода с сигнатурой и типом возврата метода родительского класса. </p>
<p>Такие методы называются переопределениями (или «переопределенными методами»).</p>
<p>Чтобы сделать функцию виртуальной, нужно просто указать ключевое слово virtual перед объявлением функции. Например:</p>
<pre class="cpp-code"><code class="language-cpp">
#include &ltiostream>
using namespace std;
 class Parent
{
public:
    virtual const char* getName() { return "Parent"; } // добавили ключевое слово virtual
};
 class Child: public Parent
{
public:
    virtual const char* getName() { return "Child"; }
};
 int main()
{
    Child child;
    Parent &rParent = child;
     cout << "rParent is a " << rParent.getName() << '\n';
     return 0;
}
</code></pre>
<p>Результат представлен на рисунке 10.28.</p>
<p class="photo"><img src="./img/10_chapter/10.28.jpg" alt=""></p>
<p class="signature">Рисунок 10.28 &#8211; Использование ключевого слова virtual</p>
<p>Поскольку rParent является ссылкой на родительскую часть объекта child, то, обычно, при обработкеrParent.getName() вызывался бы Parent::getName(). Тем не менее, поскольку Parent::getName() является виртуальной функцией, то компилятор понимает, что нужно посмотреть, есть ли переопределения этого метода в дочерних классах. И компилятор находит Child::getName()!</p>
<p>Рассмотрим пример посложнее:</p>
<pre class="cpp-code"><code class="language-cpp">
#include &ltiostream>
using namespace std;
class A
{
public:
    virtual const char* getName() { return "A"; }
};
class B: public A
{
public:
    virtual const char* getName() { return "B"; }
};
class C: public B
{public:
    virtual const char* getName() { return "C"; }
};
class D: public C
{
public:
    virtual const char* getName() { return "D"; }
};
 int main()
{
    C c;
    A &rParent = c;
    cout << "rParent is a " << rParent.getName() << '\n';
     return 0;
}
 </code></pre>
 <p>В результате выполнения какой будет выведен результат. Сначала создается объект с класса C. rParent - это ссылка класса A, которой указывается ссылаться на часть A объекта c.  Затем вызывается метод rParent.getName().</p>
  <p>Вызов rParent.GetName() приводит к вызову A::getName(). Однако, поскольку A::getName() является виртуальной функцией, то компилятор ищет «наиболее» дочерний метод между A и C. В этом случае - это C::getName().</p>
   <p>Следует обратить внимание на то, что компилятор не будет вызывать D::getName(), поскольку наш исходный объект был класса C, а не класса D, поэтому рассматриваются методы только между классами A и C.</p>
    <p>Результат выполнения программы будет выведено на экран (рисунок 10.29).</p>
    <p class="photo"><img src="./img/10_chapter/10.29.jpg" alt=""></p>
<p class="signature">Рисунок 10.29 &#8211; Использование ссылок на родительскую часть</p>


<br><br><h3 id="10.11.2">10.11.2 Использование конструктора protected</h3>
<p>Добавим тестовый код  в рассмотренный выше класс Animal. Создадим конструктор protected так, чтобы пользователи имели возможность создавать объекты класса Animal напрямую, но хотим, чтобы в дочерних классах доступ был открыт.</p>
<pre class="cpp-code"><code class="language-cpp">
#include &ltiostream>
#include &ltstring>
using namespace std;
 class Animal
{
protected:
    string m_name;
     // Мы делаем этот конструктор protected так как не хотим, чтобы пользователи имели возможность создавать объекты класса Animal напрямую,
    // но хотим, чтобы в дочерних классах доступ был открыт
    Animal(string name)
        : m_name(name)
    {
    }
 public:
    string getName() { return m_name; }
    const char* speak() { return "???"; }
};
 class Cat: public Animal
{
public:
    Cat(string name)
        : Animal(name)
    {
    }
     const char* speak() { return "Meow"; }
};
 class Dog: public Animal
{
public:
    Dog(string name)
        : Animal(name)
    {
    }
     const char* speak() { return "Woof"; }
};
 void report(Animal &animal)
{
    cout << animal.getName() << " says " << animal.speak() << '\n';
}
 int main()
{
    Cat cat("Matros");
    Dog dog("Barsik");
 
    report(cat);
    report(dog);
}
</code></pre>

<p>Результат выполнения программы представлен на рисунке 10.30.</p>
<p class="photo"><img src="./img/10_chapter/10.30.jpg" alt=""></p>
<p class="signature">Рисунок 10.30 &#8211; Использование конструктора protected</p>
<p>А теперь рассмотрим тот же класс, но сделав метод speak() виртуальным.</p>

<pre class="cpp-code"><code class="language-cpp">
#include &ltiostream>
#include &ltstring>
 class Animal
{
protected:
    string m_name;
     // Мы делаем этот конструктор protected так как не хотим, чтобы пользователи имели возможность создавать объекты класса Animal напрямую,
    // но хотим, чтобы в дочерних классах доступ был открыт
    Animal(std::string name)
        : m_name(name)
    {
    }
 public:
    string getName() { return m_name; }
    virtual const char* speak() { return "???"; }
};
 class Cat: public Animal
{
public:
    Cat(string name)
        : Animal(name)
    {
    }
     virtual const char* speak() { return "Meow"; }
};
 class Dog: public Animal
{
public:
    Dog(string name)
        : Animal(name)
    {
    }
     virtual const char* speak() { return "Woof"; }
};
 void report(Animal &animal)
{
    cout << animal.getName() << " says " << animal.speak() << '\n';
}
 int main()
{
    Cat cat("Matros");
    Dog dog("Barsik");
     report(cat);
    report(dog);
}   
</code></pre>
<p>Результат выполнения программы представлен на рисунке 10.31.</p>
<p class="photo"><img src="./img/10_chapter/10.31.jpg" alt=""></p>
<p class="signature">Рисунок 10.31 &#8211; Метод speak() стал виртуальным</p>
<p>При обработке animal.speak(), компилятор видит, что метод Animal::speak() является виртуальной функцией. Когда animal ссылается на часть Animal объекта cat, то компилятор просматривает все классы между Animal и Cat, чтобы найти наиболее дочерний метод speak(). И находит Cat::speak(). В случае, когдаanimal ссылается на часть Animal объекта dog, компилятор находит Dog::speak().</p>
<p>Следует обратить внимание, что мы не сделали Animal::GetName() виртуальной функцией. Это из-за того, что GetName() никогда не переопределяется ни в одном из дочерних классов, поэтому в этом нет необходимости.</p>
<p>Аналогично со следующим примером с массивом животных. </p>

<pre class="cpp-code"><code class="language-cpp">
    Cat matros("Matros"), ivan("Ivan"), martun("Martun");
Dog barsik("Barsik"), tolik("Tolik"), tyzik("Tyzik");
 // Создаем массив указателей на наши объекты Cat и Dog
Animal *animals[] = { &matros, &barsik, &ivan, &tolik, &martun, &tyzik};
for (int iii=0; iii < 6; ++iii)
    cout << animals[iii]->getName() << " says " << animals[iii]->speak() << '\n';
    </code></pre>
    <p>Результат выполнения программы представлен на рисунке 10.32.</p>
    <p class="photo"><img src="./img/10_chapter/10.32.jpg" alt=""></p>
<p class="signature">Рисунок 10.32 &#8211; Использование массива указателей</p>
<p>Несмотря на то, что эти два примера используют только классы Cat и Dog, любые другие дочерние классы также будут работать с нашей функцией report() и с массивом животных, без внесения дополнительных модификаций! Это, пожалуй, самое большое преимущество виртуальных функций - возможность структурировать код таким образом, чтобы новые дочерние классы автоматически работали со старым кодом, без необходимости внесения изменений со стороны программиста.</p>
<p>Если функция отмечена как виртуальная, то все соответствующие переопределения тоже считаются виртуальными, даже если возле них явно не указано ключевое слова virtual. Однако, наличие ключевого слова virtual возле методов дочерних классов послужит полезным напоминанием о том, что эти методы являются виртуальными, а не обычными. Следовательно, полезно указывать ключевое слово virtual возле переопределений в дочерних классах, даже если это не является строго необходимым.</p>
<!-- ----------------------------------------------------- -->
<!-- ----------------------------------------------------- -->
<!-- ----------------------------------------------------- -->





    <h3 id="10.12">10.12 Контрольные вопросы для закрепления изученного материала</h3>
    <ol>
        <li class="with-a-bracket">Что такое инкапсуляция, наследование и полиморфизм?</li>
        <li class="with-a-bracket">Что такое класс?</li>
        <li class="with-a-bracket">Опишите способы создания объектов класса в виде представления класса и через оператор
            new.
        </li>
        <li class="with-a-bracket">Как создаются приватные и публичные области при определении класса?</li>
        <li class="with-a-bracket">Как происходит обращение к методам и данным класса через объекты?</li>
    </ol>
</script>


<script id="page10.3" type="text/html">
    <TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0>
        <TR>
            <TD width="50%"><a name="3"></a>
                <HR>
                <div align=justify><h1>Тренировочные упражнения</h1></div>
  <form>
   <ol> 
    <li class="without-parentheses"> Соотнесите правильные варианты ответов определения основных элементов парадигмы объектно-ориентированного программирования. <br><br>
<table class="table_center">
    <tr>
        <td>
            <ul class="static_ul fd">
                <li>Инкапсуляция</li>
                <li>Наследование</li>
                <li>Полиморфизм</li>
            </ul>
        </td>
        <td>
            <ul class="droppable_ul1 droppable_ul glava10_ul" id="parent1">
            </ul>
            <ul class="droppable_ul2 droppable_ul glava10_ul" id="parent2">
            </ul>
            <ul class="droppable_ul3 droppable_ul glava10_ul" id="parent3">
            </ul>
        </td>
        <td>
            <ul class="draggable_ul drag_glava10">
                <li class="ufo draggable_li" id="ufo1" draggable="true">Возможность закрывать данные и методы класса от внешнего вмешательства</li>
                <li class="ufo2 draggable_li" id="ufo2" draggable="true">Образование новых классов на основе ранее созданных</li>
                <li class="ufo3 draggable_li" id="ufo3" draggable="true">Образование вызова методов базового класса из дочерних</li>
            </ul>
        </td>
    </tr>
</table><br><br>
 <input type="button" value="Ответить" onclick="provet()"></input>
 <input type="button" value ="Сбросить" onclick="provet_del()"></input>
    <br><br>
    <div id="resultat_2"></div>
              </li><br><br>


   <form>           
<li class="without-parentheses"> Заполните пропуски для объявления открытых / закрытых методов или данных класса в реализации объектно-ориентированном подходе языка С++.
	  <pre class="cpp-code"><code class="language-cpp">
#include &ltiostream>
using namespace std;
class Point{
<input type="text" id="glav10_2_1" size="3">: // объявление приватной области
    int x, y; //координата точки
<input type="text" id="glav10_2_2" size="3">: //объявление публичной области
    void setCoord(int pt_x, int pt_y){
        // метод класса, задающий координаты точки
        x = pt_x;
        y = pt_y;
    }
};
int main(){
    setlocale(LC_ALL, "rus");
    Point pt;
    pt.setCoord(2, 3);// 2 и 3 значения, передающиеся х и у
    Point* ptr = new Point();
    ptr->setCoord(3, 4);
}
</code></pre>
 <input type="button" value="Ответить" class="proverit_glav_10_2"></input>
              <input type="reset" value ="Очистить"></input>
              <br><br>
                 <div id="resultat_10_2"></div>
  </form>
</li><br><br>

  <form>           

           </ol>
 </HR></TD></TR></TABLE>
</script> 


<script id="page10.4" type="text/html">
    <TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0>
        <TR>
            <TD width="50%"><a name="3"></a>
                <HR>
                <div align=justify><h1 align="center">Тестирование по десятой главе</h1></div>
                <form name=test>
                    <ol>
                        <li>
                            <h4><input type=text name=T1 style="height: 15px; width:15px;" value=''> Класс &mdash; это:
                            </h4>
                            <input type=radio name=Q1> любой тип данных, определяемый пользователем;<br>
                            <input type=radio name=Q1> тип данных, определяемый пользователем и сочетающий в себе данные
                            и функции их обработки;<br>
                            <input type=radio name=Q1> структура, для которой в программе имеются функции работы с
                            нею;<br>
                            <input type=radio name=Q1> программа;<br>
                            <input type=radio name=Q1> тип данных, создаваемый программой.<br>
                            <br>
                        </li>
                        <li>
                            <h4><input type=text name=T2 style="height: 15px; width:15px;" value=''> Членами класса
                                могут быть:</h4>
                            <input type=radio name=Q2> как переменные, так и функции, могут быть объявлены как private и
                            как public;<br>
                            <input type=radio name=Q2> только переменные, объявленные как private;<br>
                            <input type=radio name=Q2> только функции, объявленные как private;<br>
                            <input type=radio name=Q2> только переменные и функции, объявленные как private;<br>
                            <input type=radio name=Q2> только переменные и функции, объявленные как public.<br>
                            <br>
                        </li>
                        <li>
                            <h4><input type=text name=T3 style="height: 15px; width:15px;" value=''> Что называется
                                конструктором?</h4>
                            <input type=radio name=Q3> метод, имя которого совпадает с именем класса и который
                            вызывается автоматически при создании объекта класса;<br>
                            <input type=radio name=Q3> метод, имя которого совпадает с именем класса и который
                            вызывается автоматически при объявлении класса (до создания объекта класса);<br>
                            <input type=radio name=Q3> метод, имя которого необязательно совпадает с именем класса и
                            который вызывается при создании объекта класса;<br>
                            <input type=radio name=Q3> метод, имя которого совпадает с именем класса и который
                            необходимо явно вызывать из головной программы при объявлении объекта класса;<br>
                            <input type=radio name=Q3> метод, имя которого не совпадает с именем класса и который
                            необходимо явно вызывать из головной программы при объявлении объекта класса.<br>
                            <br>
                        </li>
                        <li>
                            <h4><input type=text name=T4 style="height: 15px; width:15px;" value=''> Объект &mdash; это:
                            </h4>
                            <input type=radio name=Q4> переменная, содержащая указатель на класс;<br>
                            <input type=radio name=Q4> экземпляр класса;<br>
                            <input type=radio name=Q4> класс, который содержит в себе данные и методы их обработки;<br>
                            <input type=radio name=Q4> тип данных, определяемый пользователем;<br>
                            <input type=radio name=Q4> переменная, обозначающая процедуру.<br>
                            <br>
                        </li>
                        <li>
                            <h4><input type=text name=T5 style="height: 15px; width:15px;" value=''> Полиморфизм &mdash;
                                это:</h4>
                            <input type=radio name=Q5> средство, позволяющее использовать одно имя для обозначения
                            действий, общих для родственных классов;<br>
                            <input type=radio name=Q5> средство, позволяющее в одном классе использовать методы с
                            одинаковыми именами;<br>
                            <input type=radio name=Q5> средство, позволяющее в одном классе использовать методы с
                            разными именами для выполнения одинаковых действий;<br>
                            <input type=radio name=Q5> средство, позволяющее перегружать функции для работы с разными
                            типами или разным количеством аргументов;<br>
                            <input type=radio name=Q5> средство, позволяющее перегружать функции для работы с
                            одинаковыми типами или разным количеством аргументов.<br>
                            <br>
                        </li>
                        <li>
                            <h4><input type=text name=T6 style="height: 15px; width:15px;" value=''> Что называется
                                деструктором?</h4>
                            <input type=radio name=Q6> метод, который уничтожает объект;<br>
                            <input type=radio name=Q6> метод, который удаляет объект;<br>
                            <input type=radio name=Q6> метод, который освобождает память, занимаемую объектом;<br>
                            <input type=radio name=Q6> системная функция, которая освобождает память, занимаемую
                            объектом;<br>
                            <input type=radio name=Q6> метод, который создает объект.<br>
                            <br>
                        </li>
                        <li>
                            <h4><input type=text name=T7 style="height: 15px; width:15px;" value=''> Выберите правильное
                                объявление производного класса:</h4>
                            <input type=radio name=Q7> class MoreDetails:: Details;<br>
                            <input type=radio name=Q7> class MoreDetails: public class Details;<br>
                            <input type=radio name=Q7> class MoreDetails: public Details;<br>
                            <input type=radio name=Q7> class MoreDetails: class(Details);<br>
                            <input type=radio name=Q7> classMoreDetails(Details).<br>
                            <br>
                        </li>
                        <li>
                            <h4><input type=text name=T8 style="height: 15px; width:15px;" value=''> Шаблон функции
                                &mdash; это:</h4>
                            <input type=radio name=Q8> определение функции, в которой типу обрабатываемых данных
                            присвоено условное обозначение;<br>
                            <input type=radio name=Q8> прототип функции, в котором вместо имен параметров указан
                            условный тип;<br>
                            <input type=radio name=Q8> определение функции, в котором указаны возможные варианты типов
                            обрабатываемых параметров;<br>
                            <input type=radio name=Q8> определение функции, в котором в прототипе указан условный тип, а
                            в определении указаны варианты типов обрабатываемых параметров;<br>
                            <input type=radio name=Q8> прототип функции, в котором вместо имен параметров указаны все
                            возможные варианты типов.<br>
                            <br>
                        </li>
                        <li>
                            <h4><input type=text name=T9 style="height: 15px; width:15px;" value=''> Полиморфизм
                                реализован через механизмы:</h4>
                            <input type=radio name=Q9> перегрузки функций, виртуальных функций, шаблонов;<br>
                            <input type=radio name=Q9> перегрузки функций, наследования методов, шаблонов;<br>
                            <input type=radio name=Q9> наследования методов, виртуальных функций, шаблонов;<br>
                            <input type=radio name=Q9> перегрузки функций, наследования, виртуальных функций;<br>
                            <input type=radio name=Q9> использования шаблонов.<br>
                            <br>
                        </li>
                        <li>
                            <h4><input type=text name=T10 style="height: 15px; width:15px;" value=''> Выберите
                                правильный вариант выделения динамической памяти под переменную X типа float:</h4>
                            <input type=radio name=Q10> float *ptr = new float; X = *ptr;<br>
                            <input type=radio name=Q10> float &ptr = new float; X = &#38;ptr;<br>
                            <input type=radio name=Q10> float * ptr = &#38;X; X = new float;<br>
                            <input type=radio name=Q10> float &ptr = float; X = &#38;ptr;<br>
                            <input type=radio name=Q10> X = new float.<br>
                            <br>
                        </li>
                    </ol>
                    <div align="center">
                        <div>
                            <input type=button value="Показать результат" onClick="test1('MjExMjEzMzExMQ', 10)">
                        </div>
                        <div>
                            <textarea style="margin-top:6px" rows=5 cols="100%" name=s1></textarea>
                        </div>
                        <div>
                            <input type=reset value="Очистить выбранные пункты">
                        </div>
                        <br>
                        <Div align=center>
                            <a href="#3">В начало страницы</a>
                        </div>
                        <br>
                    </div>
                </form>
            </TD>
        </TR>
    </TABLE>
</script>

<!-- /page11 -->
<script id="page11" type="text/html">
    <TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0>
        <TR>
            <TD width="50%"><a name="3"></a>
                <HR>
                <div align=justify><h1 align="center">Итоговое тестирование</h1></div>
                <form name=test>
                    <ol>
                        <li class="without-parentheses"><h4><input type=text name=T1 style="height: 15px; width:15px;"
                                                                   value=''> Что такое алгоритм?
                        </h4>
                            <input type=radio name=Q1> совокупность чётко определенных действий, выполнение
                            которых ведёт к
                            решению задачи;<br>
                            <input type=radio name=Q1> последовательность действий, выполнение которых ведёт к
                            концу;<br>
                            <input type=radio name=Q1> набор определений и понятий, определенных в языке С++;<br>
                            <input type=radio name=Q1> повтор
                            действий, приводящих к решению задачи;<br>
                            <input type=radio name=Q1> нет верного ответа.<br>
                            <br>
                        </li>
                        <li>
                            <h4><input type=text name=T2 style="height: 15px; width:15px;" value=''> После компиляции
                                программы:</h4>
                            <input type=radio name=Q2> ее можно выполнять только с одним набором исходных
                            данных;<br>
                            <input type=radio name=Q2> перед каждым последующим запуском ее нужно перекомпилировать;<br>
                            <input type=radio name=Q2> ее можно выполнять многократно без перекомпиляции;<br>
                            <input type=radio name=Q2> можно запускать только .exe файл;<br>
                            <input type=radio name=Q2> нет верного ответа.<br>
                            <br>
                        </li>
                        <li>
                            <h4><input type=text name=T3 style="height: 15px; width:15px;" value=''> Оператор вывода
                                cout
                                может печатать несколько значений или переменных в одной команде, используя следующий
                                синтаксис:</h4>
                            <input type=radio name=Q3> cout << "Привет" + name + "n";<br>
                            <input type=radio name=Q3> cout << ("Привет" &name& "n");<br>
                            <input type=radio name=Q3> cout << "Привет" << name << "n";<br>
                            <input type=radio name=Q3> cout << "Привет;name;n);<br>
                            <input type=radio name=Q3> cout << "Привет", name, "n".<br>
                            <br>
                        </li>
                        <li>
                            <h4><input type=text name=T4 style="height: 15px; width:15px;" value=''> Какие
                                преобразования
                                типов данных невозможны без потери данных?</h4>
                            <input type=radio name=Q4> все перечисленные преобразования невозможны;<br>
                            <input type=radio name=Q4> char to float;<br>
                            <input type=radio name=Q4> float to int;<br>
                            <input type=radio name=Q4> string toint;<br>
                            <input type=radio name=Q4> int to float.<br>
                            <br>
                        </li>
                        <li>
                            <h4><input type=text name=T5 style="height: 15px; width:15px;" value=''> Логическая
                                операция с
                                большим приоритетом выполнения:</h4>
                            <input type=radio name=Q5> ||;<br>
                            <input type=radio name=Q5> !;<br>
                            <input type=radio name=Q5> &&;<br>
                            <input type=radio name=Q5> -;<br>
                            <input type=radio name=Q5> ==.<br>
                            <br>
                        </li>
                        <li>
                            <h4><input type=text name=T6 style="height: 15px; width:15px;" value=''> Отметьте верный
                                вариант
                                задания массива:</h4>
                            <input type=radio name=Q6> задается одномерный целочисленный массив числами int a;<br>
                            <input type=radio name=Q6> задается одномерный массив по:
                            <pre class="cpp-code"><code class="language-cpp">for (i = 0; i = i + 1){
    a[i] = i + 1;
}</code></pre>
                            <input type=radio name=Q6> задается одномерный целочисленный массив числами double a[4] = {
                            0.5, -2, 856, 1 };<br>
                            <input type=radio name=Q6> задается одномерный массив с клавиатуры
                            <pre class="cpp-code"><code class="language-cpp">for (i = 0; i < 4; i = i + 1){
    cin >> a[i];
}</code></pre>
                            <input type=radio name=Q6> задается одномерный массив с клавиатуры a [4] = {0.5, -2, 856, 1}<br>
                        </li>
                        <li>
                            <h4><input type=text name=T7 style="height: 15px; width:15px;" value=''> Сколько
                                размерностей
                                массива можно использовать в программах?</h4>
                            <input type=radio name=Q7> не более трех;<br>
                            <input type=radio name=Q7> можно использовать только многомерные массивы;<br>
                            <input type=radio name=Q7> до десяти, поскольку разработчики C++ посчитали это максимальным
                            допустимым значением;<br>
                            <input type=radio name=Q7> можно использовать только одномерные массивы;<br>
                            <input type=radio name=Q7> не ограничено.<br>
                            <br>
                        </li>
                        <li>
                            <h4><input type=text name=T8 style="height: 15px; width:15px;" value=''> В какой из
                                следующих
                                строк выполняется обращение к седьмому элементу массива, размер массива равен 10?</h4>
                            <input type=radio name=Q8> mas[6];<br>
                            <input type=radio name=Q8> mas[7];<br>
                            <input type=radio name=Q8> mas;<br>
                            <input type=radio name=Q8> mas(7);<br>
                            <input type=radio name=Q8> mas(n=10).<br>
                            <br>
                        </li>
                        <li>
                            <h4><input type=text name=T9 style="height: 15px; width:15px;" value=''> Какой порядковый
                                номер
                                последнего элемента массива, если размер массива 19?</h4>
                            <input type=radio name=Q9> порядковый номер определяется программистом;<br>
                            <input type=radio name=Q9> 19;<br>
                            <input type=radio name=Q9> 0;<br>
                            <input type=radio name=Q9> 18;<br>
                            <input type=radio name=Q9> 10.<br>
                            <br>
                        </li>
                        <li>
                            <h4><input type=text name=T10 style="height: 15px; width:15px;" value=''> Что производит
                                следующий фрагмент программы?</h4>
                            <pre class="cpp-code"><code class="language-cpp">for (int i = 0;  i < n; i++)
{
    cout << a[i] << ' ';
}</code></pre>
                            <input type=radio name=Q10> ввод элементов массива с клавиатуры;<br>
                            <input type=radio name=Q10> вывод элементов массива на экран монитора;<br>
                            <input type=radio name=Q10> ввод элементов массива из файла;<br>
                            <input type=radio name=Q10> вывод элементов массива в файла;<br>
                            <input type=radio name=Q10> нет верного ответа.<br>
                            <br>
                        </li>
                        <li>
                            <h4><input type=text name=T11 style="height: 15px; width:15px;" value=''> Словосочетание
                                "Hello
                                world!" может быть сохранено
                                в символьном массиве размером n элементов. Укажите, чему равно n?</h4>
                            <input type=radio name=Q11> 12;<br>
                            <input type=radio name=Q11> 10;<br>
                            <input type=radio name=Q11> 13;<br>
                            <input type=radio name=Q11> 11;<br>
                            <input type=radio name=Q11> 9.<br>
                            <br>
                        </li>
                        <li>
                            <h4><input type=text name=T12 style="height: 15px; width:15px;" value=''> Строковый тип
                                данных в
                                C++:</h4>
                            <input type=radio name=Q12> строки в C++ представляются как массивы элементов типа char,
                            заканчивающиеся терминатором строки &mdash; символом с нулевым значением '0';<br>
                            <input type=radio name=Q12> строки в C++ представляются как массивы элементов типа char,
                            заканчивающиеся терминатором строки &mdash; символом с нулевым значением (‘/0’);<br>
                            <input type=radio name=Q12> строки в C++ представляются как массивы элементов типа char,
                            заканчивающиеся терминатором строки &mdash; символом с нулевым значением (‘’);<br>
                            <input type=radio name=Q12> нет верного ответа;<br>
                            <input type=radio name=Q12> все ответы верны.<br>
                            <br>
                        </li>
                        <li>
                            <h4><input type=text name=T13 style="height: 15px; width:15px;" value=''> Допустим, есть
                                код:
                            </h4>
                            <pre class="cpp-code"><code class="language-cpp">char arr[8];
cin >> arr;</code></pre>
                            <h4><p>И в массив arr мы попытались записать следующий набор символов: «Hello World». Что в
                                действительности будет содержать массив arr?</p></h4>
                            <input type=radio name=Q13> Hello World;<br>
                            <input type=radio name=Q13> Другой ответ;<br>
                            <input type=radio name=Q13> Hello Wo;<br>
                            <input type=radio name=Q13> Hello W;<br>
                            <input type=radio name=Q13> Hello.<br>
                            <br>
                        </li>
                        <li>
                            <h4><input type=text name=T14 style="height: 15px; width:15px;" value=''> Какая функция
                                добавляет
                                одну строку к другой?</h4>
                            <input type=radio name=Q14> strcat();<br>
                            <input type=radio name=Q14> strcpy();<br>
                            <input type=radio name=Q14> atof();<br>
                            <input type=radio name=Q14> sprint();<br>
                            <input type=radio name=Q14> strcmp().<br>
                            <br>
                        </li>
                        <li>
                            <h4><input type=text name=T15 style="height: 15px; width:15px;" value=''> Какую библиотеку
                                необходимо подключить в код для работы со строками?</h4>
                            <input type=radio name=Q15> &ltchar&gt;<br>
                            <input type=radio name=Q15> &ltstring&gt;<br>
                            <input type=radio name=Q15> &ltrandom&gt;<br>
                            <input type=radio name=Q15> &ltwords&gt;<br>
                            <input type=radio name=Q15> &ltsentence&gt.<br>
                            <br>
                        </li>
                        <li>
                            <h4><input type=text name=T16 style="height: 15px; width:15px;" value=''> Укажите
                                зарезервированное ключевое слово для
                                высвобождения выделенной памяти:</h4>
                            <input type=radio name=Q16> delete;<br>
                            <input type=radio name=Q16> clear;<br>
                            <input type=radio name=Q16> remove;<br>
                            <input type=radio name=Q16> utilize;<br>
                            <input type=radio name=Q16> free.<br>
                            <br>
                        </li>
                        <li>
                            <h4><input type=text name=T17 style="height: 15px; width:15px;" value=''> Укажите
                                зарезервированное ключевое слово для
                                динамического выделения памяти:</h4>
                            <input type=radio name=Q17> value;<br>
                            <input type=radio name=Q17> new;<br>
                            <input type=radio name=Q17> create;<br>
                            <input type=radio name=Q17> creation;<br>
                            <input type=radio name=Q17> malloc.<br>
                            <br>
                        </li>
                        <li>
                            <h4><input type=text name=T18 style="height: 15px; width:15px;" value=''> Какой из видов
                                указателей описан в следующем коде?
                            </h4>
                            <pre class="cpp-code"><code class="language-cpp">typedef struct{
// объявление структуры
    char a;
    int b;
}
VAR;
VAR v = { '#', 5 };   // присвоение значений структуре
VAR* p = &#38;v;        // указателю p присваивается адрес структуры
cout << (*p).a << " " << (*p).b << endl;</code></pre>
                            <input type=radio name=Q18> указатель на строки;<br>
                            <input type=radio name=Q18> указатель на функцию;<br>
                            <input type=radio name=Q18> указатель на массив;<br>
                            <input type=radio name=Q18> указатель на переменную;<br>
                            <input type=radio name=Q18> указатель на структуру.<br>
                            <br>
                        </li>
                        <li>
                            <h4><input type=text name=T19 style="height: 15px; width:15px;" value=''> Пример: val =
                                *ptr;
                                операция косвенной адресации * производит:</h4>
                            <input type=radio name=Q19> получение адреса;<br>
                            <input type=radio name=Q19> перенаправление адреса переменной val к переменной ptr;<br>
                            <input type=radio name=Q19> определение значения, на которое указывает ptr;<br>
                            <input type=radio name=Q19> определение значения, на которое указывает val;<br>
                            <input type=radio name=Q19> нет правильного варианта.<br>
                            <br>
                        </li>
                        <li>
                            <h4><input type=text name=T20 style="height: 15px; width:15px;" value=''> Выберите вариант
                                ответа, где представлена ссылка на объект типа T:</h4>
                            <input type=radio name=Q20> T& r;<br>
                            <input type=radio name=Q20> T* p;<br>
                            <input type=radio name=Q20> T a[n];<br>
                            <input type=radio name=Q20> все варианты верны;<br>
                            <input type=radio name=Q20> нет правильного ответа.<br>
                            <br>
                        </li>
                        <li>
                            <h4><input type=text name=T21 style="height: 15px; width:15px;" value=''> Если в функции на
                                языке
                                С++ отсутствует оператор
                                return, то такая функция:</h4>
                            <input type=radio name=Q21> не будет возвращать значения;<br>
                            <input type=radio name=Q21> будет возвращать значение 1;<br>
                            <input type=radio name=Q21> будет возвращать значение 0;<br>
                            <input type=radio name=Q21> будет возвращать значение 10;<br>
                            <input type=radio name=Q21> нет верного ответа.<br>
                            <br>
                        </li>
                        <li>
                            <h4><input type=text name=T22 style="height: 15px; width:15px;" value=''> Прототипом функции
                                называется?</h4>
                            <input type=radio name=Q22> словесное описание действий функции;<br>
                            <input type=radio name=Q22> перечень переменных, объявленных в функции;<br>
                            <input type=radio name=Q22> заголовок функции без ее тела, оканчивающийся символом ‘;’;<br>
                            <input type=radio name=Q22> вложенная функция;<br>
                            <input type=radio name=Q22> нет верного ответа.<br>
                            <br>
                        </li>
                        <li>
                            <h4><input type=text name=T23 style="height: 15px; width:15px;" value=''> Перегруженные
                                функции
                                применяются тогда, когда:</h4>
                            <input type=radio name=Q23> необходимо смоделировать вложенность функций;<br>
                            <input type=radio name=Q23> функция должна выполнять различные действия в зависимости от
                            типа
                            и
                            количества ее параметров;<br>
                            <input type=radio name=Q23> нужно объявить глобальную функцию;<br>
                            <input type=radio name=Q23> когда работают с рекурсией;<br>
                            <input type=radio name=Q23> нет верного ответа.<br>
                            <br>
                        </li>
                        <li>
                            <h4><input type=text name=T24 style="height: 15px; width:15px;" value=''> Выберите ложное
                                утверждение:</h4>
                            <input type=radio name=Q24> локальные переменные существуют только во время выполнения
                            функции;<br>
                            <input type=radio name=Q24> для параметров, передаваемых по значению, в стеке создается их
                            копия;<br>
                            <input type=radio name=Q24> функция может возвращать значение стандартного типа;<br>
                            <input type=radio name=Q24> компилятор инициализирует нулями локальные переменные;<br>
                            <input type=radio name=Q24> нет правильных утверждений.<br>
                            <br>
                        </li>
                        <li>
                            <h4><input type=text name=T25 style="height: 15px; width:15px;" value=''> Величины,
                                описанные
                                внутри функции, а также ее параметры, являются:</h4>
                            <input type=radio name=Q25> глобальные;<br>
                            <input type=radio name=Q25> локальные;<br>
                            <input type=radio name=Q25> статические величины;<br>
                            <input type=radio name=Q25> нет правильного ответа;<br>
                            <input type=radio name=Q25> переменные области класса.<br>
                            <br>
                        </li>
                        <li>
                            <h4><input type=text name=T26 style="height: 15px; width:15px;" value=''> Укажите правильное
                                обращение к полям структуры: structcoord{int x; int z;}data;:</h4>
                            <input type=radio name=Q26> data.x; data.z;<br>
                            <input type=radio name=Q26> coord.x; coord.z;<br>
                            <input type=radio name=Q26> coord.x; data.z;<br>
                            <input type=radio name=Q26> data.y;<br>
                            <input type=radio name=Q26> data x; cord x.<br>
                            <br>
                        </li>
                        <li>
                            <h4><input type=text name=T27 style="height: 15px; width:15px;" value=''> Какие ограничения
                                налагаются на объединения?</h4>
                            <input type=radio name=Q27> объединение не может содержать битовые поля;<br>
                            <input type=radio name=Q27> объединение не может входить в иерархию классов;<br>
                            <input type=radio name=Q27> объединение может инициализироваться только значением его
                            первого
                            элемента;<br>
                            <input type=radio name=Q27> объединение не может содержать виртуальные методы, конструкторы,
                            деструкторы и операцию присваивания;<br>
                            <input type=radio name=Q27> все перечисленное.<br>
                            <br>
                        </li>
                        <li>
                            <h4><input type=text name=T28 style="height: 15px; width:15px;" value=''> Элементы структур
                                располагаются в памяти компьютера:</h4>
                            <input type=radio name=Q28> последовательно, один за другим;<br>
                            <input type=radio name=Q28> начинаясь с одного адреса памяти, перекрывая друг друга;<br>
                            <input type=radio name=Q28> только на жестком диске;<br>
                            <input type=radio name=Q28> только в оперативной памяти;<br>
                            <input type=radio name=Q28> нет правильного ответа.<br>
                            <br>
                        </li>
                        <li>
                            <h4><input type=text name=T29 style="height: 15px; width:15px;" value=''> В каком из
                                следующих
                                вариантов ответов выполнен корректный доступ к переменной структуры, причём структура
                                объявлена через указатель?</h4>
                            <input type=radio name=Q29> b->var;<br>
                            <input type=radio name=Q29> b>var;<br>
                            <input type=radio name=Q29> b.var;<br>
                            <input type=radio name=Q29> b-var;<br>
                            <input type=radio name=Q29> нет верного ответа.<br>
                            <br>
                        </li>
                        <li>
                            <h4><input type=text name=T30 style="height: 15px; width:15px;" value=''> Выберите
                                правильное
                                определение структуры в С++:</h4>
                            <input type=radio name=Q30> struct a_struct int a;<br>
                            <input type=radio name=Q30> struct {int a;};<br>
                            <input type=radio name=Q30> structure a;<br>
                            <input type=radio name=Q30> struct a_struct {int a;};<br>
                            <input type=radio name=Q30> struct a_struct {}.<br>
                            <br>
                        </li>
                        <li>
                            <h4><input type=text name=T31 style="height: 15px; width:15px;" value=''> Линейный список, в
                                котором доступен только последний элемент, называется:</h4>
                            <input type=radio name=Q31> стеком;<br>
                            <input type=radio name=Q31> очередью;<br>
                            <input type=radio name=Q31> деком;<br>
                            <input type=radio name=Q31> массивом;<br>
                            <input type=radio name=Q31> кольцом.<br>
                            <br>
                        </li>
                        <li>
                            <h4><input type=text name=T32 style="height: 15px; width:15px;" value=''> На что должны быть
                                объявлены указатели в линейном списке?</h4>
                            <input type=radio name=Q32> head, tail;<br>
                            <input type=radio name=Q32> head body;<br>
                            <input type=radio name=Q32> header footer;<br>
                            <input type=radio name=Q32> left right.<br>
                            <input type=radio name=Q32> нет верного ответа.<br>
                            <br>
                        </li>
                        <li>
                            <h4><input type=text name=T33 style="height: 15px; width:15px;" value=''> Как объявить
                                вектор
                                элементов целых чисел?</h4>
                            <input type=radio name=Q33> std::vector&lt;int&gt; myVector;<br>
                            <input type=radio name=Q33> std::vector(int) myVector;<br>
                            <input type=radio name=Q33> std::vector integer myVector;<br>
                            <input type=radio name=Q33> int vector myVector;<br>
                            <input type=radio name=Q33> нет верного ответа.<br>
                            <br>
                        </li>
                        <li>
                            <h4><input type=text name=T34 style="height: 15px; width:15px;" value=''> Какое правильное
                                объявление списка на C++?</h4>
                            <input type=radio name=Q34> List&lt;string&gt; list =new List&lt;string&gt;();<br>
                            <input type=radio name=Q34>
                            <pre class="cpp-code"><code class="language-cpp">struct Node{
   float data; // Данные.
   Node *Next, *Prev; // Указатели на следующий и предыдущий элементы.
};</code></pre>
                            <input type=radio name=Q34> LinkedList list = List.CreateList();<br>
                            <input type=radio name=Q34> MakeList(*tail, *head);<br>
                            <input type=radio name=Q34> нет верного ответа.<br>
                            <br>
                        </li>
                        <li>
                            <h4><input type=text name=T35 style="height: 15px; width:15px;" value=''> Какое значение
                                будет напечатано?</h4>
                            <pre class="cpp-code"><code class="language-cpp">#include &ltiostream&gt;
const int x = 12;
int main (intargc, char **argv){
    enum dog{
        x = x,
        y
    };
    std::cout << y << std::endl;
    return 0;
}</code></pre>
                            <input type=radio name=Q35> неопределенное;<br>
                            <input type=radio name=Q35> 12;<br>
                            <input type=radio name=Q35> 0;<br>
                            <input type=radio name=Q35> 13;<br>
                            <input type=radio name=Q35> 11.<br>
                            <br>
                        </li>
                        <li>
                            <h4><input type=text name=T36 style="height: 15px; width:15px;" value=''> В результате
                                выполнения программы</h4>
                            <pre class="cpp-code"><code class="language-cpp">FILE *f1;
f1=fopen("data.txt", "rt");</code></pre>
                            <input type=radio name=Q36> файл data.txt будет открыт на чтение и запись в текстовом
                            режиме;<br>
                            <input type=radio name=Q36> файл data.txt будет открыт на чтение в текстовом режиме;<br>
                            <input type=radio name=Q36> файл data.txt будет открыт на чтение в двоичном режиме;<br>
                            <input type=radio name=Q36> файл data.txt будет открыт на чтение и запись в двоичном
                            режиме;<br>
                            <input type=radio name=Q36> ничего из вышеперечисленного.<br>
                            <br>
                        </li>
                        <li>
                            <h4><input type=text name=T37 style="height: 15px; width:15px;" value=''> С помощью функции
                                fopen( ) можно открыть файл:</h4>
                            <input type=radio name=Q37> только в текстовом режиме;<br>
                            <input type=radio name=Q37> только в двоичном режиме;<br>
                            <input type=radio name=Q37> в двоичном или текстовом режиме;<br>
                            <input type=radio name=Q37> ничего из вышеперечисленного;<br>
                            <input type=radio name=Q37> только на удаление.<br>
                            <br>
                        </li>
                        <li>
                            <h4><input type=text name=T38 style="height: 15px; width:15px;" value=''> В языке С++
                                программист может сам задавать положение файлового указателя места. Это делается
                                функцией:</h4>
                            <input type=radio name=Q38> setfile( );<br>
                            <input type=radio name=Q38> fpointer( );<br>
                            <input type=radio name=Q38> fseek( );<br>
                            <input type=radio name=Q38> settxt;<br>
                            <input type=radio name=Q38> ничего из вышеперечисленного.<br>
                            <br>
                        </li>
                        <li>
                            <h4><input type=text name=T39 style="height: 15px; width:15px;" value=''> Процедура открытия
                                файла заключается в:</h4>
                            <input type=radio name=Q39> создании переменной типа FILE;<br>
                            <input type=radio name=Q39> блокировке операций с файлом со стороны других приложений;<br>
                            <input type=radio name=Q39> создании переменной типа FILE и связывании ее с конкретным
                            файлом
                            на диске;<br>
                            <input type=radio name=Q39> создании переменной типа fstream;<br>
                            <input type=radio name=Q39> создании переменной типа ofstream.<br>
                            <br>
                        </li>
                        <li>
                            <h4><input type=text name=T40 style="height: 15px; width:15px;" value=''> Укажите класс,
                                который реализует получение информации о файле в C++:</h4>
                            <input type=radio name=Q40> fileInfo;<br>
                            <input type=radio name=Q40> dataInfo;<br>
                            <input type=radio name=Q40> fileDescription;<br>
                            <input type=radio name=Q40> fileProperties;<br>
                            <input type=radio name=Q40> objInfo.<br>
                            <br>
                        </li>
                        <li>
                            <h4><input type=text name=T41 style="height: 15px; width:15px;" value=''> Обработчик события
                                OnDblClick задает:</h4>
                            <input type=radio name=Q41> функцию, вызываемую при одном щелчке мышью на компоненте;<br>
                            <input type=radio name=Q41> функцию, вызываемую при двойном щелчке мышью на компоненте;<br>
                            <input type=radio name=Q41> функцию, вызываемую при одном нажатии клавиши на клавиатуре;<br>
                            <input type=radio name=Q41> функцию, вызываемую при двойном нажатии клавиши на
                            клавиатуре;<br>
                            <input type=radio name=Q41> ничего из вышеперечисленного.<br>
                            <br>
                        </li>
                        <li>
                            <h4><input type=text name=T42 style="height: 15px; width:15px;" value=''> Функция,
                                вызываемая
                                при отпускании клавиши на клавиатуре, задается в обработчике события:</h4>
                            <input type=radio name=Q42> OnKeyDown;<br>
                            <input type=radio name=Q42> OnKeyUp;<br>
                            <input type=radio name=Q42> OnClick;<br>
                            <input type=radio name=Q42> KeyUp;<br>
                            <input type=radio name=Q42> MouseClick.<br>
                            <br>
                        </li>
                        <li>
                            <h4><input type=text name=T43 style="height: 15px; width:15px;" value=''> Свойство Height
                                визуальных компонентов задает:</h4>
                            <input type=radio name=Q43> ширину компонента;<br>
                            <input type=radio name=Q43> высоту компонента;<br>
                            <input type=radio name=Q43> цвет компонента;<br>
                            <input type=radio name=Q43> расположение относительно оси X;<br>
                            <input type=radio name=Q43> расположение относительно оси Y.<br>
                            <br>
                        </li>
                        <li>
                            <h4><input type=text name=T44 style="height: 15px; width:15px;" value=''> Библиотека C++ для
                                визуального программирования называется:</h4>
                            <input type=radio name=Q44> MLM;<br>
                            <input type=radio name=Q44> MVC;<br>
                            <input type=radio name=Q44> MFC;<br>
                            <input type=radio name=Q44> .NET;<br>
                            <input type=radio name=Q44> JSF.<br>
                            <br>
                        </li>
                        <li>
                            <h4><input type=text name=T45 style="height: 15px; width:15px;" value=''> Свойство Left
                                визуальных компонентов задает:</h4>
                            <input type=radio name=Q45> ширину компонента;<br>
                            <input type=radio name=Q45> высоту компонента;<br>
                            <input type=radio name=Q45> цвет компонента;<br>
                            <input type=radio name=Q45> расположение относительно оси X;<br>
                            <input type=radio name=Q45> расположение относительно оси Y.<br>
                            <br>
                        </li>
                        <li>
                            <h4><input type=text name=T46 style="height: 15px; width:15px;" value=''> Класс &mdash; это:
                            </h4>
                            <input type=radio name=Q46> любой тип данных, определяемый пользователем;<br>
                            <input type=radio name=Q46> тип данных, определяемый пользователем и сочетающий в себе
                            данные
                            и функции их обработки;<br>
                            <input type=radio name=Q46> структура, для которой в программе имеются функции работы с
                            нею;<br>
                            <input type=radio name=Q46> программа;<br>
                            <input type=radio name=Q46> тип данных, создаваемый программой.<br>
                            <br>
                        </li>
                        <li>
                            <h4><input type=text name=T47 style="height: 15px; width:15px;" value=''> Выберите
                                правильный вариант выделения динамической памяти под переменную X типа float:</h4>
                            <input type=radio name=Q47> float *ptr = new float; X = *ptr;<br>
                            <input type=radio name=Q47> float &ptr = new float; X = &#38;ptr;<br>
                            <input type=radio name=Q47> float * ptr = &#38;X; X = new float;<br>
                            <input type=radio name=Q47> float &ptr = float; X = &#38;ptr;<br>
                            <input type=radio name=Q47> X = new float.<br>
                            <br>
                        </li>
                        <li>
                            <h4><input type=text name=T48 style="height: 15px; width:15px;" value=''> Членами класса
                                могут быть:</h4>
                            <input type=radio name=Q48> как переменные, так и функции, могут быть объявлены как private
                            и
                            как public;<br>
                            <input type=radio name=Q48> только переменные, объявленные как private;<br>
                            <input type=radio name=Q48> только функции, объявленные как private;<br>
                            <input type=radio name=Q48> только переменные и функции, объявленные как private;<br>
                            <input type=radio name=Q48> только переменные и функции, объявленные как public.<br>
                            <br>
                        </li>
                        <li>
                            <h4><input type=text name=T49 style="height: 15px; width:15px;" value=''> Полиморфизм
                                &mdash;
                                это:</h4>
                            <input type=radio name=Q49> средство, позволяющее использовать одно имя для обозначения
                            действий, общих для родственных классов;<br>
                            <input type=radio name=Q49> средство, позволяющее в одном классе использовать методы с
                            одинаковыми именами;<br>
                            <input type=radio name=Q49> средство, позволяющее в одном классе использовать методы с
                            разными именами для выполнения одинаковых действий;<br>
                            <input type=radio name=Q49> средство, позволяющее перегружать функции для работы с разными
                            типами или разным количеством аргументов;<br>
                            <input type=radio name=Q49> средство, позволяющее перегружать функции для работы с
                            одинаковыми типами или разным количеством аргументов.<br>
                            <br>
                        </li>
                        <li>
                            <h4><input type=text name=T50 style="height: 15px; width:15px;" value=''> Выберите
                                правильное
                                объявление производного класса:</h4>
                            <input type=radio name=Q50> class MoreDetails:: Details;<br>
                            <input type=radio name=Q50> class MoreDetails: public class Details;<br>
                            <input type=radio name=Q50> class MoreDetails: public Details;<br>
                            <input type=radio name=Q50> class MoreDetails: class(Details);<br>
                            <input type=radio name=Q50> classMoreDetails(Details).<br>
                            <br>
                        </li>
                    </ol>
                    <div align="center">
                        <div>
                            <input type=button value="Показать результат"
                                   onClick="test1('MTMxMzI0NTE0MjMyMTQyMTI1MzEzMzI0MjE1MTE0MTExMjQyMzMzMTIyMjM0MjExMTM=', 50)">
                        </div>
                        <div>
                            <textarea style="margin-top:6px" rows=5 cols="100%" name=s1></textarea>
                        </div>
                        <div>
                            <input type=reset value="Очистить выбранные пункты">
                        </div>
                        <br>
                        <Div align=center>
                            <a href="#3">В начало страницы</a>
                        </div>
                        <br>
                    </div>
                </form>
            </TD>
        </TR>
    </TABLE>
</script>

<!-- /other -->
<script id="page-conclusion" type="text/html">
    <h1>Заключение</h1>
    <p>Язык С++ &#8211; это компилируемый строго типизированный язык программирования общего назначения. Целью создания
        языка C++
        являлось развитие языка Cи возможностями, удобными для масштабной разработки прикладных программ.</p>
    <p>Как приемник языка Си, язык C++ широко используется в системном программировании. На языке пишутся
        высокоэффективные
        программы, операционные системы, драйверы и т. п. Также язык C++ является одним из основных языков,
        применяющихся
        при создании трансляторов. Помимо этого, язык C++ широко применяется при создании сложных, графических
        пользовательских интерфейсов.</p>
    <p>В данном электронном гиперссылочном учебном пособии рассмотрены различные инструменты для создания приложений с помощью языка высокого
        уровня
        С++, начиная от простейших программ структурного программирования и заканичивая обьектно-ориментированным
        подходом.</p>
    <p>В электронном гиперссылочном учебном пособии рассмотрены основы работы со средой MS Visual Studio, стандартные типы данных языка С++, массивы и
        строки в
        языке С++, работа с указателями. Также представлен материал по созданию пользовательских функции, описана работа
        с
        типами и структурами данных, динамическими структурами данных, файлами в языке С++.</p>
    <p>В ходе изучения электронного гиперссылочного учебного пособия студенты знакомятся с разработкой не только консольных приложений, но также
        реализуют работу с формами, создавая визуальные приложения. Помимо описанных инструментов структурного
        программирования, в заключительной главе студентам предоставляется материал по основам создания
        объектно-ориентированных приложений.</p>
    <p>В результате изучения данного учебного электронного гиперссылочного учебного пособия студенты смогут изучить возможности программирования на языке
        высокого
        уровня С++. Смогут самостоятельно разрабатывать и отлаживать программы в инструментальной среде Microsoft Visual
        Studio.</p>
</script>
<script id="page-glossary" type="text/html">
    <h1>Глоссарий</h1>
    <p><strong>Алгоритм</strong> &#8211; последовательность чётко определенных действий, выполнение которых ведёт к
        решению задачи;
        совокупность
        действий, приводящих к достижению результата за конечное число шагов.</p>
    <p><strong>Аргументы по умолчанию</strong> &#8211; такие аргументы, которым сразу присваивается некоторое значение,
        когда объявляется
        функция.</p>
    <p><strong>Бинарное дерево</strong> &#8211; иерархическая структура данных, в которой каждый узел имеет не более
        двух
        потомков (детей).</p>
    <p><strong>Вид</strong> &#8211; объекты классов, производные от CView (класс "вид") и определяющие методы обработки
        объектов класса документа.</p>
    <p><strong>Выпадающий список</strong> &#8211; элемент управления формы, помесь поля редактирования с окном-списком.
        Этот элемент содержит поле редактирование и список, который может отображаться все время либо «выпадать» при
        нажатии
        на кнопку рядом с полем редактирования.</p>
    <p><strong>Диалоговые окна</strong> &#8211; объекты классов, производные от CDialog. Классы CView, CFrameWnd,
        CDialog и
        все классы элементов управления наследуют свойства и поведение своего базового класса CWnd ("окно"),
        определяющего,
        по существу, Windows-окно.</p>
    <p><strong>Дек (deque &#8211; double ended queue)</strong> &#8211; структура данных, представляющая из себя список
        элементов,
        в которой добавление новых элементов и удаление существующих производится с обоих концов.</p>
    <p><strong>Дескриптор</strong> &#8211; ссылка на объект.</p>
    <p><strong>Деструктор</strong> &#8211; метод, который освобождает память, занимаемую объектом.</p>
    <p><strong>Детерминированность</strong> &#8211; свойство алгоритма, согласно которому любое действие алгоритма
        должно
        быть строго и недвусмысленно определено в каждом случае.</p>
    <p><strong>Дискретность </strong> &#8211; разбиение алгоритма на ряд отдельных законченных действий.</p>
    <p><strong>Индекс</strong> &#8211; номер элемента в массиве.</p>
    <p><strong>Инкапсуляция</strong> &#8211; возможность закрывать данные и методы класса от внешнего вмешательства.</p>
    <p><strong>Итерация</strong> &#8211; единичное выполнение тела цикла.</p>
    <p><strong>Класс</strong> &#8211; тип данных, определяемый пользователем и сочетающий в себе данные и функции их
        обработки.</p>
    <p><strong>Кнопка</strong> &#8211; небольшое прямоугольное дочернее окно, обычно имеющее два состояния:
        нажато/отпущено
        или включено/выключено.</p>
    <p><strong>Конечность</strong> &#8211; свойство алгоритма, согласно которому каждое действие в отдельности и
        алгоритм в
        целом должны иметь возможность завершения.</p>
    <p><strong>Константа</strong> &#8211; постоянная величина в ряду изменяющихся.</p>
    <p><strong>Конструктор</strong> &#8211; метод, имя которого совпадает с именем класса и который вызывается
        автоматически при создании объекта класса.</p>
    <p><strong>Линейный алгоритм </strong> &#8211; алгоритм, в котором действия выполняются однократно и строго
        последовательно.</p>
    <p><strong>Массив</strong> &#8211; пронумерованный набор однотипных элементов.</p>
    <p><strong>Массовость</strong> &#8211; свойство алгоритма, согласно которому один и тот же алгоритм можно
        использовать
        с разными исходными данными.</p>
    <p><strong>Методы класса</strong> &#8211; функции, которые определены внутри класса.</p>
    <p><strong>Наследование</strong> &#8211; образование новых классов на основе ранее созданных.</p>
    <p><strong>Нулевой указатель</strong> &#8211; указатель, хранящий специальное значение, показывающее, что данная
        переменная-указатель не ссылается (не указывает) ни на какой объект.</p>
    <p><strong>Объединение (union)</strong> &#8211; частный случай структуры, все поля которой располагаются по одному и
        тому же адресу.</p>
    <p><strong>Объект</strong> &#8211; экземпляр класса в объектно-ориентированном программировании.</p>
    <p><strong>Объектно-ориентированное программирование (ООП)</strong> &#8211; парадигма разработки программных систем,
        в
        которой приложения состоят из объектов.</p>
    <p><strong>Одномерный массив</strong> &#8211; массив с одним параметром, характеризующим количество элементов
        одномерного массива.</p>
    <p><strong>Окно-список</strong> &#8211; поле, используемое для отображения списка имен.</p>
    <p><strong>Оконная функция</strong> &#8211; это функция обратного вызова, предназначенная для обработки сообщений,
        адресованных окну того оконного класса, в котором содержится ссылка на данную процедуру.</p>
    <p><strong>Очередь</strong> &#8211; абстрактный тип данных, представляющий собой список элементов, организованных по
        принципу FIFO (англ. first in &#8211; first out, «первым пришёл &#8211; первым вышел»).</p>
    <p><strong>Переменная</strong> &#8211; именованная область памяти, в которой хранятся данные определенного типа.</p>
    <p><strong>Переменная цикла</strong> &#8211; величина, изменяющаяся на каждой итерации цикла.</p>
    <p><strong>Поле редактирования</strong> &#8211; поле, предназначенное для ввода пользователем текста с клавиатуры.
    </p>
    <p><strong>Полиморфизм</strong> &#8211; вызов методов базового класса из дочерних в объектно-ориентированном
        программировании.</p>
    <p><strong>Программа</strong> &#8211; алгоритм, записанный на языке машины для решения задачи.</p>
    <p><strong>Программная реализация алгоритма </strong> &#8211; компьютерная программа, написанная на каком-либо
        алгоритмическом языке программирования.</p>
    <p><strong>Прототип</strong> &#8211; запись функции без тела функции.</p>
    <p><strong>Разветвляющийся алгоритм</strong> &#8211; алгоритм, в котором в зависимости от условия выполняется либо
        одна, либо другая последовательность действий.</p>
    <p><strong>Результативность</strong> &#8211; свойство алгоритма, согласно которому алгоритм должен приводить к
        достоверному решению.</p>
    <p><strong>Рекурсивная функция</strong> &#8211; функция, которая вызывает саму себя.</p>
    <p><strong>Символ (символьная константа)</strong> &#8211; буква, цифра или любой другой изображаемый знак,
        заключенный
        в одинарные кавычки (апострофы).</p>
    <p><strong>Список</strong> &#8211; абстрактный тип данных, представляющий собой упорядоченный набор значений, в
        котором
        некоторое значение может встречаться более одного раза.</p>
    <p><strong>Статический текст</strong> &#8211; текстовое поле, окно или прямоугольник, используемый для надписей, не
        подлежащих редактированию.</p>
    <p><strong>Стек</strong> &#8211; абстрактный тип данных, представляющий собой список элементов, организованных по
        принципу LIFO (англ. last in &#8211; first out, «последним пришёл &#8211; первым вышел»).</p>
    <p><strong>Строка (строковая константа)</strong> &#8211; последовательность символов, заключенная в двойные кавычки.
    </p>
    <p><strong>Структура</strong> &#8211; объединенное в единое целое множество поименованных элементов (компонентов)
        данных разных типов.</p>
    <p><strong>Схема алгоритма</strong> &#8211; графическая реализация алгоритма, представляет собой удобный и наглядный
        способ записи алгоритма.</p>
    <p><strong>Счетчик цикла</strong> &#8211; переменная, в которой хранится количество проходов данного цикла.</p>
    <p><strong>Тело цикла</strong> &#8211; набор инструкций, предназначенный для многократного выполнения.</p>
    <p><strong>Указатель</strong> &#8211; некая переменная занимающая 4 байта в 32-разрядных операционных системах,
        диапазон значений которой состоит из адресов ячеек памяти или специального значения &#8211; нулевого адреса.</p>
    <p><strong>Условный оператор (оператор ветвления)</strong> &#8211; оператор, конструкция языка программирования,
        обеспечивающая выполнение определённой команды (набора команд) только при условии истинности некоторого
        логического
        выражения, либо выполнение одной из нескольких команд (наборов команд) в зависимости от значения некоторого
        выражения.</p>
    <p><strong>Уточненное имя</strong> &#8211; выражение с двумя операндами операцией доступа к элементам структуры
        ('точка') между ними.</p>
    <p><strong>Функции обратного вызова</strong> &#8211; это функции, которые вызывает сама операционная система.
        Компилятор определяет их по спецификатору CALLBACK.</p>
    <p><strong>Цикл</strong> &#8211; разновидность управляющей конструкции в высокоуровневых языках программирования,
        предназначенная для организации многократного исполнения набора инструкций.</p>
    <p><strong>Циклический алгоритм</strong> &#8211; алгоритм, команды которого повторяются некое количество раз подряд.
    </p>
    <p><strong>Шаг цикла</strong> &#8211; значение, на которое будет увеличиваться или уменьшаться счетчик цикла при
        каждом
        проход.</p>
    <p><strong>Язык С++</strong> &#8211; компилируемый строго типизированный язык программирования общего назначения.
    </p>
    <p><strong>API (Application Programming Interface)</strong> &#8211; программный интерфейс приложения, интерфейс
        прикладного программирования) &#8211; описание способов (набор классов, процедур, функций, структур или
        констант),
        которыми одна компьютерная программа может взаимодействовать с другой программой.</p>
    <p><strong>MFC (Microsoft Foundation Classes)</strong> &#8211; библиотека на языке C++, разработанная Microsoft и
        призванная облегчить разработку GUI-приложений для Microsoft Windows путём использования богатого набора
        библиотечных классов, библиотека классов, написанных на языке C++. MFC является оболочкой для Win32 API и
        содержит
        многоуровневую иерархию классов.</p>
    <p><strong>Microsoft Visual Studio</strong> &#8211; набор инструментов разработки, основанных на использовании
        компонентов и других технологий для создания мощных, производительных приложений.</p>
    <p><strong><a href="glossary.html#m12">Namespace</a>
</strong> &#8211; пространство имен, в котором находится класс.</p>
</script>
<script id="page-sources" type="text/html">
    <h1>Список использованных источников</h1>
    <ol class="sources_ol">
        <li class="with-a-bracket"> <a name="metka1">Павловская, Т. А. С/С++. Программирование на языке высокого уровня / Т. А.
            Павловская. -
            СПб.: Питер, 2004. – 461 с.</a>
        </li>
        <li class="with-a-bracket">Павловская, Т.А. С/С ++. Структурное программирование: Практикум / Т.А. Павловская,
            Ю. А.
            Щупак. - СПб.: Питер, 2007. - 239 с.: ил.
        </li>
        <li class="with-a-bracket">ГОСТ 19.701-90 (ИСО 5807-85) Единая система программной документации (ЕСПД). Схемы
            алгоритмов, программ, данных и систем. Обозначения условные и правила выполнения. Режим доступа:
            http://docs.cntd.ru/document/9041994.
        </li>
        <li class="with-a-bracket">Герберт, Шилдт: С++ базовый курс. / Герберт Шилдт. Режим доступа:
            https://www.bsuir.by/m/12_100229_1_98220.pdf.
        </li>
        <li class="with-a-bracket">Johnson, B Professional Visual Studio 2017 / B. Johnson. Изд.-во: Wrox 864 с.</li>
        <li class="with-a-bracket">Богуславский, А.А. Основы программирования на языке Си++. / А.А. Богуславский, С.М.
            Соколов Режим доступа: http://www.ict.edu.ru/ft/004246/cpp_p1.pdf.
        </li>
        <li class="with-a-bracket">Линский, Е. Основы C++. / Е. Линский. Режим доступа:
            https://www.lektorium.tv/lecture/13373.
        </li>
        <li class="with-a-bracket">Седжвик, Р. Фундаментальные алгоритмы на С++. Анализ/Структуры
            данных/Сортировка/Поиск:
            Пер. с англ. / Роберт Седжвик. - Киев: Издательство “Диасофт”, 2001. - 688с.
        </li>
        <li class="with-a-bracket">Сиддкхартха, Р. Освой самостоятельно С++ за 21 день. / Сиддкхартха, Р. - М.: SAMS,
            2013.
            - 651 с.
        </li>
        <li class="with-a-bracket">Стивен, П. Язык программирования С++. Лекции и упражнения: пер. с англ. / П. Стивен.
            6-е
            изд. - М.: ООО "И. Д. Вильямс", 2012. - 1248 с.
        </li>
        <li class="with-a-bracket">Страуструп, Б. Дизайн и эволюция языка С++. / Б. Страуструп. - М.: ДМК, 2000. - 448
            с.
        </li>
        <li class="with-a-bracket">Мейерс, С. Эффективное использование С++. / С. Мейерс. - М.: ДМК, 2000. - 240 с.</li>
        <li class="with-a-bracket">Страуструп, Б. Язык программирования С++. / Б. Страуструп. Режим доступа:
            http://8361.ru/6sem/books/Straustrup-Yazyk_programmirovaniya_c.pdf.
        </li>
        <li class="with-a-bracket">Страуструп, Б. Язык программирования С++. / Б. Страуструп. Режим доступа:
            http://8361.ru/6sem/books/Straustrup-Yazyk_programmirovaniya_c.pdf.
        </li>
        <li class="with-a-bracket">Керниган, Б., Язык программирования Си. / Б. Керниган, Д. Ритчи. Режим доступа:
            http://cpp.com.ru/kr_cbook/index.html.
        </li>
        <li class="with-a-bracket">Кольцов, Д. М. 100 примеров на Си. / Д. М. Кольцов. СПб.: “Наука и техника”, 2017 -
            256
            с.
        </li>
        <li class="with-a-bracket">Доусон, М. Изучаем С++ через программирование игр / М. Доусон. - СПб.: “Питер”, 2016.
            -
            352.
        </li>
        <li class="with-a-bracket">Черносвитов, А. Visual C++: руководство по практическому изучению / А. Черносвитов. -
            CПб.: Питер, 2002. - 528 с. : ил.
        </li>
        <li class="with-a-bracket">Варфоломеев, В.А. Обработка сообщений в ОС Windows. / И.И. Чиликни, В.А. Варфоломеев.
            Методические указания к лабораторным работам по дисциплине «Операционные системы». - М.: МИИТ, 2009 - 40 с.
        </li>
        <li class="with-a-bracket">Фролов А., Операционная система Microsoft Windows 3.1 для программиста / А. Фролов.,
            Г.
            Фролов. Том 12, М.: Диалог-МИФИ, 1993, 255 стр.
        </li>
        <li class="with-a-bracket">Безруков, В.А. Win32 API. / В.А. Безруков. Программирование /учебное пособие. – СПб:
            СПбГУ ИТМО, 2009. – 90 с.
        </li>
        <li class="with-a-bracket">Мешков, А.В. Visual C++ и MFC / Ю. В. Тихомиров, А.В. Мешков. - 2-е изд. - СПб.: БХВ
            -
            Санкт-Петербург, 1999. - 1040 с.
        </li>
        <li class="with-a-bracket">Бадд, Т. Объектно-ориентированное программирование в действии. - СПб: Питер, 1997. -
            464
            с.
        </li>
        <li class="with-a-bracket">Павловская, Т. А., C++. Объектно-ориентированное программирование: Практикум. / Т.А.
            Павловская, Ю. А. Щупак - СПб.: Питер, 2006. - 265 с: ил.
        </li>
        <li class="with-a-bracket">Лаптев, В. В. С ++. Объектно-ориентированное программирование: Учебное пособие. -
            СПб.:
            Питер, 2008. - 464 с.: ил.
        </li>
    </ol>
</script>
<script id="page-intro" type="text/html">
    <h1>Введение</h1>
    <p>
        Язык С++ &#8211; это компилируемый строго типизированный язык программирования общего назначения. Целью создания
        языка C++ являлось развитие языка Cи возможностями, удобными для масштабной разработки прикладных программ. При
        создании языка C++ разработчики стремились сохранить совместимость с существующим языком Cи 
        <a href="source.html#metka1">[1]</a>.
    </p>
    <p>
        Целью данного электронного гиперссылочного учебного пособия является обучение студентов современным языкам программирования высокого уровня
        на примере языка С++ методами и средствами разработки и отладки программ в инструментальной среде Microsoft
        Visual Studio.
    </p>
    <p>
        В электронном гиперссылочном учебном пособии представлен материал по изучению основ работы с инструментальной средой Microsoft Visual Studio,
        изучение конструкций языка программирования С++, приобретение навыков разработки и представления алгоритмов
        решения задач, овладение опытом создания программ с использованием процедурного и объектно-ориентированного
        подхода на основе разработанных алгоритмов, отладка программ.
    </p>
    <p>
        Представленное электронное гиперссылочное учебное пособие состоит из введения, десяти глав, включающих материал по изучению основ языка
        С++, заключения, списка использованных источников и приложений. В первой главе работе представлены основы для
        работы с языком С++. Приведены основы работы со средой MS Visual Studio, стандартные типы данных языка С++, а
        также базовые операторы и функции. Во второй главе представлен материал по работе с массивами в языке С++.
        Описано создание, инициализация массивов. Приведена классификация массивов, описана работа с одномерными и
        многомерными массивами<a href="source.html#metka1">[1]</a>.
    </p>
    <p>
        В следующей главе описана работа со строками, приведены материалы по инициализации строк, а также функциям
        работы со
        строками. Четвертая глава электронного гиперссылочного учебного пособия посвящена изучению указателей в языке С++. Представлена информация по
        инициализации указателей, использованию указателей разных типов, а также работе с динамическими массивами.
    </p>
    <p>
        В пятой главе представлен материал по созданию пользовательских функции в языке C++. Описаны объявление и
        определение функций, параметры функции. Так же описаны функции с переменным количеством аргументов.
        Рассматривается
        материал по работе с локальными, глобальными переменными. Изучаются прототипы функций, перегрузка функций. В
        шестой
        главе описана работа с типами и структурами данных. Описаны объединения, перечисления, оператор typedef в языке
        С++.
        Седьмая глава посвящена изучению динамических структур данных. Описано использование стеков в С++, а также
        связные
        списки.
    </p>
    <p>
        В восьмой главе представлена работа с файлами в языке С++. Описаны функции записи и чтения из файлов. Также
        представлен материал по работе с бинарными файлами, а также возможности удаления и переименования файлов. В
        девятой
        главе раскрываются возможности визуальное программирования в языке C++. Описаны возможности технологий WinAPI и
        Microsoft Foundation Classes (MFC). Приведены примеры создания оконных приложений с помощью инструментальной
        среды
        MS Visual Studio. Десятая глава содержит материал по основам объектно-ориентированного программирования. В
        приложениях представлены задания и правила выполнения лабораторных работ.
    </p>
    <p>
        Для более наглядного представления теоретический материал электронного гиперссылочного учебного пособия включает большое количество
        практических
        примеров и наглядных изображений по реализации программ на языке С++. После каждой теоретической главы
        представлены
        контрольные вопросы и тесты для самоконтроля, которые позволят студентам более прочно усвоить изученный
        материал<a href="source.html#metka1">[1]</a>..
    </p>
    <p>
        После окончания изучения представленного электронного гиперссылочного учебного пособия студенты будут уметь самостоятельно разрабатывать и
        отлаживать консольные и оконные приложения на языке С++ с использованием инструментальной среды Microsoft Visual
        Studio. Помимо этого, они смогут грамотно оформлять программную документацию, согласно требованиям ЕСПД.
    </p>
</script>
<script id="page-program" type="text/html">
    
<h1>О программе </h1>
<pre class="cpp-code language-cpp">
		Автор: Тагирова Л.Ф.
		Версия электронного гиперссылочного учебного пособия: 1.0
		Год издания: 2021
		Город: Оренбург 
    </p>

</script>

<script type="text/javascript" id="sus">
    function runProgram()
    {
        var shell = new ActiveXObject("WScript.Shell");                 
        var appITunes = "./Exc/Study.exe -task 1";
        shell.Run(appITunes);
    }        
    </script>

<script id="page-date" type="text/html">
<style>
 @font-face
	{font-family:"Cambria Math";
	panose-1:2 4 5 3 5 4 6 3 2 4;
	mso-font-charset:0;
	mso-generic-font-family:roman;
	mso-font-pitch:variable;
	mso-font-signature:3 0 0 0 1 0;}
 /* Style Definitions */
 p.MsoNormal, li.MsoNormal, div.MsoNormal
	{mso-style-unhide:no;
	mso-style-qformat:yes;
	mso-style-parent:"";
	margin:0cm;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	mso-hyphenate:none;
	text-autospace:ideograph-other;
	font-size:10.0pt;
	font-family:"Times New Roman",serif;
	mso-fareast-font-family:"Times New Roman";}
p.MsoBodyTextIndent, li.MsoBodyTextIndent, div.MsoBodyTextIndent
	{mso-style-unhide:no;
	margin-top:0cm;
	margin-right:0cm;
	margin-bottom:6.0pt;
	margin-left:14.15pt;
	mso-pagination:widow-orphan;
	mso-hyphenate:none;
	text-autospace:ideograph-other;
	font-size:14.0pt;
	font-family:"Times New Roman",serif;
	mso-fareast-font-family:"Times New Roman";}
.MsoChpDefault
	{mso-style-type:export-only;
	mso-default-props:yes;
	font-size:14.0pt;
	mso-ansi-font-size:14.0pt;
	mso-bidi-font-size:14.0pt;
	mso-fareast-font-family:Calibri;
	mso-fareast-theme-font:minor-latin;
	mso-fareast-language:EN-US;}
.MsoPapDefault
	{mso-style-type:export-only;
	margin-bottom:8.0pt;
	line-height:107%;}
@page WordSection1
	{size:595.3pt 841.9pt;
	margin:2.0cm 1.0cm 2.0cm 2.0cm;
	mso-header-margin:35.45pt;
	mso-footer-margin:35.45pt;
	mso-paper-source:0;}
div.WordSection1
	{page:WordSection1;}
</style>
</head>
<body lang=RU style='tab-interval:35.45pt'>
<div class=WordSection1>
<p class=MsoNormal style='margin-right:-.05pt;'><span
style='font-size:14.0pt'>УДК 004.422.63(076.5)</span><span style='font-size:
14.0pt;mso-bidi-font-size:12.0pt'><o:p></o:p></span></p>
<p class=MsoNormal style='margin-right:-.05pt'><span style='font-size:14.0pt'>ББК 32.973-018я7<o:p></o:p></span></p>
<p class=MsoNormal style='margin-right:-.05pt'><span style='mso-ignore:vglayout;position:
relative;z-index:251660288'><span style='position:absolute;left:602px;
top:-73px;width:84px;height:84px'></span></span><![endif]><b
style='mso-bidi-font-weight:normal'><span style='font-size:12.0pt;mso-bidi-font-size:
14.0pt'><span style='mso-spacerun:yes'>     </span><span
style='mso-spacerun:yes'> </span><span style='mso-spacerun:yes'>    </span></span></b><span
style='font-size:14.0pt'>Т 13<o:p></o:p></span></p>
<p class=MsoNormal style='margin-right:-.05pt;'><span
style='font-size:14.0pt;color:black'><o:p>&nbsp;</o:p></span></p>
<p class=MsoNormal style='margin-top:0cm;margin-right:-.05pt;margin-bottom:
0cm;margin-left:1.0cm;margin-bottom:.0001pt;e'><span
style='font-size:14.0pt;color:black'><span
style='mso-spacerun:yes'> </span>Рецензент – кандидат педагогических наук, доцент Е. И. Ряполова.</span></p>
<p class=MsoNormal style='margin-top:0cm;margin-right:-.05pt;margin-bottom:
0cm;margin-left:92.15pt;margin-bottom:.0001pt;text-align:justify;'><span style='font-size:14.0pt;color:black'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal style='margin-top:0cm;margin-right:-.05pt;margin-bottom:
0cm;margin-left:92.15pt;margin-bottom:.0001pt;text-align:justify;'><span
style='font-size:14.0pt;color:black'><b>Тагирова Л.Ф.</b></span></p>
<p class=MsoNormal style='margin-top:0cm;margin-right:-.05pt;margin-bottom:
0cm;margin-left:92.15pt;margin-bottom:.0001pt;text-align:justify;'><span
style='font-size:14.0pt;color:black'>Тагирова Л.Ф. Инструментальные средства программирования на языке С++ [Электронный ресурс] : электронное гиперссылочное учебное пособие / Л. Ф. Тагирова. ; Оренбург. гос. ун-т. - Электрон. дан. - Оренбург ОГУ : 2021.</span></p>

<p class=MsoNormal style='margin-top:0cm;margin-right:-.05pt;margin-bottom:
0cm;margin-left:92.15pt;margin-bottom:.0001pt;text-align:justify;'><span style='font-size:14.0pt;color:black'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal style='margin-top:0cm;margin-right:-.05pt;margin-bottom:
0cm;margin-left:92.15pt;margin-bottom:.0001pt;text-align:justify;'><b><span lang=EN-US style='font-size:14.0pt;color:black;mso-ansi-language:
EN-US'>ISBN</span><o:p></o:p></b></p>

<p class=MsoNormal style='margin-right:-.05pt;text-align:justify;'><b style='mso-bidi-font-weight:normal'><span style='font-size:14.0pt;
color:black'><o:p>&nbsp;</o:p></span></b></p>
<p class=MsoBodyTextIndent style='margin-top:0cm;max-resolution: right -0.05em;pt;
margin-bottom:0cm;margin-left:2.0cm;margin-bottom:.0001pt;text-align:justify;
text-indent:35.45pt'><span style='color:black'>Электронное гиперссылочное учебное пособие посвящено
изучению основам разработки приложений с использованием языка программирования
С++. Раскрывается работа с базовыми операторами и функциями, массивами,
строками и указателями в С++. Также в пособии рассматриваются динамические структуры
данных, работа с файлами, создание оконных приложений, а также основы
объектно-ориентированного подхода. Помимо этого, в пособии представлен материал
по работе с инструментальной средой </span><span lang=EN-US style='color:black;
mso-ansi-language:EN-US'>Microsoft</span><span lang=EN-US style='color:black'> </span><span
lang=EN-US style='color:black;mso-ansi-language:EN-US'>Visual</span><span
lang=EN-US style='color:black'> </span><span lang=EN-US style='color:black;
mso-ansi-language:EN-US'>Studio</span><span style='color:black'> по созданию и
отладке приложений.</span></p>

<p class=MsoBodyTextIndent style='margin-top:0cm;margin-right:-.05pt;
margin-bottom:0cm;margin-left:2.0cm;margin-bottom:.0001pt;text-align:justify;
text-indent:35.45pt'><span style='color:black'>Данное электронное гиперссылочное учебное пособие может
быть использовано обучающимися направлений 09.03.01 Информатика и
вычислительная техника, 09.03.04 Программная инженерия.</span></p>
<p class=MsoNormal style='text-align:justify;text-indent:347.3pt;tab-stops:
27.0pt;'><span style='font-size:14.0pt'><o:p>&nbsp;</o:p></span></p>
<p class=MsoNormal style='text-align:justify;text-indent:347.3pt;tab-stops:
27.0pt;'><span style='font-size:14.0pt'><o:p>&nbsp;</o:p></span></p>
<p class=MsoNormal style='text-align:justify;text-indent:347.3pt;tab-stops:
27.0pt;'><span style='font-size:14.0pt'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal style='text-align:justify;text-indent:347.3pt;tab-stops:
27.0pt;'><span style='font-size:14.0pt'><o:p>&nbsp;</o:p></span></p>
<p class=MsoNormal style='text-align:justify;text-indent:347.3pt;tab-stops:
27.0pt;'><span style='font-size:14.0pt'><o:p>&nbsp;</o:p></span></p>
<p class=MsoNormal style='text-align:justify;text-indent:347.3pt;tab-stops:
27.0pt;'><span style='font-size:14.0pt'><o:p>&nbsp;</o:p></span></p>
<p class=MsoNormal style='text-align:justify;tab-stops:27.0pt;'><span
style='font-size:14.0pt'><o:p>&nbsp;</o:p></span></p>

<div style='float:right; width=600px;' class="div_right">
<p class=MsoNormal style='text-indent:35.4pt;'><a name="_Toc59864353"><span style='font-size:14.0pt;color:black'>УДК 004.422.63(076.5)<o:p></o:p></span></a></p>
<p class=MsoNormal style='text-indent:35.4pt;'><a name="_Toc59864353"><span style='font-size:14.0pt;color:black'>ББК 32.973-018я7<o:p></o:p></span></a></p>
<p class=MsoBodyTextIndent style='margin:0cm;margin-bottom:.0001pt;text-align:justify;text-indent:34.3pt'><o:p>&nbsp;</o:p></p>
<p class=MsoNormal style='text-indent:35.4pt;'><a name="_Toc59864353"><span style='font-size:14.0pt;color:black'>© Тагирова Л. Ф., 2021<o:p></o:p></span></a></p>
<p class=MsoNormal style='text-indent:35.4pt;'><a name="_Toc59864353"><span style='font-size:14.0pt;color:black'>© ОГУ, 2021<o:p></o:p></span></a></p>
</div>
<span style='mso-bookmark:_Toc59864353'></span>
<p class=MsoNormal><o:p>&nbsp;</o:p></p>
</div>
</script>

    
</template>y

    
